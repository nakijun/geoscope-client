
{*******************************************************}
{                                                       }
{                 "Virtual Town" project                }
{                                                       }
{               Copyright (c) 1998-2012 PAS             }
{                                                       }
{Authors: Alex Ponomarev <AlxPonom@mail.ru>             }
{                                                       }
{  This program is free software under the GPL (>= v2)  }
{ Read the file COPYING coming with project for details }
{*******************************************************}

{$H+}
unit TypesFunctionality;
interface
uses
  Windows,
  SysUtils,
  MySysUtils,
  SyncObjs,
  ActiveX,
  Classes,
  Variants,
  MSXML,
  SOAPHTTPTrans,
  Controls,
  StdCtrls,
  ComCtrls,
  ExtCtrls,
  Forms,
  Dialogs,
  Graphics,
  GDIPOBJ, GDIPAPI, //. GDI+ support
  PNGImage,
  unitIDsCach,
  {$IFDEF EmbeddedServer}
  SpaceInterfacesImport,
  {$ENDIF}
  FunctionalitySOAPInterface,
  ImgList,
  OpenGL,
  OpenGLEx, {stuff by Mike Lischke}
  GlobalSpaceDefines,
  unitProxySpace,
  unit3DReflector,
  unitReflector,
  unitNodesApproximator,
  SpaceObjInterpretation,
  DB,
  DBTables,
  DBClient,
  TypesDefines,
  unitListObjects,
  UnitLabelsCash,
  ObjectActionsList,
  Functionality,
  unitOpenGL3DSpace,
  GeoTransformations,
  RxGIF;




//. Функциональность системы типов
    function Types__TObjectsManager_Create: TFormObjectActionsList; stdcall;
    function Types__TImageList_Create: TImageList; stdcall;
    function TypesImageList: TImageList; stdcall;
var
    Types_ImageList: TImageList;
//. --------------------------------------------------------------------------





{$I TypesFunctionalityImportInterface.inc}














Type {to be synchronized with DetailedPictureVisualization}
    TTSVSegmentsOGLTextures = class;
    TTTileServerVisualizationCash = class;

    TSystemTTileServerVisualization = class(TBaseVisualizationTypeSystem)
    private
      TileServerDeferredReflectingList: TThreadList;
      LoadingImage: TBitmap;
      EmptySegmentImageDATA: TMemoryStream;
      EmptySegmentImage: TBitmap;
      ContextTypeHolder: TTypeSystemPresentUpdater;
      ProviderLock: TCriticalSection;
    public
      Cash: TTTileServerVisualizationCash;
      ReflectingBMP: TBitmap;
      SegmentsOGLTextures: TTSVSegmentsOGLTextures;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure DoOnReflectorRemoval(const pReflector: TAbstractReflector); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      procedure Context_RemoveItem(const idComponent: integer); override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
      procedure Context_ClearItems(); override;
      procedure Context_ClearInactiveItems(); override;
      procedure DoOnContextIsInitialized(); override; 
    end;

    TTSVTextureSegmentItem = record
      ptrNext: pointer;
      Segment: pointer;
    end;

    TTSVAccessedSegmentItem = record
      ptrNext: pointer;
      Segment: pointer;
      ptrLevel: pointer;
    end;

    TTSVAccessedSegmentsRevising = class(TThread)
    private
      Cache: TTTileServerVisualizationCash;
      Lock: TCriticalSection;
      Segments: pointer;
      SegmentsCount: integer;
      SegmentsMaxCount: integer;

      Constructor Create(const pCache: TTTileServerVisualizationCash);
      Destructor Destroy; override;
      procedure Add(const pSegment: pointer; const pptrLevel: pointer; const pidObj: integer);
      procedure AddByList(const List: TList; const pptrLevel: pointer; const pidObj: integer);
      procedure Remove(const pSegment: pointer);
      function RemoveOld(const Count: integer; out RemoveList: TList): boolean;
      procedure RemoveVisualizationSegments(const ptrVisualizationItem: pointer);
      procedure Clear;
      procedure Execute; override;
    end;

    TTSVPersistLevelsProviding = class(TThread)
    private
      Cache: TTTileServerVisualizationCash;
      Lock: TCriticalSection;
      evtQueryProviding: THandle;
      flServerConnectionIsFast: boolean;
      PersistSegmentsMaxCount: integer;

      Constructor Create(const pCache: TTTileServerVisualizationCash);
      Destructor Destroy; override;
      procedure Execute; override;
      function ServerConnectionIsFast: boolean;
      procedure Provide();
      procedure Providing;
    end;

    TTSVSegmentsOGLTextures = class(TThread)
    private
      TypeSystem: TSystemTTileServerVisualization;
      //.
      DIB: cardinal;
      DIB_BitInfo: TBitmapInfo;
      DIB_DC: cardinal;
      Texture_DC: cardinal;
      //.
      OGLContext: HGLRC;
      //.
      _DrawCanvas_Functionality: TBase2DVisualizationFunctionality; 
      _DrawCanvas_Segments: pointer;
      _DrawCanvas_SegmentsSize: integer;
      _DrawCanvas_SegmentWidth: double;
      _DrawCanvas_SegmentHeight: double;
      _DrawCanvas_XIndexMin: integer;
      _DrawCanvas_YIndexMin: integer;
      _DrawCanvas_dX: Extended;
      _DrawCanvas_dY: Extended;
      _DrawCanvas_WidthScale: Extended;
      _DrawCanvas_HeightScale: Extended;
      _DrawCanvas_Rotation: Extended;
      _DrawCanvas_flBestQuality: boolean;
      _DrawCanvas_Result: boolean;
      _NewTextureSegment: pointer;
      _NewTexturesSegments: TList;
      _DeleteTextureSegment: pointer;
      _DeleteSegmentsTextures: TList;
      OperationLock: TCriticalSection;
      OperationException: Exception;
      evtStart: THandle;
      evtFinished: THandle;
      TexturesMaxCount: integer;
      LastAccessTextureSegments: pointer;
      LastAccessTextureSegmentsCount: integer;

      Constructor Create(const pTypeSystem: TSystemTTileServerVisualization);
      Destructor Destroy; override;
      procedure Execute; override;
      procedure LastAccessTextureSegments_Insert(const pSegment: pointer);
      procedure LastAccessTextureSegments_Remove(const pSegment: pointer);
      procedure LastAccessTextureSegments_RemoveOld(const Count: integer; out RemoveList: TList);
      procedure LastAccessTextureSegments_Clear;
      function DrawOnCanvas(const Functionality: TBase2DVisualizationFunctionality; const Canvas: TCanvas; const Segments: pointer; const SegmentsSize: integer; const SegmentWidth: double; const SegmentHeight: double; const XIndexMin: integer; const YIndexMin: integer; const dX: Extended; const dY: Extended; const WidthScale: Extended; const HeightScale: Extended; const Rotation: Extended; const flBestQuality: boolean): boolean;
      function InstallTexture(const ImageStream: TMemoryStream): cardinal;
      function DoDrawOnCanvas(const Functionality: TBase2DVisualizationFunctionality; const Segments: pointer; const SegmentsSize: integer; const SegmentWidth: double; const SegmentHeight: double; const XIndexMin: integer; const YIndexMin: integer; const dX: Extended; const dY: Extended; const WidthScale: Extended; const HeightScale: Extended; const Rotation: Extended; const flBestQuality: boolean): boolean;
    public
      flEnabled: boolean;
      flInitialized: boolean;
      flStarted: boolean;

      procedure GenerateSegmentTexture(const Segment: pointer);
      procedure GenerateSegmentItemsTextures(const Segments: TList);
      procedure DeleteSegmentTexture(const Segment: pointer);
      procedure DeleteSegmentsItemsTextures(const Segments: TList);
    end;

    TTileServerTileProvider = record
      ServerType: integer;
      ID: integer;
      Name: string;
      URL: string;
      Format: string;
      flIndependentLevels: boolean;
    end;

    TTileServerTileProviders = array of TTileServerTileProvider;

    TTileServerParsedData = class
    public
      TileProviders: TTileServerTileProviders;

      class function GetParsedData(const ServerType: TTileServerType; const ServerData: TByteArray): TTileServerParsedData;

      Destructor Destroy(); override;
      procedure SetDefaults(); virtual; abstract;
      function Clone(): TTileServerParsedData; virtual; abstract;
      function ToByteArray(): TByteArray; virtual; abstract;
      function  TileProviders_ItemIndex(const pID: integer): integer;
      function  TileProviders_GetItemIndex(const pID: integer): integer;
      procedure TileProviders_FreeItem(const ItemIndex: integer);
      procedure TileProviders_Clear();
      function  TileProviders_GetNextID(): integer;
      function  TileProviders_AddNew(const TileProvider: TTileServerTileProvider): integer;
      procedure TileProviders_Delete(const ProviderIndex: integer);
      procedure TileProviders_Set(const ProviderIndex: integer; const TileProvider: TTileServerTileProvider);
    end;

    TNativeTileServerParsedData = class(TTileServerParsedData)
    public
      Constructor Create(); overload;
      Constructor Create(const ServerData: TByteArray); overload;
      procedure SetDefaults(); override;
      function Clone(): TTileServerParsedData; override;
      function ToByteArray(): TByteArray; override;
    end;

    TYandexMapsTileServerParsedData = class(TTileServerParsedData)
    public
      Constructor Create(); overload;
      Constructor Create(const ServerData: TByteArray); overload;
      procedure SetDefaults(); override;
      function Clone(): TTileServerParsedData; override;
      function ToByteArray(): TByteArray; override;
    end;

    TGoogleMapsTileServerParsedData = class(TTileServerParsedData)
    public
      Constructor Create(); overload;
      Constructor Create(const ServerData: TByteArray); overload;
      procedure SetDefaults(); override;
      function Clone(): TTileServerParsedData; override;
      function ToByteArray(): TByteArray; override;
    end;

    TOpenStreetMapsTileServerParsedData = class(TTileServerParsedData)
    public
      Constructor Create(); overload;
      Constructor Create(const ServerData: TByteArray); overload;
      procedure SetDefaults(); override;
      function Clone(): TTileServerParsedData; override;
      function ToByteArray(): TByteArray; override;
    end;

    TNavitelMapsTileServerParsedData = class(TTileServerParsedData)
    public
      Constructor Create(); overload;
      Constructor Create(const ServerData: TByteArray); overload;
      procedure SetDefaults(); override;
      function Clone(): TTileServerParsedData; override;
      function ToByteArray(): TByteArray; override;
    end;

    TItemTTileServerVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;
      ptrObj: TPtr;
      ServerType: integer;
      ServerURL: string;
      ServerData: TByteArray;
      ServerParsedData: TTileServerParsedData;
      TileProviderID: integer;
      Width: integer;
      Height: integer;

      Levels: pointer;
    end;

    TLevelItemOfTTileServerVisualizationCash = packed record
      ptrNext: pointer;
      ptrItem: pointer;
      LevelIndex: integer;
      Lock: TMultiReadExclusiveWriteSynchronizer;
      SegmentLock: TCriticalSection;
      Disabled: boolean;
      flPersist: boolean;
      Params: TTileServerVisualizationLevel;
      Segments: pointer;
    end;

    TSegmentItemOfTTileServerVisualizationCash = packed record
      ptrNext: pointer;
      Lock: TCriticalSection;
      Params: TTileServerVisualizationLevelSegment;
      _idOGLTexture: cardinal;
    end;

    TTileServerDeferredReflecting = class(TThread)
    private
      TypeSystem: TSystemTTileServerVisualization;
      flFinished: boolean;
      flUpdateIsNeeded: boolean;
      flLiveUpdateOnly: boolean;
      ReflectorsList: TThreadList;
      idObj: integer;
      ptrObj: TPtr;
      idLevel: integer;
      XIndexMin,XIndexMax,YIndexMin,YIndexMax: integer;
      ExceptSegments: TByteArray;
      ptrCancelFlag: pointer;

      Constructor Create(const pTypeSystem: TSystemTTileServerVisualization; const pflLiveUpdateOnly: boolean; const pReflector: TReflector; const pidObj: integer; const pptrObj: TPtr; const pidLevel: integer; const pXIndexMin,pXIndexMax,pYIndexMin,pYIndexMax: integer; const pExceptSegments: TByteArray; const pptrCancelFlag: pointer);
      procedure Execute; override;
      function ReflectorsList_Add(const Reflector: TReflector): boolean;
    end;

    TTTileServerVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;
      AccessedSegmentsRevising: TTSVAccessedSegmentsRevising;
      PersistLevelsProviding: TTSVPersistLevelsProviding; 

      function GetPtrItem(const pidObj: integer): pointer;
      function NotRecombinatedGetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
      procedure ConvertDATAToBMP(const DS: TMemoryStream; out BMP: TBitmap);
      procedure Context_DestroyItemSegments(const pidObj: integer);
      procedure Context_DestroyItemSegmentFiles(const pidObj: integer);
      function ParseServerData(const pServerType: TTileServerType; const pServerData: TByteArray): TTileServerParsedData;
    public
      Lock: TMultiReadExclusiveWriteSynchronizer;

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure UpdateLocalForPartialUpdate(const idObj: integer; const Data: TByteArray); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      function NotRecombinatedGetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
      //.
      function SegmentPositionHashCode(X,Y: integer): integer;
      procedure Segment_Lock(const ptrSegment: pointer);
      procedure Segment_UnLock(const ptrSegment: pointer);
      function Segment_SetidOGLTexture(const ptrSegment: pointer; const Value: cardinal): cardinal;
      function Segment_idOGLTexture(const ptrSegment: pointer): cardinal;
      procedure Segment_SetDATA(const ptrSegment: pointer; const pDATA: TMemoryStream);
      function Segment_DATAIsNull(const ptrSegment: pointer): boolean;
      function Segment_DATAIsEmpty(const ptrSegment: pointer): boolean;
      function Segment_DATAIsNotEmpty(const ptrSegment: pointer): boolean;
      //.
      function Item_GetContextFolder(const Item_idObj: integer): string;
      function Item_Level__GetContextFolder(const Item_idObj: integer; const TileProviderID: integer; const idLevel: integer): string;
      function Item_Level__GetSegmentsLocal(const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; out LocalSegments: TByteArray): boolean;
      function Item_Level__GetVisibleSegmentsLocal(const ptrItem: pointer; const pTileProviderID: integer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const flSegmentsInMemory: boolean; const flLoadFromContextFiles: boolean; const ptrCancelFlag: pointer; out ItemsTable: pointer; out ItemsTableSize: integer; out ExceptSegments: TByteArray; const ptrHasEmptySegmentFlag: pointer = nil): boolean;
      function Item_Level__RestoreSegmentsLocal(const ptrItem: pointer; const pTileProviderID: integer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ptrCancelFlag: pointer; out ItemsList: TList; var ExceptSegments: TByteArray): boolean;
      function Item_Level__GenerateSegmentsLocal(const ptrItem: pointer; const pTileProviderID: integer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const MaxDepth: integer; const ptrCancelFlag: pointer; out ItemsList: TList; var ExceptSegments: TByteArray): boolean;
      function Item_Level__DegenerateSegmentsLocal(const ptrItem: pointer; const pTileProviderID: integer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ptrCancelFlag: pointer; out ItemsList: TList): boolean;
      function Item_Level__UpdateSegmentsLocal(const ptrItem: pointer; const pTileProviderID: integer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ExceptSegments: TByteArray; const ptrCancelFlag: pointer): boolean;
      function Item_SetTileProviderID(const ptrItem: pointer; const pTileProviderID: integer): boolean;
    end;

    procedure TTileServerVisualizationCashItem_PrepareLevelsFromByteArray(const pptrItem: pointer; var Levels: pointer; const BA: TByteArray);
    procedure TTileServerVisualizationCashItem_FreeAndNilLevels(const TypeSystem: TSystemTTileServerVisualization; var Levels: pointer);
    procedure TTileServerVisualizationCashItem_FreeAndNilLevelsSegments(const TypeSystem: TSystemTTileServerVisualization; var Levels: pointer);
    function TTileServerVisualizationCashItemLevelSegments_Insert(var Segments: pointer; const ptrSegment: pointer; const ptrptrExistedSegment: pointer = nil): boolean;
    procedure TTileServerVisualizationCashItemLevel_PrepareSegmentsFromByteArray(const TypeSystem: TSystemTTileServerVisualization; const idTileServerVisualization: integer; const TileProviderID: integer; const ptrLevel: pointer; const BA: TByteArray; ItemsList: TList = nil; const flAllItemsInList: boolean = false);
    procedure TTileServerVisualizationCashItemLevel_FreeAndNilSegments(const TypeSystem: TSystemTTileServerVisualization; var Segments: pointer);

var
    SystemTTileServerVisualization: TSystemTTileServerVisualization;













Type
    TSystemTMeasurementObject = class(TTypeSystem)
    public
      Constructor Create; override;
    end;

Var
    SystemTMeasurementObject: TSystemTMeasurementObject;












Type
    TSystemTAreaNotificationServer = class(TTypeSystem)
    public
      Constructor Create; override;
    end;

Var
    SystemTAreaNotificationServer: TSystemTAreaNotificationServer;












Type
    TTMODELServerVisualizationCash = class;
    TSystemTMODELServerVisualization = class;

    TWindowViewDataParams = record
      Reflector: TReflector;
      ServerURL: string;
      InvisibleLayNumbersArray: TByteArray;
      VisibleFactor: integer;
      DynamicHints_VisibleFactor: double;
      Window: TReflectionWindowStruc;
    end;

    TMODELServerVisualizationDeferredReflecting = class(TThread)
    private
      TypeSystem: TSystemTMODELServerVisualization;
      idObj: integer;
      ptrObj: TPtr;
      Params: TWindowViewDataParams;
      ptrCancelFlag: pointer;
      flFinished: boolean;
      flUpdateIsNeeded: boolean;

      Constructor Create(const pTypeSystem: TSystemTMODELServerVisualization; const pidObj: integer; const pptrObj: TPtr; const pParams: TWindowViewDataParams; const pptrCancelFlag: pointer);
      procedure Execute; override;
    end;

    TSystemTMODELServerVisualization = class(TBaseVisualizationTypeSystem)
    private
      DeferredReflectingList: TThreadList;
      VisualizationIsNotLoadedBMP: TBitmap;
    public
      Cash: TTMODELServerVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure DoOnReflectorRemoval(const pReflector: TAbstractReflector); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TWindowViewData = class
    private
      Params: TWindowViewDataParams;
      Data: TMemoryStream;

      Constructor Create(const pParams: TWindowViewDataParams; const pData: TByteArray);
      Destructor Destroy; override;
      class function IsWindowTheSameTo(const Params,pWindowParams: TWindowViewDataParams): boolean; overload;
      function IsWindowTheSameTo(const pWindowParams: TWindowViewDataParams): boolean; overload;
    end;

    TItemTMODELServerVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      ServerURL: string;
      WindowViewData: TWindowViewData;
    end;

    TTMODELServerVisualizationCash = class(TCashTypeSystem)
    private
      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public
      FItems: pointer;

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTMODELServerVisualization: TSystemTMODELServerVisualization;








Type
    TSystemTDoubleVar = class(TTypeSystem)
    public
      Constructor Create; override;
    end;

Var
    SystemTDoubleVar: TSystemTDoubleVar;












Type
    TSystemTInt32Var = class(TTypeSystem)
    public
      Constructor Create; override;
    end;

Var
    SystemTInt32Var: TSystemTInt32Var;












Type
    TSystemTURL = class(TTypeSystem)
    public
      Constructor Create; override;
    end;

Var
    SystemTURL: TSystemTURL;












Type
    TTPatternVisualizationCash = class;

    TSystemTPatternVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTPatternVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
      function CreateContext(const Owner: TComponentContext): TComponentTypeContext; override;
      function InplaceHintEnabled(): boolean; override;
    end;

    TItemTPatternVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;
      //.
      idDATAFile: integer;
    end;

    TPatternVisualizationDATAFile = record
      ptrNext: pointer;
      RefCounter: integer;
      idDATAFile: integer;
      DATA: TBitmap;
      flSaved: boolean;
    end;
    
    TPatternVisualizationDATAFileRepository = class
    private
      Lock: TCriticalSection;
      DATAFiles: pointer;

      Constructor Create;
      Destructor Destroy; override;
      procedure Clear;
      function DATAFile_Exists(const pidDATAFile: integer): boolean;
      function DATAFile_AddRef(const pidDATAFile: integer): boolean;
      function DATAFile_Release(const pidDATAFile: integer): integer;
      function AddDATAFile(const pidDATAFile: integer; const DATAFileDATA: TBitmap): boolean;
    public 
      function DATAFile_Lock(const pidDATAFile: integer; out DATAFilePtr: pointer): boolean;
      procedure DATAFile_Unlock(const DATAFilePtr: pointer);
    end;

    TTPatternVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public
      DATAFileRepository: TPatternVisualizationDATAFileRepository;

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTPatternVisualization: TSystemTPatternVisualization;











Type
    TSystemTMapFormatObject = class(TTypeSystem)
    public
      Constructor Create; override;
    end;

Type
    TMapFormatObjectDATAParser = class
    private
      Doc: IXMLDOMDocument;
    public
      FileSection: ANSIString;
      
      Constructor Create();
      Destructor Destroy; override;
      procedure LoadFromStream(const Stream: TStream);
      procedure SaveToStream(const Stream: TStream);
    end;

Var
    SystemTMapFormatObject: TSystemTMapFormatObject;












Type
    TSystemTMapFormatMap = class(TTypeSystem)
    public
      Constructor Create; override;
    end;

Type
    TMapFormatMapDATAParser = class
    private
      Doc: IXMLDOMDocument;
    public
      Constructor Create(const Stream: TStream);
      Destructor Destroy; override;
      function FileSection(): ANSIString;
    end;

Var
    SystemTMapFormatMap: TSystemTMapFormatMap;












Type
    TTSPLVisualizationCash = class;

    TSystemTSPLVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTSPLVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTSPLVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      SPLType: TSPLVisualizationType;
      SPLDATA: TMemoryStream;
    end;

    TTSPLVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTSPLVisualization: TSystemTSPLVisualization;











Type
    TSystemTGeoSpace = class(TTypeSystem)
    public
      Constructor Create; override;
    end;

Var
    SystemTGeoSpace: TSystemTGeoSpace;












Type
    TSystemTBoolVar = class(TTypeSystem)
    public
      Constructor Create; override;
    end;

Var
    SystemTBoolVar: TSystemTBoolVar;












Type
    TSystemTUserAlert = class(TTypeSystem)
    public
      Constructor Create; override;
    end;

Var
    SystemTUserAlert: TSystemTUserAlert;












Type
    TSystemTGeoGraphServerObject = class(TTypeSystem)
    public
      Constructor Create; override;
    end;

Var
    SystemTGeoGraphServerObject: TSystemTGeoGraphServerObject;












Type
    TSystemTGeoGraphServer = class(TTypeSystem)
    public
      Constructor Create; override;
    end;

Var
    SystemTGeoGraphServer: TSystemTGeoGraphServer;












Type
    TTFilterVisualizationCash = class;

    TSystemTFilterVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTFilterVisualizationCash;
      Reflecting__DIB: cardinal;
      Reflecting__DIB_BitInfo: TBitmapInfo;
      Reflecting__DIB_DC: cardinal;
      Reflecting__DIB_PixelsPtr: pointer;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTFilterVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      FilterType: TFilterVisualizationType;
      FilterDATA: TMemoryStream;
    end;

    TTFilterVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTFilterVisualization: TSystemTFilterVisualization;











Type
    TTHINTVisualizationCash = class;

    TSystemTHINTVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTHINTVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    THintVisualizationParsedDataFontNameString = string[16];
    THintVisualizationParsedDataInfoTextString = string[64];
    THintVisualizationParsedDataStatusInfoTextString = string[16];

    THintVisualizationParsedDataV1 = record
      InfoString: shortstring;
      InfoStringFontName: THintVisualizationParsedDataFontNameString;
      InfoStringFontSize: integer;
      InfoStringFontColor: TColor;
      InfoText: THintVisualizationParsedDataInfoTextString;
      InfoTextFontName: THintVisualizationParsedDataFontNameString;
      InfoTextFontSize: integer;
      InfoTextFontColor: TColor;
      InfoComponent: TID;
      StatusInfoText: THintVisualizationParsedDataStatusInfoTextString;
      Transparency: integer;
    end;

    THintVisualizationDATA = class(TMemoryStream)
    private
      InfoStringFontDefaultName: string;
      InfoStringFontDefaultSize: integer;
      InfoStringFontDefaultColor: TColor;
      InfoTextFontDefaultName: string;
      InfoTextFontDefaultSize: integer;
      InfoTextFontDefaultColor: TColor;
    public
      InfoString: string;
      InfoStringFontName: string;
      InfoStringFontSize: integer;
      InfoStringFontColor: TColor;
      InfoText: string;
      InfoTextFontName: string;
      InfoTextFontSize: integer;
      InfoTextFontColor: TColor;
      InfoComponent: TID;
      StatusInfoText: ANSIString;
      Transparency: integer;

      Constructor Create(const AStream: TStream = nil);
      Destructor Destroy; override;
      procedure ClearProperties;
      procedure GetProperties;
      procedure SetProperties;
    end;

    TItemTHINTVisualizationCash = packed record 
      ptrNext: pointer;
      idObj: integer;
      //.
      idDATAFile: integer;
      //.
      DATA: TMemoryStream;
      ParsedDataV1: THintVisualizationParsedDataV1;
    end;

    THINTVisualizationDATAFile = record
      ptrNext: pointer;
      RefCounter: integer;
      idDATAFile: integer;
      DATA: TBitmap;
      flSaved: boolean;
    end;
    
    THINTVisualizationDATAFileRepository = class
    private
      Lock: TCriticalSection;
      DATAFiles: pointer;

      Constructor Create;
      Destructor Destroy; override;
      procedure Clear;
      function DATAFile_Exists(const pidDATAFile: integer): boolean;
      function DATAFile_AddRef(const pidDATAFile: integer): boolean;
      function DATAFile_Release(const pidDATAFile: integer): integer;
      function AddDATAFile(const pidDATAFile: integer; const DATAFileDATA: TBitmap): boolean;
    public 
      function DATAFile_Lock(const pidDATAFile: integer; out DATAFilePtr: pointer): boolean;
      procedure DATAFile_Unlock(const DATAFilePtr: pointer);
    end;

    TTHINTVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
      procedure DestroyItem(var ptrDestroyItem: pointer);
    public
      DATAFileRepository: THINTVisualizationDATAFileRepository;
      Index: TIDsCach;

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTHINTVisualization: TSystemTHINTVisualization;











Type {to be synchronized with TileServerVisualization}
    TDPVSegmentsOGLTextures = class;
    TTDetailedPictureVisualizationCash = class;

    TSystemTDetailedPictureVisualization = class(TBaseVisualizationTypeSystem)
    private
      DetailedPictureDeferredReflectingList: TThreadList;
      LoadingImage: TBitmap;
      EmptySegmentImageDATA: TMemoryStream;
      EmptySegmentImage: TBitmap;
      ContextTypeHolder: TTypeSystemPresentUpdater;
    public
      Cash: TTDetailedPictureVisualizationCash;
      ReflectingBMP: TBitmap;
      SegmentsOGLTextures: TDPVSegmentsOGLTextures;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure DoOnReflectorRemoval(const pReflector: TAbstractReflector); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      procedure Context_RemoveItem(const idComponent: integer); override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
      procedure Context_ClearItems(); override;
      procedure Context_ClearInactiveItems(); override;
      procedure DoOnContextIsInitialized(); override;
    end;

    TDPVTextureSegmentItem = record
      ptrNext: pointer;
      Segment: pointer;
    end;

    TDPVAccessedSegmentItem = record
      ptrNext: pointer;
      Segment: pointer;
      ptrLevel: pointer;
    end;

    TDPVAccessedSegmentsRevising = class(TThread)
    private
      Cache: TTDetailedPictureVisualizationCash;
      Lock: TCriticalSection;
      Segments: pointer;
      SegmentsCount: integer;
      SegmentsMaxCount: integer;

      Constructor Create(const pCache: TTDetailedPictureVisualizationCash);
      Destructor Destroy; override;
      procedure Add(const pSegment: pointer; const pptrLevel: pointer; const pidObj: integer);
      procedure AddByList(const List: TList; const pptrLevel: pointer; const pidObj: integer);
      procedure Remove(const pSegment: pointer);
      function RemoveOld(const Count: integer; out RemoveList: TList): boolean;
      procedure RemoveVisualizationSegments(const ptrVisualizationItem: pointer);
      procedure Clear;
      procedure Execute; override;
    end;

    TDPVPersistLevelsProviding = class(TThread) 
    private
      Cache: TTDetailedPictureVisualizationCash;
      Lock: TCriticalSection;
      evtQueryProviding: THandle;
      flServerConnectionIsFast: boolean;
      PersistSegmentsMaxCount: integer;

      Constructor Create(const pCache: TTDetailedPictureVisualizationCash);
      Destructor Destroy; override;
      procedure Execute; override;
      function ServerConnectionIsFast: boolean;
      procedure Provide();
      procedure Providing;
    end;

    TDPVSegmentsOGLTextures = class(TThread)
    private
      TypeSystem: TSystemTDetailedPictureVisualization;
      //.
      DIB: cardinal;
      DIB_BitInfo: TBitmapInfo;
      DIB_DC: cardinal;
      Texture_DC: cardinal;
      //.
      OGLContext: HGLRC;
      //.
      _DrawCanvas_Functionality: TBase2DVisualizationFunctionality; 
      _DrawCanvas_Segments: pointer;
      _DrawCanvas_SegmentsSize: integer;
      _DrawCanvas_SegmentWidth: double;
      _DrawCanvas_SegmentHeight: double;
      _DrawCanvas_XIndexMin: integer;
      _DrawCanvas_YIndexMin: integer;
      _DrawCanvas_dX: Extended;
      _DrawCanvas_dY: Extended;
      _DrawCanvas_WidthScale: Extended;
      _DrawCanvas_HeightScale: Extended;
      _DrawCanvas_Rotation: Extended;
      _DrawCanvas_flBestQuality: boolean;
      _DrawCanvas_Result: boolean;
      _NewTextureSegment: pointer;
      _NewTexturesSegments: TList;
      _DeleteTextureSegment: pointer;
      _DeleteSegmentsTextures: TList;
      OperationLock: TCriticalSection;
      OperationException: Exception;
      evtStart: THandle;
      evtFinished: THandle;
      TexturesMaxCount: integer;
      LastAccessTextureSegments: pointer;
      LastAccessTextureSegmentsCount: integer;

      Constructor Create(const pTypeSystem: TSystemTDetailedPictureVisualization);
      Destructor Destroy; override;
      procedure Execute; override;
      procedure LastAccessTextureSegments_Insert(const pSegment: pointer);
      procedure LastAccessTextureSegments_Remove(const pSegment: pointer);
      procedure LastAccessTextureSegments_RemoveOld(const Count: integer; out RemoveList: TList);
      procedure LastAccessTextureSegments_Clear;
      function DrawOnCanvas(const Functionality: TBase2DVisualizationFunctionality; const Canvas: TCanvas; const Segments: pointer; const SegmentsSize: integer; const SegmentWidth: double; const SegmentHeight: double; const XIndexMin: integer; const YIndexMin: integer; const dX: Extended; const dY: Extended; const WidthScale: Extended; const HeightScale: Extended; const Rotation: Extended; const flBestQuality: boolean): boolean;
      function InstallTexture(const ImageStream: TMemoryStream): cardinal;
      function DoDrawOnCanvas(const Functionality: TBase2DVisualizationFunctionality; const Segments: pointer; const SegmentsSize: integer; const SegmentWidth: double; const SegmentHeight: double; const XIndexMin: integer; const YIndexMin: integer; const dX: Extended; const dY: Extended; const WidthScale: Extended; const HeightScale: Extended; const Rotation: Extended; const flBestQuality: boolean): boolean;
    public
      flEnabled: boolean;
      flInitialized: boolean;
      flStarted: boolean;

      procedure GenerateSegmentTexture(const Segment: pointer);
      procedure GenerateSegmentItemsTextures(const Segments: TList);
      procedure DeleteSegmentTexture(const Segment: pointer);
      procedure DeleteSegmentsItemsTextures(const Segments: TList);
    end;

    TItemTDetailedPictureVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;
      ptrObj: TPtr;
      Width: integer;
      Height: integer;

      Levels: pointer;
    end;

    TLevelItemOfTDetailedPictureVisualizationCash = packed record
      ptrNext: pointer;
      ptrItem: pointer;
      LevelIndex: integer;
      Lock: TMultiReadExclusiveWriteSynchronizer;
      SegmentLock: TCriticalSection;
      Disabled: boolean;
      flPersist: boolean;
      Params: TDetailedPictureVisualizationLevel;
      Segments: pointer;
    end;

    TSegmentItemOfTDetailedPictureVisualizationCash = packed record
      ptrNext: pointer;
      Lock: TCriticalSection;
      Params: TDetailedPictureVisualizationLevelSegment;
      _idOGLTexture: cardinal;
    end;

    TDetailedPictureDeferredReflecting = class(TThread)
    private
      TypeSystem: TSystemTDetailedPictureVisualization;
      flFinished: boolean;
      flUpdateIsNeeded: boolean;
      flLiveUpdateOnly: boolean;
      ReflectorsList: TThreadList;
      idObj: integer;
      ptrObj: TPtr;
      idLevel: integer;
      XIndexMin,XIndexMax,YIndexMin,YIndexMax: integer;
      ExceptSegments: TByteArray;
      ptrCancelFlag: pointer;

      Constructor Create(const pTypeSystem: TSystemTDetailedPictureVisualization; const pflLiveUpdateOnly: boolean; const pReflector: TReflector; const pidObj: integer; const pptrObj: TPtr; const pidLevel: integer; const pXIndexMin,pXIndexMax,pYIndexMin,pYIndexMax: integer; const pExceptSegments: TByteArray; const pptrCancelFlag: pointer);
      procedure Execute; override;
      function ReflectorsList_Add(const Reflector: TReflector): boolean;
    end;

    TTDetailedPictureVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;
      AccessedSegmentsRevising: TDPVAccessedSegmentsRevising;
      PersistLevelsProviding: TDPVPersistLevelsProviding; 

      function GetPtrItem(const pidObj: integer): pointer;
      function NotRecombinatedGetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
      procedure ConvertDATAToBMP(const DS: TMemoryStream; out BMP: TBitmap);
      procedure Context_DestroyItemSegmentFiles(const pidObj: integer);
    public
      Lock: TMultiReadExclusiveWriteSynchronizer;

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure UpdateLocalForPartialUpdate(const idObj: integer; const Data: TByteArray); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      function NotRecombinatedGetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
      //.
      function SegmentPositionHashCode(X,Y: integer): integer;
      procedure Segment_Lock(const ptrSegment: pointer);
      procedure Segment_UnLock(const ptrSegment: pointer);
      function Segment_SetidOGLTexture(const ptrSegment: pointer; const Value: cardinal): cardinal;
      function Segment_idOGLTexture(const ptrSegment: pointer): cardinal;
      procedure Segment_SetDATA(const ptrSegment: pointer; const pDATA: TMemoryStream);
      function Segment_DATAIsNull(const ptrSegment: pointer): boolean;
      function Segment_DATAIsEmpty(const ptrSegment: pointer): boolean;
      function Segment_DATAIsNotEmpty(const ptrSegment: pointer): boolean;
      //.
      function Item_GetContextFolder(const Item_idObj: integer): string;
      function Item_Level__GetContextFolder(const Item_idObj: integer; const idLevel: integer): string;
      function Item_Level__GetSegmentsLocal(const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; out LocalSegments: TByteArray): boolean;
      function Item_Level__GetVisibleSegmentsLocal(const ptrItem: pointer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const flSegmentsInMemory: boolean; const flLoadFromContextFiles: boolean; const ptrCancelFlag: pointer; out ItemsTable: pointer; out ItemsTableSize: integer; out ExceptSegments: TByteArray; const ptrHasEmptySegmentFlag: pointer = nil): boolean;
      function Item_Level__RestoreSegmentsLocal(const ptrItem: pointer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ptrCancelFlag: pointer; out ItemsList: TList; var ExceptSegments: TByteArray): boolean;
      function Item_Level__GenerateSegmentsLocal(const ptrItem: pointer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const MaxDepth: integer; const ptrCancelFlag: pointer; out ItemsList: TList; var ExceptSegments: TByteArray): boolean;
      function Item_Level__DegenerateSegmentsLocal(const ptrItem: pointer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ptrCancelFlag: pointer; out ItemsList: TList): boolean;
      function Item_Level__UpdateSegmentsLocal(const ptrItem: pointer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ExceptSegments: TByteArray; const ptrCancelFlag: pointer): boolean;
    end;

    procedure TDetailedPictureVisualizationCashItem_PrepareLevelsFromByteArray(const pptrItem: pointer; var Levels: pointer; const BA: TByteArray);
    procedure TDetailedPictureVisualizationCashItem_FreeAndNilLevels(const TypeSystem: TSystemTDetailedPictureVisualization; var Levels: pointer);
    function TDetailedPictureVisualizationCashItemLevelSegments_Insert(var Segments: pointer; const ptrSegment: pointer; const ptrptrExistedSegment: pointer = nil): boolean;
    procedure TDetailedPictureVisualizationCashItemLevel_PrepareSegmentsFromByteArray(const TypeSystem: TSystemTDetailedPictureVisualization; const idDetailedPictureVisualization: integer; const ptrLevel: pointer; const BA: TByteArray; ItemsList: TList = nil; const flAllItemsInList: boolean = false);
    procedure TDetailedPictureVisualizationCashItemLevel_FreeAndNilSegments(const TypeSystem: TSystemTDetailedPictureVisualization; var Segments: pointer);

var
    SystemTDetailedPictureVisualization: TSystemTDetailedPictureVisualization;













Type
    TTCoVisualizationCash = class;

    TSystemTCoVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTCoVisualizationCash;
      Figure: TFigureWinRefl;
      AdditionalFigure: TFigureWinRefl;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTCoVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      idDATAFile: integer;
      _Space: TMemoryStream;
      _SpaceComponentsUpdaters: TList;
    end;

    TTCoVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
      procedure Context_RemoveSpaceComponents(const ptrItem: pointer);
      procedure CreateSpaceComponentsUpdaters(const ptrItem: pointer);
      procedure FreeSpaceComponentsUpdaters(const ptrItem: pointer);
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
      function GetComponentFile(const pidDATAFile: integer; out DATA: TMemoryStream): boolean;
      function ComponentFileRefCount(const pidDATAFile: integer): integer;
    end;

var
    SystemTCoVisualization: TSystemTCoVisualization;

    function CoVisualization_GetOwnSpaceHINTVisualizationLocally(const idCoVisualization: integer; out idHINTVisualization: integer): boolean;






Type
    TSystemTForumMessage = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTForumMessage: TSystemTForumMessage;







Type
    TSystemTForum = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTForum: TSystemTForum;







Type
    TTCUSTOMVisualizationCash = class;

    TSystemTCUSTOMVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTCUSTOMVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTCUSTOMVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      MODULEName: string;
      FunctionName: string;
      FunctionVersion: integer;
    end;

    TTCUSTOMVisualizationCash = class(TCashTypeSystem)
    private
      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public
      FItems: pointer;

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTCUSTOMVisualization: TSystemTCUSTOMVisualization;








Type
    TTOLEVisualizationCash = class;

    TSystemTOLEVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTOLEVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTOLEVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      WMF: TMetaFile;
      LastUser_ID: integer;
      LastUser_flRead: boolean;
    end;

    TTOLEVisualizationCash = class(TCashTypeSystem)
    private
      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public
      FItems: pointer;

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTOLEVisualization: TSystemTOLEVisualization;













Type
    TTHTMLVisualizationCash = class;

    TSystemTHTMLVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTHTMLVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTHTMLVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      DataStream: TClientBlobStream;
      Width: integer;
      LastUser_ID: integer;
      LastUser_flRead: boolean;
    end;

    TTHTMLVisualizationCash = class(TCashTypeSystem)
    private
      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public
      FItems: pointer;

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTHTMLVisualization: TSystemTHTMLVisualization;













Type
    TSystemTBZRVisualization = class(TBaseVisualizationTypeSystem)
    public
      Constructor Create; override;
    end;
var
    SystemTBZRVisualization: TSystemTBZRVisualization;





Type
    TTAGIFVisualizationCash = class;

    TSystemTAGIFVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTAGIFVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TAGIFData = class(TThread)
    private
      Space: TProxySpace;
      Lock: TCriticalSection;
      RefCount: integer;
      DATA: TGIFImage;
      Interval: integer;
      BMP: TBitmap;
      FrameID: integer;
      NullRefTime: TDateTime;

      Constructor Create(pSpace: TProxySpace; const pidTObj,pidObj: integer; const MS: TMemoryStream = nil);
      Destructor Destroy; override;
      procedure Execute; override;
    end;

    TTAGIFVisualizationAGIFDataTracker = class(TThread)
    private
      Cash: TTAGIFVisualizationCash;

      Constructor Create(pCash: TTAGIFVisualizationCash);
      Destructor Destroy; override;
      procedure Execute; override;
    end;

    TItemTAGIFVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      AGIFData: TAGIFData;
    end;

    TTAGIFVisualizationCash = class(TCashTypeSystem)
    private
      AGIFDataTracker: TTAGIFVisualizationAGIFDataTracker;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public
      FItems: pointer;

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTAGIFVisualization: TSystemTAGIFVisualization;
Type
    TAGIFVisualizationUpdating = class(TThread)
    private
      Reflecting: TReflecting;
      Functionality: TComponentFunctionality;
      Interval: integer;
      ptrItem: pointer;
      LastFrameID: integer;

      Constructor Create(pReflecting: TReflecting; pFunctionality: TComponentFunctionality);
      Destructor Destroy; override;
      procedure Execute; override;
      procedure Update;
    end;












Type
    TTOrientedVIDEOVisualizationCash = class;

    TSystemTOrientedVIDEOVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTOrientedVIDEOVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TVIDEOData = class;
    
    TAUDIOData = class(TThread)
    private
      VIDEOData: TVIDEOData;

      Constructor Create(pVIDEOData: TVIDEOData);
      Destructor Destroy; override;
      procedure Execute; override;
    end;

    TVIDEOData = class(TThread)
    private
      Space: TProxySpace;
      idTObj: integer;
      idObj: integer;
      Lock: TCriticalSection;
      RefCount: integer;
      DataServer: string;
      ObjectID: integer;
      Interval: integer;
      FrameBuffer: PSafeArray;
      LastFrameID: integer;
      NullRefTime: TDateTime;
      AUDIOData: TAUDIOData;

      Constructor Create(pSpace: TProxySpace; const pidTObj,pidObj: integer; const pDataServer: string; const pObjectID: integer);
      Destructor Destroy; override;
      procedure Execute; override;
    end;

    TItemTOrientedVIDEOVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      VIDEOData: TVIDEOData;
    end;

    TVIDEODataTracker = class(TThread)
    private
      Cash: TTOrientedVIDEOVisualizationCash;

      Constructor Create(pCash: TTOrientedVIDEOVisualizationCash);
      Destructor Destroy; override;
      procedure Execute; override;
    end;

    TTOrientedVIDEOVisualizationCash = class(TCashTypeSystem)
    private
      VIDEODataTracker: TVIDEODataTracker;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public
      FItems: pointer;

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTOrientedVIDEOVisualization: TSystemTOrientedVIDEOVisualization;

Type
    TOrientedVIDEOVisualizationUpdating = class(TThread)
    private
      Reflecting: TReflecting;
      Functionality: TComponentFunctionality;
      
      Constructor Create(pReflecting: TReflecting; pFunctionality: TComponentFunctionality);
      Destructor Destroy; override;
      procedure Execute; override;
    end;


Type
    TTVIDEOVisualizationCash = class;

    TSystemTVIDEOVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTVIDEOVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTVIDEOVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      VIDEOData: TVIDEOData;
    end;

    TTVIDEOVisualizationVIDEODataTracker = class(TThread)
    private
      Cash: TTVIDEOVisualizationCash;

      Constructor Create(pCash: TTVIDEOVisualizationCash);
      Destructor Destroy; override;
      procedure Execute; override;
    end;

    TTVIDEOVisualizationCash = class(TCashTypeSystem)
    private
      VIDEODataTracker: TTVIDEOVisualizationVIDEODataTracker;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public
      FItems: pointer;

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTVIDEOVisualization: TSystemTVIDEOVisualization;


Type
    TVIDEOVisualizationUpdating = class(TThread)
    private
      Reflecting: TReflecting;
      Functionality: TComponentFunctionality;
      
      Constructor Create(pReflecting: TReflecting; pFunctionality: TComponentFunctionality);
      Destructor Destroy; override;
      procedure Execute; override;
    end;


Type
    TTOPPVisualizationCash = class;

    TSystemTOPPVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTOPPVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTOPPVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      PropsPanel_idTObj: integer;
      PropsPanel_idObj: integer;
      PropsPanel: TForm;
      PropsPanelBMP: TBitmap;
      flLock: boolean;
      LockReflector: TAbstractReflector;
    end;

    TTOPPVisualizationCash = class(TCashTypeSystem)
    private
      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public
      FItems: pointer;

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
      function GetPanel(const pidObj: integer; const Reflector: TAbstractReflector;  out oPropsPanel: TForm; out oPropsPanelBMP: TBitmap): boolean;
    end;

var
    SystemTOPPVisualization: TSystemTOPPVisualization;




    


Type
    TSystemTMODELServer = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTMODELServer: TSystemTMODELServer;









    


Type
    TSystemTCoReference = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTCoReference: TSystemTCoReference;








    


Type
    TSystemTPositioner = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTPositioner: TSystemTPositioner;








    


Type
    TTOrientedWMFVisualizationCash = class;

    TSystemTOrientedWMFVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTOrientedWMFVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTOrientedWMFVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      idDATAFile: integer;
      WMF: TMetaFile;
      Width: Double;
      Height: Double;
      Orientation: integer;
    end;

    TTOrientedWMFVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
      function GetComponentFile(const pidDATAFile: integer; out DATA: TMemoryStream): boolean;
    end;

var
    SystemTOrientedWMFVisualization: TSystemTOrientedWMFVisualization;










Type
    TTCELLVisualizationCash = class;

    TSystemTCELLVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTCELLVisualizationCash;
      ReflectingFigure: TFigureWinRefl;
      ReflectingFigureLock: TCriticalSection;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTCELLVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      ColCount: integer;
      RowCount: integer;
      LineWidth: Double;
    end;

    TTCELLVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTCELLVisualization: TSystemTCELLVisualization;











Type
    TTEllipseVisualizationCash = class;

    TSystemTEllipseVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTEllipseVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTEllipseVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      BorderWidth: Double;
    end;

    TTEllipseVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTEllipseVisualization: TSystemTEllipseVisualization;












Type
    TTWMFVisualizationCash = class;

    TSystemTWMFVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTWMFVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTWMFVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      idDATAFile: integer;
      WMF: TMetaFile;
    end;

    TTWMFVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
      function GetComponentFile(const pidDATAFile: integer; out DATA: TMemoryStream): boolean;
    end;

var
    SystemTWMFVisualization: TSystemTWMFVisualization;









    


Type
    TTPictureVisualizationCash = class;

    TSystemTPictureVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTPictureVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTPictureVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      idDATAFile: integer;
      BMP: TBitmap;
      VisibleMinScale: double;
      VisibleMaxScale: double;
    end;

    TTPictureVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
      procedure ConvertDATAToBMP(const DS: TMemoryStream; const CDT: TComponentFileType; out BMP: TBitmap);
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
      function GetComponentFile(const pidDATAFile: integer; out DATA: TMemoryStream): boolean;
    end;

var
    SystemTPictureVisualization: TSystemTPictureVisualization;










Type
    TTRoundVisualizationCash = class;

    TSystemTRoundVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTRoundVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTRoundVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      BorderWidth: Double;
    end;

    TTRoundVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTRoundVisualization: TSystemTRoundVisualization;












Type
    TTGeoCrdSystemCash = class;

    TSystemTGeoCrdSystem = class(TTypeSystem)
    public
      Cash: TTGeoCrdSystemCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      procedure Context_RemoveItem(const idComponent: integer);
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
      procedure Context_ClearItems(); override;
      procedure DoOnContextIsInitialized(); override;
      procedure Component_CheckCachedState(const idComponent: integer);
    end;

    TGeoCrdSystemBoundsPoint = packed record
      ptrNext: pointer;
      X,Y: TCrd;
      Lat,Long: double;
    end;

    TItemTGeoCrdSystemCash = packed record
      ptrNext: pointer;
      idObj: integer;
      //.
      idTOwner: integer;
      idOwner: integer;
      //.
      GeoSpaceID: integer;
      Name: string;
      Datum: string;
      Projection: string;
      ProjectionDATA: TMemoryStream;
      CalibrationPoints: TByteArray;
      Bounds_idTVisualization: integer;
      Bounds_idVisualization: integer;
      Bounds: pointer;
      Bounds_minX: double;
      Bounds_minY: double;
      Bounds_maxX: double;
      Bounds_maxY: double;
      Bounds_minLat: double;
      Bounds_minLong: double;
      Bounds_maxLat: double;
      Bounds_maxLong: double;
    end;

    TTGeoCrdSystemCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
      procedure UpdateItemsBounds;
    end;

    procedure TGeoCrdSystemBounds_Clear(var Bounds: pointer);

var
    SystemTGeoCrdSystem: TSystemTGeoCrdSystem;







Type
    TTSystemTGeodesyPointCrdSysCash = class;

    TSystemTGeodesyPoint = class(TTypeSystem)
    public
      CrdSysCache: TTSystemTGeodesyPointCrdSysCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
    end;

    TItemOfTSystemTGeodesyPointCrdSysCash = packed record
      idCrdSys: integer;
      GeodesyPointsList: TList;
    end;

    TTSystemTGeodesyPointCrdSysCash = class(TCashTypeSystem)
    private
      CrdSysList: TList;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      procedure CrdSys_AddGeodesyPoints(const pidCrdSys: integer; Points: TByteArray);
      function CrdSys_GetNearestGeoPoints(const idCrdSys: integer; const pLatitude,pLongitude: double; const PointsCount: integer; out Points: TByteArray): boolean;
      function CrdSys_GetNearestXYPoints(const idCrdSys: integer; const pX,pY: double; const PointsCount: integer; out Points: TByteArray): boolean;
    end;

Var
    SystemTGeodesyPoint: TSystemTGeodesyPoint;












Type
    TTPrivateAreaVisualizationCash = class;

    TSystemTPrivateAreaVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTPrivateAreaVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
    end;


    TItemTPrivateAreaVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      idTOwner: integer;
      idOwner: integer;
    end;

    TTPrivateAreaVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetOwner(const idObj: integer; var vidTOwner,vidOwner: integer): boolean;
    end;

var
    SystemTPrivateAreaVisualization: TSystemTPrivateAreaVisualization;
















Type
    TSystemTHyperText = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTHyperText: TSystemTHyperText;








Type
    TSystemTComponentsFindService = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTComponentsFindService: TSystemTComponentsFindService;









Type
    TSystemTUsersService = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTUsersService: TSystemTUsersService;









Type
    TSystemTTransportService = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTTransportService: TSystemTTransportService;

















Type
    TSystemTMarketService = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTMarketService: TSystemTMarketService;










Type
    TSystemTTelecomService = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTTelecomService: TSystemTTelecomService;










Type
    TTWNDVisualizationCash = class;

    TSystemTWNDVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTWNDVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTWNDVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      DATAPtr: pointer;
      DATASize: integer;
    end;

    TTWNDVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTWNDVisualization: TSystemTWNDVisualization;













Type
    TTMRKVisualizationCash = class;

    TSystemTMRKVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTMRKVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTMRKVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      idDATAFile: integer;
      DATAPtr: pointer;
      DATASize: integer;
      Align: TMRKVisualizationAlign;
      BindingPointIndex: integer;
    end;

    TTMRKVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
      function GetComponentFile(const pidDATAFile: integer; out DATA: TMemoryStream): boolean;
    end;

var
    SystemTMRKVisualization: TSystemTMRKVisualization;











Type
    TTOrientedPictureVisualizationCash = class;

    TSystemTOrientedPictureVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTOrientedPictureVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;

    TItemTOrientedPictureVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      idDATAFile: integer;
      DATAPtr: pointer;
      DATASize: integer;
      Width: Double;
      Height: Double;
      Orientation: integer;
    end;

    TTOrientedPictureVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
      function GetComponentFile(const pidDATAFile: integer; out DATA: TMemoryStream): boolean;
    end;

var
    SystemTOrientedPictureVisualization: TSystemTOrientedPictureVisualization;











Type
    TTOrientedTTFVisualizationCash = class;

    TSystemTOrientedTTFVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTOrientedTTFVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;


    TStringOrientedTTFVisualization = String;
    TFontNameOrientedTTF = String;
    
    TItemTOrientedTTFVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      Str: WideString;
      Font_Width: Double;
      Font_Height: Double;
      Font_Name: WideString;
      CharInterval: Double;
      Orientation: integer;
    end;

    TTOrientedTTFVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; var S: WideString; var vFont_Width,vFont_Height: Double; var vFont_Name: WideString; var vCharInterval: Double; var vOrientation: integer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTOrientedTTFVisualization: TSystemTOrientedTTFVisualization;















    




Type
    TSystemTIcon = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTIcon: TSystemTIcon;










Type
    TSystemTMessageBoardMessage = class(TTypeSystem)
    public
      Constructor Create; override;
      procedure DoOnComponentOperationLocal(const pidTObj,pidObj: integer; const Operation: TComponentOperation); override;
    end;
Var
    SystemTMessageBoardMessage: TSystemTMessageBoardMessage;








Type
    TSystemTMessageBoard = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTMessageBoard: TSystemTMessageBoard;









Type
    TSystemTHREF = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTHREF: TSystemTHREF;






Type
    TTQDCVisualizationCash = class;

    TSystemTQDCVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTQDCVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
    end;


    TItemTQDCVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      DATAPtr: pointer;
      DATASize: integer;
    end;

    TTQDCVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const idObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTQDCVisualization: TSystemTQDCVisualization;









Type
    TSystemTOffersServer = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTOffersServer: TSystemTOffersServer;





    
Type
    TSystemTSecurityComponentOperation = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTSecurityComponentOperation: TSystemTSecurityComponentOperation;









Type
    TSystemTSecurityKey = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTSecurityKey: TSystemTSecurityKey;






Type
    TSystemTSecurityFile = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTSecurityFile: TSystemTSecurityFile;







         


Type
    TSystemTSecurityComponent = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTSecurityComponent: TSystemTSecurityComponent;

















Type
    TSystemTMODELUser = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTMODELUser: TSystemTMODELUser;







    

  
Type
    TSystemTTexture = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTTexture: TSystemTTexture;





Type
    TTBuffered3DVisualizationCash = class;

    TSystemTBuffered3DVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTBuffered3DVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
    end;


    TTransforMatrix = array[0..3,0..3] of TGLFloat;
    
    TItemTBuffered3DVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      Meshes: TMeshes;
      TransforMatrix: TTransforMatrix;
      Scale: Double;
      Translate_X: Double;
      Translate_Y: Double;
      Translate_Z: Double;
      Rotate_AngleX: Double;
      Rotate_AngleY: Double;
      Rotate_AngleZ: Double;
    end;

    TMeshesList = class
    public
      Cash: TTBuffered3DVisualizationCash;
      FMeshes: TMeshes;

      Constructor Create(pCash: TTBuffered3DVisualizationCash);
      Destructor Destroy; override;

      procedure Clear;
      function Insert(const pidSourceFile: integer; const InstallTextureProc: TInstallTextureProc): TMeshes;
      procedure Delete(var Meshes: TMeshes);
    end;

    TTBuffered3DVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;
      MeshesList: TMeshesList;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
      function InstallTexture(const Material: TMaterial): cardinal;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      function GetItem(const idObj: integer; out ptrItem: pointer): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
      procedure RecompileMeshesDisplayLists;
    end;

var
    SystemTBuffered3DVisualization: TSystemTBuffered3DVisualization;







Type
    TSystemTDATAFile = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTDATAFile: TSystemTDATAFile;






Type
    TSystemTCoComponent = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTCoComponent: TSystemTCoComponent;





    


Type
    TSystemTCoComponentTypeMarker = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTCoComponentTypeMarker: TSystemTCoComponentTypeMarker;



    

Type
    TSystemTCoComponentType = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTCoComponentType: TSystemTCoComponentType;




Type
    TSystemTAddress = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTAddress: TSystemTAddress;




Type
    TSystemTTransportRoute = class(TTypeSystem)
    public
      Constructor Create; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
    end;
Var
    SystemTTransportRoute: TSystemTTransportRoute;
Type
    TItemRouteNodesList = record
      idNode: integer;
      idItem: integer;
    end;

    TRouteNodesList = class(TList)
    public
      Destructor Destroy; override;
      procedure Clear;
      procedure AddNode(const pidNode: integer; const pidItem: integer);
    end;



Type
    TSystemTTransportNode = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTTransportNode: TSystemTTransportNode;


Type
    TSystemTOfferGoods = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTOfferGoods: TSystemTOfferGoods;

    procedure MeasureUnits_NormalizeName(MUName: string; out NN: string);
    function MeasureUnits_GetEqualUnit(const MUName: string; out idMeasureUnit: integer): boolean;
    function MeasureUnits_CreateInstance(const pName: string): integer;
    procedure MeasureUnits_GetInstanceList(var List: TStringList);

type
    TMeasureUnitFunctionality = class(TFunctionality)
    private
      function getName: string;
    public
      idObj: integer;
      Constructor Create(const pidObj: integer);
      property Name: string read getName;
    end;


Type
    TSystemTTLFStationTMT = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTTLFStationTMT: TSystemTTLFStationTMT;



    {ProxyObject функциональность перенесена в Functionality unit}

Type
    TSystemTName = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTName: TSystemTName;






Type
    TTVisualizationCash = class;

    TSystemTVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      function CreateContext(const Owner: TComponentContext): TComponentTypeContext; override;
      function InplaceHintEnabled(): boolean; override;
    end;


    TItemTVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      idTOwner: integer;
      idOwner: integer;
    end;

    TTVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      function GetOwner(const idObj: integer; var vidTOwner,vidOwner: integer): boolean;
    end;

var
    SystemTVisualization: TSystemTVisualization;






Type
    TSystemTHREFVisualization = class(TSystemTVisualization)
    public
      Constructor Create; override;
    end;
var
    SystemTHREFVisualization: TSystemTHREFVisualization;






Type
  TStringTTFVisualization = String;
  TFontNameTTF = String;
Type
    TTTTFVisualizationCash = class;

    TSystemTTTFVisualization = class(TBaseVisualizationTypeSystem)
    public
      Cash: TTTTFVisualizationCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
      procedure Caching_Start; override;
      procedure Caching_AddObject(const idObj: integer); override;
      procedure Caching_Finish; override;
      function  Context_IsItemExist(const idComponent: integer): boolean; override;
      procedure Context_GetItems(out IDs: TIDArray); override;
      procedure RegisterTTF;
      procedure UnRegisterTTF;
    end;


    TItemTTTFVisualizationCash = packed record
      ptrNext: pointer;
      idObj: integer;

      Str: WideString;
      Font_Width: Double;
      Font_Height: Double;
      Font_Name: WideString;
    end;

    TTTTFVisualizationCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateByObjectsList(List: TList);
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      procedure SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement); override;
      procedure LoadItems(Node: IXMLDOMNode); override;
      function GetItem(const pidObj: integer; var S: WideString; var vFont_Width,vFont_Height: Double; var vFont_Name: WideString): boolean;
      procedure GetItemsIDs(out IDs: TIDArray);
    end;

var
    SystemTTTFVisualization: TSystemTTTFVisualization;






Type
    TSystemTObject = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTObject: TSystemTObject;






Type
    TSystemTLabel = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTLabel: TSystemTLabel;
    LabelsCash: TLabelsCash;






Type
    TSystemTStation = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTStation: TSystemTStation;


Type
    TSystemTMainLine = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTMainLine: TSystemTMainLine;





Type
    TSystemTDescription = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTDescription: TSystemTDescription;






Type
    TSystemTImage = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTImage: TSystemTImage;





Type
    TSystemTWell = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTWell: TSystemTWell;





Type
    TSystemTTLF = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTTLF: TSystemTTLF;


    





Type
    TSystemTBox = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTBox: TSystemTBox;








Type
    TSystemTCableBox = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTCableBox: TSystemTCableBox;







    

Type
    TSystemTDistrLine = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTDistrLine: TSystemTDistrLine;













Type
    TSystemTClient = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTClient: TSystemTClient;




    




Type
    TSystemTHouse = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTHouse: TSystemTHouse;





    





Type
    TSystemTCommNode = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTCommNode: TSystemTCommNode;




    


Type
    TSystemTCross = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTCross: TSystemTCross;




    


Type
    TSystemTCase = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTCase: TSystemTCase;


    



Type
    TSystemTStreet = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTStreet: TSystemTStreet;





    


Type
    TSystemTOtherObj = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTOtherObj: TSystemTOtherObj;




    



Type
    TSystemTSpan = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTSpan: TSystemTSpan;






    

Type
    TSystemTChanel = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTChanel: TSystemTChanel;




    




Type
    TSystemTHandHold = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTHandHold: TSystemTHandHold;





    


Type
    TSystemTLineDist = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTLineDist: TSystemTLineDist;






    


Type
    TSystemTMuff = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTMuff: TSystemTMuff;




    





Type
    TSystemTOffer = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTOffer: TSystemTOffer;







    


Type
    TSystemTDemand = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTDemand: TSystemTDemand;








    

Type
    TSystemTCommLine = class(TTypeSystem)
    public
      Constructor Create; override;
    end;
Var
    SystemTCommLine: TSystemTCommLine;







    

Type
    TTGoodsCash = class;

    TSystemTGoods = class(TTypeSystem)
    public
      Cash: TTGoodsCash;

      Constructor Create; override;
      Destructor Destroy; override;
      procedure Initialize; override;
    end;

    TItemTGoodsCash = packed record
      ptrNext: pointer;
      idObj: integer;

      ptrName: pointer; {Name -> (Size: word; Buffer[0..Size-1] of byte)}
    end;

    TTGoodsCash = class(TCashTypeSystem)
    private
      FItems: pointer;

      function GetPtrItem(const pidObj: integer): pointer;
      procedure RemoveItem(const pidObj: integer); override;
    public

      Constructor Create(pTypeSystem: TTypeSystem); override;
      destructor Destroy; override;
      procedure Empty; override;
      procedure Update; override;
      procedure UpdateLocal(const pidObj: integer; const Operation: TComponentOperation); override;
      function GetItem(const idObj: integer; var Name: string): boolean;
      function GetItemByPtr(const ptrItem: pointer; var Name: string): boolean;
    end;

Var
    SystemTGoods: TSystemTGoods;



Type
    TSystemTCollection = class(TTypeSystem)
    public
      Constructor Create; override;
      procedure DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation); override;
    end;

var
    SystemTCollection: TSystemTCollection;


Type
    TItemCollectionStruc = packed record
      id: integer;
      idTItem: integer;
      idItem: integer;
      Alias: string;
      ListOrder: integer;
    end;




//. ---------------------------------------------------------------------------------------------










{$I TypesFunctionalityInterface.inc}
{$I TypesFunctionalityExportInterface.inc}










Type
    TMapFormatObjectDATAPanel = class(TForm)
    public
      MapFormatObjectFunctionality: TMapFormatObjectFunctionality;
      
      Constructor Create(const pMapFormatObjectFunctionality: TMapFormatObjectFunctionality); virtual;
      Destructor Destroy; override;
      procedure UpdatePanel; virtual; abstract;
      function Dialog(): boolean; virtual; abstract;
    end;

//. ---------------------------------------------------------------------------------------------










    procedure Initialize; stdcall;
    procedure Finalize; stdcall;
    //.
    procedure ProcessOnInitializationEndTasks; stdcall;
    function CoComponentFunctionality_idCoType(const idCoComponent: integer): integer; stdcall;
    function GetCreateCompletionObject(const idTPrototype,idPrototype: integer): TCreateCompletionObject; stdcall;
    procedure CheckForNewUserMessages; stdcall;


implementation
Uses
  INIFiles,
  unitEventLog,
  Math,
  unitCRC,
  unitSpline,
  File3DS, {stuff by Mike Lischke}
  Geometry, {stuff by Mike Lischke}
  Types3DS, {stuff by Mike Lischke}
  GraphicEx, {stuff by Mike Lischke}
  JPEG,
  IJL,
  VFW,
  ShellAPI,
  Messages,
  Sockets,
  IdException,
  IdHTTP,
  unitObjectReflectingCfg,
  unitTextInput,
  unitMODELUserMessages,
  unitUserChat,
  unitMODELServersHistory,
  unitSpaceFunctionalServer,
  unitSpaceDataServerClient,
  unitAreaNotificationServer,
  //. (component's representation) Property-Panel units
  unitAddressPanelProps,
  unitTransportRoutePanelProps,
  unitTransportNodePanelProps,
  unitNamePanelProps,
  unitVisualizationPanelProps,
  unitTTFVisualizationPanelProps,
  unitObjectPanelProps,
  unitLabelPanelProps,
  unitStationPanelProps,
  unitMainLinePanelProps,
  unitDescriptionPanelProps,
  unitImagePanelProps,
  unitWellPanelProps,
  unitTLFPanelProps,
  unitBoxPanelProps,
  unitCableBoxPanelProps,
  unitCommNodePanelProps,
  unitCrossPanelProps,
  unitCasePanelProps,
  unitDistrLinePanelProps,
  unitClientPanelProps,
  unitStreetPanelProps,
  unitHousePanelProps,
  unitOtherObjPanelProps,
  unitSpanPanelProps,
  unitChanelPanelProps,
  unitHandHoldPanelProps,
  unitLineDistPanelProps,
  unitMuffPanelProps,
  unitOfferPanelProps,
  unitDemandPanelProps,
  unitCommLinePanelProps,
  unitGoodsPanelProps,
  unitCollectionPanelProps,
  unitTLFStationTMTPanelProps,
  unitOfferGoodsPanelProps,
  unitLay2DVisualizationPanelProps,
  unitCoComponentTypePanelProps,
  unitCoComponentTypeMarkerPanelProps,
  unitCoComponentPanelProps,
  unitDATAFilePanelProps,
  unitMODELUserPanelProps,
  unitBuffered3DVisualizationPanelProps,
  unitTexturePanelProps,
  unitSecurityComponentPanelProps,
  unitSecurityFilePanelProps, unitSecurityFileFunctionality,
  unitSecurityKeyPanelProps,
  unitSecurityComponentOperationPanelProps,
  unitOffersServerPanelProps,
  unitQDCVisualizationPanelProps,
  unitHREFPanelProps, unitInetFileDownloader,
  unitMessageBoardPanelProps,
  unitMessageBoardMessagePanelProps,
  unitIconPanelProps,
  unitOrientedTTFVisualizationPanelProps,
  unitOrientedPictureVisualizationPanelProps,
  unitMRKVisualizationPanelProps,
  unitWNDVisualizationPanelProps,
  unitTelecomServicePanelProps,
  unitMarketServicePanelProps,
  unitTransportServicePanelProps,
  unitUsersServicePanelProps,
  unitComponentsFindServicePanelProps,
  unitHyperTextPanelProps,
  unitPrivateAreaVisualizationPanelProps,
  unitGeodesyPointPanelProps,
  unitRoundVisualizationPanelProps,
  unitPictureVisualizationPanelProps,
  unitWMFVisualizationPanelProps,
  unitEllipseVisualizationPanelProps,
  unitCELLVisualizationPanelProps,
  unitOrientedWMFVisualizationPanelProps,
  unitPositionerPanelProps,
  unitCoReferencePanelProps,
  unitMODELServerPanelProps,
  unitOPPVisualizationPanelProps, unitPropsPanelsRepository,
  unitOrientedVIDEOVisualizationPanelProps, MMSystem, VIDEODataServer_TLB,
  unitVIDEOVisualizationPanelProps,
  unitAGIFVisualizationPanelProps,
  unitBZRVisualizationPanelProps,
  unitHTMLVisualizationPanelProps, HTMLString, HTMLFile, QuickHTML {copyright by Ars?ne von Wyss: avonwyss@beaulieu-software.ch}, ExtActns,
  unitOLEVisualizationPanelProps, MyOLECtnrs,
  unitCUSTOMVisualizationPanelProps,
  unitForumPanelProps,
  unitForumMessagePanelProps,
  unitCoVisualizationPanelProps,
  unitDetailedPictureVisualizationPanelProps, unitDetailedPictureLevels,
  unitHINTVisualizationPanelProps,
  unitFilterVisualizationPanelProps,
  unitGeoSpacePanelProps,
  unitGeoCrdSystemPanelProps,
  unitGeoGraphServerPanelProps,
  unitGeoGraphServerObjectPanelProps,
  unitUserAlertPanelProps,
  unitBoolVarPanelProps,
  unitSPLVisualizationPanelProps,
  unitMapFormatMapPanelProps, unitPolishMapFormatDefines, unitPFMLoader,
  unitMapFormatObjectPanelProps, unitPolishMapFormatObjectDataPanel,
  unitPatternVisualizationPanelProps,
  unitURLPanelProps,
  unitInt32VarPanelProps,
  unitDoubleVarPanelProps,
  unitMODELServerVisualizationPanelProps,
  unitAreaNotificationServerPanelProps,
  unitMeasurementObjectPanelProps,
  unitTileServerVisualizationPanelProps, unitTileServerVisualizationLevels;
  {unitXXXXPanelProps,}















function FormatFloat(const Format: string; Value: Extended): string;
begin
DecimalSeparator:='.';
Result:=SysUtils.FormatFloat(Format,Value);
end;

function StrToFloat(const S: string): Extended;
begin
DecimalSeparator:='.';
Result:=SysUtils.StrToFloat(S);
end;


function Types__TObjectsManager_Create: TFormObjectActionsList;
var
  Item: TItemActionsList;
begin
Result:=nil;
Result:=TFormObjectActionsList.Create;
end;


function Types__TImageList_Create: TImageList;
var
  I: integer;
  BMP: TTypeImage;
  TypeFunctionality: TTypeFunctionality;
begin
Result:=TImageList.CreateSize(32,32);
try
BMP:=TTypeImage.Create;
try
for I:=0 to TypesSystem.Count-1 do begin
  TypeFunctionality:=TTypeSystem(TypesSystem[I]).TypeFunctionalityClass.Create;
  with TypeFunctionality do
  try
  BMP.Assign(Image);
  finally
  Release;
  end;
  Result.Add(BMP,nil);
  end;
finally
BMP.Destroy;
end;
except
  Result.Destroy;
  Result:=nil;
  Raise; //. =>
  end;
end;


function TypesImageList: TImageList;
begin
Result:=Types_ImageList;
end;




Type
  TUserUnreadMessagesChecking = class(TThread)
  private
    TypesSystem: TTypesSystem;
    flForceChecking: boolean;
    Counter: integer;
    fmMODELUserMessages: TfmMODELUserMessages;

    Constructor Create(pTypesSystem: TTypesSystem);
    Destructor Destroy; override;
    procedure Execute; override;
    function HaveNewMessages: boolean;
    procedure ProcessOnNewMessages;
  end;

var
  UserUnreadMessagesChecking: TUserUnreadMessagesChecking;

procedure CheckForNewUserMessages;
begin
if (UserUnreadMessagesChecking <> nil) then UserUnreadMessagesChecking.flForceChecking:=true;
end;

Constructor TUserUnreadMessagesChecking.Create(pTypesSystem: TTypesSystem);
begin
TypesSystem:=pTypesSystem;
Counter:=0;
flForceChecking:=false;
fmMODELUserMessages:=nil;
Inherited Create(true);
Priority:=tpIdle;
end;

Destructor TUserUnreadMessagesChecking.Destroy;
begin
if (Suspended) then Resume();
Inherited;
//.
fmMODELUserMessages.Free;
end;

procedure TUserUnreadMessagesChecking.Execute;
const
  CheckInterval = 600*10; {10 minuts}

  procedure Process;
  begin
  if (TypesSystem.Space.flOffline OR (TypesSystem.Space.State = psstDestroying)) then Exit; //. ->
  //.
  if (HaveNewMessages) then Synchronize(ProcessOnNewMessages);
  end;

begin
repeat
  if flForceChecking
   then begin
    try
    Process;
    except
      end;
    flForceChecking:=false;
    end
   else
    if ((Counter MOD CheckInterval) = 0)
     then
      try
      Process;
      except
        end;
  Sleep(100);
  Inc(Counter);
until Terminated;
end;

function TUserUnreadMessagesChecking.HaveNewMessages: boolean;
begin
with TModelUserFunctionality(TComponentFunctionality_Create(idTMODELUser,TypesSystem.Space.UserID)) do
try
Result:=HaveUnreadMessages;
finally
Release;
end;
end;

procedure TUserUnreadMessagesChecking.ProcessOnNewMessages;
begin
if (fmMODELUserMessages = nil)
 then begin
  fmMODELUserMessages:=TfmMODELUserMessages.Create(TypesSystem.Space.UserID,true);
  if (fmMODELUserMessages.lvMessages.Items.Count > 0)
   then begin
    fmMODELUserMessages.lbAnnotation.Caption:='! Your post box(es) has a mail';
    fmMODELUserMessages.Show;
    end
   else
    FreeAndNil(fmMODELUserMessages);
  end
 else begin
  fmMODELUserMessages.Update;
  if (fmMODELUserMessages.lvMessages.Items.Count > 0) then fmMODELUserMessages.Show();
  end;
end;

function CoComponentFunctionality_idCoType(const idCoComponent: integer): integer;
var
  idTypeMarker,idMarker: integer;
begin
with TComponentFunctionality_Create(idTCoComponent,idCoComponent) do
try
if QueryComponent(idTCoComponentTypeMarker, idTypeMarker,idMarker)
 then with TCoComponentTypeMarkerFunctionality(TComponentFunctionality_Create(idTypeMarker,idMarker)) do
  try
  Result:=idCoComponentType;
  finally
  Release;
  end
 else Result:=0;
finally
Release;
end;
end;

function GetCreateCompletionObject(const idTPrototype,idPrototype: integer): TCreateCompletionObject;
begin
Result:=nil;
if (idTPrototype = idTCoComponent)
 then Result:=TCreateCompletionObject(ProxySpace.Plugins__GetCreateCompletionObjectForCoComponentType(CoComponentFunctionality_idCoType(idPrototype)));
if (Result = nil) then ; //. TODO: for builtin types
end;




//. GDI+ support
procedure DrawUsingGDIPus(const CanvasHandle: THandle; const BMP: TBitmap; const Left,Top,Width,Height: integer);
var
  GDIPlusGraphics: TGPGraphics;
  GDIPlusBitmap: TGPBitmap;
begin
GDIPlusGraphics:=TGPGraphics.Create(CanvasHandle);
try
GDIPlusBitmap:=TGPBitmap.Create(BMP.Handle,BMP.Palette);
try
GDIPlusGraphics.DrawImage(GDIPlusBitmap, Left,Top, Width,Height);
finally
GDIPlusBitmap.Destroy;
end;
finally
GDIPlusGraphics.Destroy;
end;
end;

//. JPEG support
function GetBitmapFromJPEGStream(const JPEGStream: TMemoryStream; const Bitmap: TBitmap): boolean;
var
  iWidth, iHeight, iNChannels: Integer;
  iDIBChannels: integer;
  iStatus: integer;
  jcprops: TJPEG_CORE_PROPERTIES;
  DIB: TDIBSection;
begin
Result:=False;
IJL_Lock.Enter;
try
iDIBchannels:=3;
FillChar(jcprops,SizeOf(jcprops),0);
iStatus:=ijlInit(@jcprops);
if (iStatus = IJL_OK)
 then
  try
  jcprops.JPGBytes:=JPEGStream.Memory;
  jcprops.JPGSizeBytes:=JPEGStream.Size;
  iStatus:=ijlRead(@jcprops,IJL_JBUFF_READPARAMS);
  if (iStatus = IJL_OK)
   then begin
    iWidth:=jcprops.JPGWidth;
    iHeight:=jcprops.JPGHeight;
    iNChannels:=jcprops.JPGChannels;
    if (iNChannels = 3)
     then begin
      iDIBChannels:=iNChannels;
      Bitmap.Width:=iWidth;
      Bitmap.Height:=iHeight;
      FillChar(DIB,SizeOf(DIB),0);
      iStatus:=GetObject(Bitmap.Handle,SizeOf(DIB),@DIB);
      if (iStatus <> 0)
       then begin
        jcprops.DIBWidth:=iWidth;
        jcprops.DIBHeight:=-iHeight;
        jcprops.DIBChannels:=iDIBChannels;
        jcprops.DIBColor:=IJL_BGR;
        jcprops.DIBPadBytes:=((((iWidth*iDIBChannels)+3) div 4)*4)-(iWidth*iDIBChannels);
        jcprops.DIBBytes:=System.PByte(DIB.dsBm.bmBits);
        iStatus:=ijlRead(@jcprops,IJL_JBUFF_READWHOLEIMAGE);
        Result:=(iStatus >= 0);
        end;
      end;
    end;
  finally
  ijlFree(@jcprops);
  end;
finally
IJL_Lock.Leave;
end;
end;










//. Tile-Server-Visualization
{TSystemTTileServerVisualization}

procedure TTileServerVisualizationCashItemLevel_FreeAndNilSegments(const TypeSystem: TSystemTTileServerVisualization; var Segments: pointer);
var
  ptrDestroySegment: pointer;
begin
while (Segments <> nil) do begin
  ptrDestroySegment:=Segments;
  Segments:=TSegmentItemOfTTileServerVisualizationCash(ptrDestroySegment^).ptrNext;
  //.
  if (TypeSystem.SegmentsOGLTextures.flEnabled AND (TypeSystem.Cash.Segment_idOGLTexture(ptrDestroySegment) <> 0)) then TypeSystem.SegmentsOGLTextures.DeleteSegmentTexture(ptrDestroySegment);
  //.
  TypeSystem.Cash.Segment_SetDATA(ptrDestroySegment,nil);
  //.
  TypeSystem.Cash.AccessedSegmentsRevising.Remove(ptrDestroySegment);
  //.
  FreeMem(ptrDestroySegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
  end;
end;


procedure TTileServerVisualizationCashItem_FreeAndNilLevels(const TypeSystem: TSystemTTileServerVisualization; var Levels: pointer);
var
  ptrDestroyLevel: pointer;
begin
while (Levels <> nil) do begin
  ptrDestroyLevel:=Levels;
  Levels:=TLevelItemOfTTileServerVisualizationCash(ptrDestroyLevel^).ptrNext;
  //.
  TLevelItemOfTTileServerVisualizationCash(ptrDestroyLevel^).Lock.BeginWrite;
  try
  TTileServerVisualizationCashItemLevel_FreeAndNilSegments(TypeSystem,TLevelItemOfTTileServerVisualizationCash(ptrDestroyLevel^).Segments);
  finally
  TLevelItemOfTTileServerVisualizationCash(ptrDestroyLevel^).Lock.EndWrite;
  end;
  //.
  TLevelItemOfTTileServerVisualizationCash(ptrDestroyLevel^).SegmentLock.Destroy;
  //.
  TLevelItemOfTTileServerVisualizationCash(ptrDestroyLevel^).Lock.Destroy;
  //.
  FreeMem(ptrDestroyLevel,SizeOf(TLevelItemOfTTileServerVisualizationCash));
  end;
end;

procedure TTileServerVisualizationCashItem_FreeAndNilLevelsSegments(const TypeSystem: TSystemTTileServerVisualization; var Levels: pointer);
var
  ptrLevel: pointer;
begin
ptrLevel:=Levels;
while (ptrLevel <> nil) do begin
  TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.BeginWrite();
  try
  TTileServerVisualizationCashItemLevel_FreeAndNilSegments(TypeSystem,TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Segments);
  finally
  TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.EndWrite();
  end;
  //.
  ptrLevel:=TLevelItemOfTTileServerVisualizationCash(ptrLevel^).ptrNext;
  end;
end;

procedure TTileServerVisualizationCashItem_PrepareLevelsFromByteArray(const pptrItem: pointer; var Levels: pointer; const BA: TByteArray);
var
  LevelsCount: integer;
  I: integer;
  ptrNewLevel: pointer;
begin
LevelsCount:=(Length(BA) DIV SizeOf(TTileServerVisualizationLevel));
for I:=0 to LevelsCount-1 do begin
  GetMem(ptrNewLevel,SizeOf(TLevelItemOfTTileServerVisualizationCash));
  with TLevelItemOfTTileServerVisualizationCash(ptrNewLevel^) do begin
  ptrNext:=Levels;
  ptrItem:=pptrItem;
  //.
  LevelIndex:=LevelsCount-I-1;
  Lock:=TMultiReadExclusiveWriteSynchronizer.Create;
  SegmentLock:=TCriticalSection.Create;
  Disabled:=false;
  flPersist:=false;
  Params:=TTileServerVisualizationLevel(Pointer(@BA[I*SizeOf(TTileServerVisualizationLevel)])^);
  Segments:=nil;
  end;
  Levels:=ptrNewLevel;
  end;
end;


function TTileServerVisualizationCashItemLevelSegments_Insert(var Segments: pointer; const ptrSegment: pointer; const ptrptrExistedSegment: pointer = nil): boolean;
var
  XI,YI: integer;
  ptrptrSegment: pointer;
begin
with TSegmentItemOfTTileServerVisualizationCash(ptrSegment^).Params do begin
XI:=XIndex;
YI:=YIndex;
end;
//.
ptrptrSegment:=@Segments;
while (Pointer(ptrptrSegment^) <> nil) AND (YI > TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).Params.YIndex) do begin
  ptrptrSegment:=@TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).ptrNext;
  end;
while (Pointer(ptrptrSegment^) <> nil) AND ((YI = TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).Params.YIndex) AND (XI > TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).Params.XIndex)) do begin
  ptrptrSegment:=@TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).ptrNext;
  end;
if (NOT ((Pointer(ptrptrSegment^) <> nil) AND ((YI = TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).Params.YIndex) AND (XI = TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).Params.XIndex))))
 then begin
  TSegmentItemOfTTileServerVisualizationCash(ptrSegment^).ptrNext:=Pointer(ptrptrSegment^);
  Pointer(ptrptrSegment^):=ptrSegment;
  Result:=true;
  end
 else begin
  if (ptrptrExistedSegment <> nil) then Pointer(ptrptrExistedSegment^):=Pointer(ptrptrSegment^);
  Result:=false;
  end;
end;

procedure TTileServerVisualizationCashItemLevel_PrepareSegmentsFromByteArray(const TypeSystem: TSystemTTileServerVisualization; const idTileServerVisualization: integer; const TileProviderID: integer; const ptrLevel: pointer; const BA: TByteArray; ItemsList: TList = nil; const flAllItemsInList: boolean = false);
var
  P,Pend: pointer;
  LevelFolder: string;
  ptrNewSegment: pointer;
  DATASize: integer;
  SegmentFileName: string;
  ptrExistedItem: pointer;
begin
with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
Lock.BeginRead;
try
P:=@BA[0];
Pend:=Pointer(Integer(P)+Length(BA));
if (P <> Pend)
 then begin
  LevelFolder:=TypeSystem.Cash.Item_Level__GetContextFolder(idTileServerVisualization,TileProviderID,Params.ID);
  ForceDirectories(LevelFolder);
  repeat
    GetMem(ptrNewSegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
    with TSegmentItemOfTTileServerVisualizationCash(ptrNewSegment^) do begin
    ptrNext:=nil;
    Lock:=TLevelItemOfTTileServerVisualizationCash(ptrLevel^).SegmentLock;
    with Params do begin
    id:=Integer(P^); Inc(DWord(P),SizeOf(id));
    XIndex:=Integer(P^); Inc(DWord(P),SizeOf(XIndex));
    YIndex:=Integer(P^); Inc(DWord(P),SizeOf(YIndex));
    DATASize:=Integer(P^); Inc(DWord(P),SizeOf(DATASize));
    _DATA:=TMemoryStream.Create;
    if (DATASize > 0)
     then begin
      _DATA.Size:=DATASize;
      _DATA.Write(P^,DATASize);
      Inc(DWord(P),DATASize);
      end;
    end;
    _idOGLTexture:=0;
    end;
    //.
    Lock.BeginWrite;
    try
    if (TTileServerVisualizationCashItemLevelSegments_Insert(Segments,ptrNewSegment,@ptrExistedItem))
     then begin
      TypeSystem.Cash.AccessedSegmentsRevising.Add(ptrNewSegment,ptrLevel,idTileServerVisualization); //. process segment as accessed
      if (ItemsList <> nil) then ItemsList.Add(ptrNewSegment);
      end
     else begin
      if ((ItemsList <> nil) AND flAllItemsInList) then ItemsList.Add(ptrExistedItem);
      FreeAndNil(TSegmentItemOfTTileServerVisualizationCash(ptrNewSegment^).Params._DATA);
      FreeMem(ptrNewSegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
      ptrNewSegment:=nil;
      end;
    finally
    Lock.EndWrite;
    end;
    //.
    if (ptrNewSegment <> nil)
     then with TSegmentItemOfTTileServerVisualizationCash(ptrNewSegment^).Params do begin //. save new segment into the local file
      //.
      TypeSystem.Cash.Segment_Lock(ptrNewSegment);
      try
      if ((_DATA <> nil) AND (_DATA.Size > 0))
       then begin
        SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
        if (NOT FileExists(SegmentFileName))
         then begin
          _DATA.Position:=0;
          _DATA.SaveToFile(SegmentFileName);
          end;
        end;
      finally
      TypeSystem.Cash.Segment_Unlock(ptrNewSegment);
      end;
      end;
  until (P = Pend);
  end;
finally
Lock.EndRead;
end;
end;
end;


Constructor TSystemTTileServerVisualization.Create;
var
  EmptySegmentJI: TJPegImage;
begin
CreateNew(idTTileServerVisualization,tnTTileServerVisualization,TTTileServerVisualizationFunctionality);
ProviderLock:=TCriticalSection.Create();
TileServerDeferredReflectingList:=TThreadList.Create;
if Enabled then Cash:=TTTileServerVisualizationCash.Create(Self);
//.
ReflectingBMP:=TBitmap.Create;
ReflectingBMP.HandleType:=bmDIB;
ReflectingBMP.PixelFormat:=pf24bit;
//.
LoadingImage:=TBitmap.Create;
LoadingImage.LoadFromFile(Space.WorkLocale+'\'+PathLib+'\BMP'+'\'+'Loading.bmp');
//.
EmptySegmentImageDATA:=TMemoryStream.Create;
EmptySegmentImageDATA.LoadFromFile('TypesDef\TileServerVisualization\SegmentNotExist.jpg');
EmptySegmentImage:=TBitmap.Create;
EmptySegmentImage.HandleType:=bmDIB;
EmptySegmentImage.PixelFormat:=pf24bit;
EmptySegmentJI:=TJPegImage.Create;
try
EmptySegmentImageDATA.Position:=0;
EmptySegmentJI.LoadFromStream(EmptySegmentImageDATA);
EmptySegmentImage.Assign(EmptySegmentJI);
finally
EmptySegmentJI.Destroy;
end;
//.
SegmentsOGLTextures:=TTSVSegmentsOGLTextures.Create(Self);
//. to do: make following more optimally 
ContextTypeHolder:=TContextTypeHolder_Create();
end;

Destructor TSystemTTileServerVisualization.Destroy;
begin
ContextTypeHolder.Free;
//.
EmptySegmentImage.Free;
EmptySegmentImageDATA.Free;
LoadingImage.Free;
ReflectingBMP.Free;
Cash.Free;
TileServerDeferredReflectingList.Free;
SegmentsOGLTextures.Free();
ProviderLock.Free();
Inherited;
end;

procedure TSystemTTileServerVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTTileServerVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTTileServerVisualization.DoOnReflectorRemoval(const pReflector: TAbstractReflector);
var
  DeferredReflectings: TList;
  I: integer;
  _ReflectorsList: TList;
  J: integer;
begin
DeferredReflectings:=TileServerDeferredReflectingList.LockList();
try
for I:=0 to DeferredReflectings.Count-1 do with TTileServerDeferredReflecting(DeferredReflectings[I]) do begin
  _ReflectorsList:=ReflectorsList.LockList();
  try
  for J:=0 to _ReflectorsList.Count-1 do
    if (TAbstractReflector(_ReflectorsList[J]) = pReflector)
     then begin
      _ReflectorsList.Delete(J); 
      Break; //. >
      end; 
  finally
  ReflectorsList.UnlockList();
  end;
  end;
finally
TileServerDeferredReflectingList.UnlockList();
end;
end;

procedure TSystemTTileServerVisualization.Caching_Start;
begin
end;

procedure TSystemTTileServerVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTTileServerVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTTileServerVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.NotRecombinatedGetPtrItem(idComponent) <> nil);
end;

procedure TSystemTTileServerVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;

procedure TSystemTTileServerVisualization.Context_ClearInactiveItems();

  procedure ProcessItem(const ptrItem: pointer; const pFigure,pAdditiveFigure: TFigureWinRefl);
  type
    TReflectingBound = record
      XIndexMin: integer;
      YIndexMin: integer;
      XIndexMax: integer;
      YIndexMax: integer;
    end;

    TReflectingBounds = array of TReflectingBound;
    
    TLevelItem = record
      Level: pointer;
      ReflectingBounds: TReflectingBounds;
    end;

    TLevelItems = array of TLevelItem;

    procedure ProcessReflector(const Reflector: TReflector; const ptrObject: TPtr; const pFigure,pAdditiveFigure: TFigureWinRefl; var LevelItems: TLevelItems);

      procedure GetReflectionWindowLevelContainerIndexes(const X0,Y0: double; const X1,Y1: double; const X3,Y3: double; const pReflectionWindow: TReflectionWindow; const SW,SH: double; out XIndexMin,XIndexMax,YIndexMin,YIndexMax: integer);

        procedure ProcessPoint(X,Y: double; out dX,dY: double);
        var
          QdA2: Extended;
          X_C,X_QdC,X_A1,X_QdB2: Extended;
          Y_C,Y_QdC,Y_A1,Y_QdB2: Extended;
        begin
        QdA2:=sqr(X-X0)+sqr(Y-Y0);
        //.
        X_QdC:=sqr(X1-X0)+sqr(Y1-Y0);
        X_C:=Sqrt(X_QdC);
        X_QdB2:=sqr(X-X1)+sqr(Y-Y1);
        X_A1:=(X_QdC-X_QdB2+QdA2)/(2*X_C);
        //.
        Y_QdC:=sqr(X3-X0)+sqr(Y3-Y0);
        Y_C:=Sqrt(Y_QdC);
        Y_QdB2:=sqr(X-X3)+sqr(Y-Y3);
        Y_A1:=(Y_QdC-Y_QdB2+QdA2)/(2*Y_C);
        //.
        dX:=X_A1;
        dY:=Y_A1;
        end;

      var
        dX,dY: double;
        dXMin,dYMin,dXMax,dYMax: double;
      begin
      pReflectionWindow.Lock.Enter;
      try
      ProcessPoint(pReflectionWindow.Xmn,pReflectionWindow.Ymn, dXMin,dYMin);
      dXMax:=dXMin; dYMax:=dYMin;
      ProcessPoint(pReflectionWindow.Xmx,pReflectionWindow.Ymn, dX,dY);
      if (dX < dXMin)
       then dXMin:=dX
       else
        if (dX > dXMax)
         then dXMax:=dX;
      if (dY < dYMin)
       then dYMin:=dY
       else
        if (dY > dYMax)
         then dYMax:=dY;
      ProcessPoint(pReflectionWindow.Xmx,pReflectionWindow.Ymx, dX,dY);
      if (dX < dXMin)
       then dXMin:=dX
       else
        if (dX > dXMax)
         then dXMax:=dX;
      if (dY < dYMin)
       then dYMin:=dY
       else
        if (dY > dYMax)
         then dYMax:=dY;
      ProcessPoint(pReflectionWindow.Xmn,pReflectionWindow.Ymx, dX,dY);
      if (dX < dXMin)
       then dXMin:=dX
       else
        if (dX > dXMax)
         then dXMax:=dX;
      if (dY < dYMin)
       then dYMin:=dY
       else
        if (dY > dYMax)
         then dYMax:=dY;
      finally
      pReflectionWindow.Lock.Leave;
      end;
      //.
      XIndexMin:=Trunc(dXMin/SW); XIndexMax:=Trunc(dXMax/SW);
      YIndexMin:=Trunc(dYMin/SH); YIndexMax:=Trunc(dYMax/SH);
      end;

    var
      X0,Y0,X1,Y1: Double;
      diffX1X0,diffY1Y0: Double;
      _Width: Double;
      Level: pointer;
      ptrLevel: pointer;
      MinFactor: Double;
      Factor: Double;
      LI: integer;
      flLevelFound: boolean;
      I: integer;
      Alfa: Double;
      b: Double;
      V: Double;
      S0_X3,S0_Y3: Double;
      S1_X3,S1_Y3: Double;
      Xc,Yc: double;
      diffX3X0,diffY3Y0: Double;
      SW,SH: Double;
      XIndexMin,XIndexMax,YIndexMin,YIndexMax: integer;
      RI: integer;
    begin
    with TItemTTileServerVisualizationCash(ptrItem^) do
    with Reflector.Reflecting do begin
    Obj_PrepareFigures(ptrObject, Reflector.ReflectionWindow,WindowRefl, pFigure,pAdditiveFigure);
    if (pAdditiveFigure.CountScreenNodes > 0) OR (pFigure.CountScreenNodes > 0)
     then begin
      with pFigure do begin
      X0:=Nodes[0].X;Y0:=Nodes[0].Y;
      X1:=Nodes[1].X;Y1:=Nodes[1].Y;
      diffX1X0:=X1-X0;
      diffY1Y0:=Y1-Y0;
      _Width:=Sqrt(sqr(diffX1X0)+sqr(diffY1Y0));
      b:=(pFigure.Width*Reflector.ReflectionWindow.Scale);
      end;
      //. get reflector active level
      Level:=nil;
      MinFactor:=MaxDouble;
      ptrLevel:=TItemTTileServerVisualizationCash(ptrItem^).Levels;
      while (ptrLevel <> nil) do with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
        Lock.BeginRead;
        try
        if (NOT Disabled)
         then begin
          Factor:=Abs(Params.SegmentWidth*Params.DivX/_Width-1);
          if (Factor < MinFactor)
           then begin
            Level:=ptrLevel;
            MinFactor:=Factor;
            end;
          end;
        finally
        Lock.EndRead;
        end;
        //. next level
        ptrLevel:=ptrNext;
        end;
      //.
      if (Level <> nil)
       then begin
        TLevelItemOfTTileServerVisualizationCash(Level^).Lock.BeginRead;
        try
        if (diffX1X0 > 0) AND (diffY1Y0 >= 0)
         then Alfa:=2*PI+ArcTan(-diffY1Y0/diffX1X0)
         else
          if (diffX1X0 < 0) AND (diffY1Y0 > 0)
           then Alfa:=PI+ArcTan(-diffY1Y0/diffX1X0)
           else
            if (diffX1X0 < 0) AND (diffY1Y0 <= 0)
             then Alfa:=PI+ArcTan(-diffY1Y0/diffX1X0)
             else
              if (diffX1X0 > 0) AND (diffY1Y0 < 0)
               then Alfa:=ArcTan(-diffY1Y0/diffX1X0)
               else
                if diffY1Y0 > 0
                 then Alfa:=3*PI/2
                 else Alfa:=PI/2;
        if Abs(diffY1Y0) > Abs(diffX1X0)
         then begin
          V:=(b/2)/Sqrt(1+Sqr(diffX1X0/diffY1Y0));
          S0_X3:=(V)+X0;
          S0_Y3:=(-V)*(diffX1X0/diffY1Y0)+Y0;
          S1_X3:=(-V)+X0;
          S1_Y3:=(V)*(diffX1X0/diffY1Y0)+Y0;
          end
         else begin
          V:=(b/2)/Sqrt(1+Sqr(diffY1Y0/diffX1X0));
          S0_Y3:=(V)+Y0;
          S0_X3:=(-V)*(diffY1Y0/diffX1X0)+X0;
          S1_Y3:=(-V)+Y0;
          S1_X3:=(V)*(diffY1Y0/diffX1X0)+X0;
          end;
        if (3*PI/4 <= Alfa) AND (Alfa < 7*PI/4)
         then begin Xc:=S0_X3; Yc:=S0_Y3 end
         else begin Xc:=S1_X3; Yc:=S1_Y3 end;
        diffX3X0:=(X0-Xc)*2;
        diffY3Y0:=(Y0-Yc)*2;
        with TLevelItemOfTTileServerVisualizationCash(Level^) do begin
        //. get ReflectionWindow level container indexes
        SW:=_Width/Params.DivX;
        SH:=b/Params.DivY;
        GetReflectionWindowLevelContainerIndexes(Xc,Yc, Xc+diffX1X0,Yc+diffY1Y0, Xc+diffX3X0,Yc+diffY3Y0, Reflector.ReflectionWindow, SW,SH,  XIndexMin,XIndexMax,YIndexMin,YIndexMax);
        if (XIndexMin < 0) then XIndexMin:=0;
        if (XIndexMax >= Params.DivX) then XIndexMax:=Params.DivX-1;
        if (XIndexMin > XIndexMax) then Exit; //. ->
        if (YIndexMin < 0) then YIndexMin:=0;
        if (YIndexMax >= Params.DivY) then YIndexMax:=Params.DivY-1;
        if (YIndexMin > YIndexMax) then Exit; //. ->
        end;
        //. get level item
        flLevelFound:=false;
        for I:=0 to Length(LevelItems)-1 do
          if (LevelItems[I].Level = Level)
           then begin
            LI:=I;
            flLevelFound:=true;
            Break; //. >
            end;
        if (NOT flLevelFound)
         then begin
          LI:=Length(LevelItems);
          SetLength(LevelItems,Length(LevelItems)+1);
          FillChar(LevelItems[LI],SizeOf(LevelItems[LI]), 0);
          LevelItems[LI].Level:=Level;
          end;
        //. create new reflecting bound
        with LevelItems[LI] do begin
        RI:=Length(ReflectingBounds);
        SetLength(ReflectingBounds,Length(ReflectingBounds)+1);
        //.
        ReflectingBounds[RI].XIndexMin:=XIndexMin;
        ReflectingBounds[RI].YIndexMin:=YIndexMin;
        ReflectingBounds[RI].XIndexMax:=XIndexMax;
        ReflectingBounds[RI].YIndexMax:=YIndexMax;
        end;
        finally
        TLevelItemOfTTileServerVisualizationCash(Level^).Lock.EndRead;
        end;
        end;
      end;
    end;
    end;

  var
    I,J: integer;
    LevelItems: TLevelItems;
    ptrLevel: pointer;
    flLevelProcessed: boolean;
    ptrptrSegment: pointer;
    flSegmentVisible: boolean;
    ptrDestroySegment: pointer;
    ///? LevelFolder: string;
    ///? SegmentFileName: string;
  begin
  SetLength(LevelItems,0);
  try
  with TItemTTileServerVisualizationCash(ptrItem^) do begin
  if ((ptrObj = nilPtr) OR (NOT Space.Obj_IsCached(ptrObj))) then Exit; //. ->
  for I:=0 to Space.ReflectorsList.Count-1 do if (TObject(Space.ReflectorsList[I]) is TReflector) then ProcessReflector(TReflector(Space.ReflectorsList[I]), ptrObj, pFigure,pAdditiveFigure, LevelItems);
  //. reforming levels
  ptrLevel:=Levels;
  while (ptrLevel <> nil) do with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
    Lock.BeginRead;
    try
    if (NOT flPersist)
     then begin
      ///? LevelFolder:=Cash.Item_Level__GetContextFolder(idObj,TileProviderID,Params.ID);
      ///? ForceDirectories(LevelFolder);
      flLevelProcessed:=false;
      for I:=0 to Length(LevelItems)-1 do with LevelItems[I] do
        if (ptrLevel = Level)
         then begin
          ptrptrSegment:=@Segments;
          while (Pointer(ptrptrSegment^) <> nil) do with TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^) do begin
            flSegmentVisible:=false;
            for J:=0 to Length(ReflectingBounds)-1 do with ReflectingBounds[J] do
              if (((XIndexMin <= Params.XIndex) AND (Params.XIndex <= XIndexMax)) AND ((YIndexMin <= Params.YIndex) AND (Params.YIndex <= YIndexMax)))
               then begin
                flSegmentVisible:=true;
                Break; //. >
                end;
            if (NOT flSegmentVisible)
             then begin
              //. remove from list
              TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.BeginWrite;
              try
              ptrDestroySegment:=Pointer(ptrptrSegment^);
              Pointer(ptrptrSegment^):=TSegmentItemOfTTileServerVisualizationCash(ptrDestroySegment^).ptrNext;
              finally
              TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.EndWrite;
              end;
              //.
              with TSegmentItemOfTTileServerVisualizationCash(ptrDestroySegment^) do begin
              if (SegmentsOGLTextures.flEnabled AND (Cash.Segment_idOGLTexture(ptrDestroySegment) <> 0)) then SegmentsOGLTextures.DeleteSegmentTexture(ptrDestroySegment);
              Cash.Segment_Lock(ptrDestroySegment);
              try
              if (Params._DATA <> nil)
               then begin
                {///? SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(Params.XIndex)+'Y'+IntToStr(Params.YIndex)+'.jpg';
                if ((Params._DATA.Size > 0) AND (NOT FileExists(SegmentFileName)))
                 then begin
                  Params._DATA.Position:=0;
                  Params._DATA.SaveToFile(SegmentFileName);
                  end;}
                //.
                Cash.Segment_SetDATA(ptrDestroySegment,nil);
                end;
              finally
              Cash.Segment_Unlock(ptrDestroySegment);
              end;
              end;
              //.
              Cash.AccessedSegmentsRevising.Remove(ptrDestroySegment);
              //.
              FreeMem(ptrDestroySegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
              end
             else ptrptrSegment:=@ptrNext;
            end;
          flLevelProcessed:=true;
          Break; //. >
          end;
      if (NOT flLevelProcessed)
       then
        while (Segments <> nil) do begin
          //. destroy the segment
          TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.BeginWrite;
          try
          ptrDestroySegment:=Segments;
          Segments:=TSegmentItemOfTTileServerVisualizationCash(ptrDestroySegment^).ptrNext;
          finally
          TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.EndWrite;
          end;
          //.
          with TSegmentItemOfTTileServerVisualizationCash(ptrDestroySegment^) do begin
          if (SegmentsOGLTextures.flEnabled AND (Cash.Segment_idOGLTexture(ptrDestroySegment) <> 0)) then SegmentsOGLTextures.DeleteSegmentTexture(ptrDestroySegment);
          Cash.Segment_Lock(ptrDestroySegment);
          try
          if (Params._DATA <> nil)
           then begin
            {///? SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(Params.XIndex)+'Y'+IntToStr(Params.YIndex)+'.jpg';
            if ((Params._DATA.Size > 0) AND (NOT FileExists(SegmentFileName)))
             then begin
              Params._DATA.Position:=0;
              Params._DATA.SaveToFile(SegmentFileName);
              end;}
            //.
            Cash.Segment_SetDATA(ptrDestroySegment,nil);
            end;
          finally
          Cash.Segment_Unlock(ptrDestroySegment);
          end;
          end;
          //.
          Cash.AccessedSegmentsRevising.Remove(ptrDestroySegment);
          //.
          FreeMem(ptrDestroySegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
          end;
      end;
    finally
    Lock.EndRead;
    end;
    //. next level
    ptrLevel:=ptrNext;
    end;
  end;
  finally
  for I:=0 to Length(LevelItems)-1 do with LevelItems[I] do SetLength(ReflectingBounds,0);
  SetLength(LevelItems,0);
  end;
  end;

var
  ptrItem: pointer;
  Figure: TFigureWinRefl;
  AdditiveFigure: TFigureWinRefl;
begin
Figure:=TFigureWinRefl.Create;
AdditiveFigure:=TFigureWinRefl.Create;
try
Space.Lock.Enter;
try
Cash.Lock.BeginWrite; //. to avoid deleting segment on composition reflecting
try
ptrItem:=Cash.FItems;
while (ptrItem <> nil) do begin
  ProcessItem(ptrItem, Figure,AdditiveFigure);
  //. next item
  ptrItem:=TItemTTileServerVisualizationCash(ptrItem^).ptrNext;
  end;
finally
Cash.Lock.EndWrite;
end;
finally
Space.Lock.Leave;
end;
finally
AdditiveFigure.Destroy;
Figure.Destroy;
end;
end;

procedure TSystemTTileServerVisualization.Context_RemoveItem(const idComponent: integer);
begin
//. do not remove visualizations from context because we are using SUMMARY context (tile's files) for all users
end;

procedure TSystemTTileServerVisualization.Context_ClearItems();
begin
//. do not remove visualizations from context because we are using SUMMARY context (tile's files) for all users
end;

procedure TSystemTTileServerVisualization.DoOnContextIsInitialized();
begin
if (Space.flOffline OR (Cash = nil)) then Exit; //. ->
Cash.PersistLevelsProviding.Provide();
end;


{TTSVAccessedSegmentsRevising}
Constructor TTSVAccessedSegmentsRevising.Create(const pCache: TTTileServerVisualizationCash);
const
  SegmentAvrSize = 16000;
  MemFactorToLoadSegments = 0.25;
var
  MemStatus: TMemoryStatus;
begin
Cache:=pCache;
Lock:=TCriticalSection.Create;
//.
Segments:=nil;
SegmentsCount:=0;
//. get amount of segments to live in memory
MemStatus.dwLength:=sizeof(TMemoryStatus);
GlobalMemoryStatus(MemStatus);
SegmentsMaxCount:=Round((MemStatus.dwTotalPhys*MemFactorToLoadSegments)/SegmentAvrSize);
//.
Inherited Create(true);
Priority:=tpIdle;
Resume;
end;

Destructor TTSVAccessedSegmentsRevising.Destroy;
begin
Inherited;
Clear;
Lock.Free;
end;

procedure TTSVAccessedSegmentsRevising.Add(const pSegment: pointer; const pptrLevel: pointer; const pidObj: integer);
var
  ptrptrItem: pointer;
  ptrItem: pointer;
begin
Lock.Enter;
try
ptrItem:=nil;
ptrptrItem:=@Segments;
while Pointer(ptrptrItem^) <> nil do with TTSVAccessedSegmentItem(Pointer(ptrptrItem^)^) do begin
  if (Segment = pSegment)
   then begin
    ptrItem:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TTSVAccessedSegmentItem(ptrItem^).ptrNext:=Segments;
    Segments:=ptrItem;
    Break; //. >
    end;
  ptrptrItem:=@ptrNext;
  end;
if (ptrItem = nil)
 then begin
  GetMem(ptrItem,SizeOf(TTSVAccessedSegmentItem));
  with TTSVAccessedSegmentItem(ptrItem^) do begin
  ptrNext:=Segments;
  Segment:=pSegment;
  ptrLevel:=pptrLevel;
  end;
  Segments:=ptrItem;
  Inc(SegmentsCount);
  end;
finally
Lock.Leave;
end;
end;

procedure TTSVAccessedSegmentsRevising.AddByList(const List: TList; const pptrLevel: pointer; const pidObj: integer);
var
  I: integer;
  pSegment: pointer;
  ptrptrItem: pointer;
  ptrItem: pointer;
begin
for I:=0 to List.Count-1 do begin
  pSegment:=List[I];
  //.
  Lock.Enter;
  try
  ptrItem:=nil;
  ptrptrItem:=@Segments;
  while Pointer(ptrptrItem^) <> nil do with TTSVAccessedSegmentItem(Pointer(ptrptrItem^)^) do begin
    if Segment = pSegment
     then begin
      ptrItem:=Pointer(ptrptrItem^);
      Pointer(ptrptrItem^):=ptrNext;
      TTSVAccessedSegmentItem(ptrItem^).ptrNext:=Segments;
      Segments:=ptrItem;
      Break; //. >
      end;
    ptrptrItem:=@ptrNext;
    end;
  if (ptrItem = nil)
   then begin
    GetMem(ptrItem,SizeOf(TTSVAccessedSegmentItem));
    with TTSVAccessedSegmentItem(ptrItem^) do begin
    ptrNext:=Segments;
    Segment:=pSegment;
    ptrLevel:=pptrLevel;
    end;
    Segments:=ptrItem;
    Inc(SegmentsCount);
    end;
  finally
  Lock.Leave;
  end;
  end;
end;

procedure TTSVAccessedSegmentsRevising.Remove(const pSegment: pointer);
var
  ptrptrItem: pointer;
  ptrDestroyItem: pointer;
begin
Lock.Enter;
try
ptrptrItem:=@Segments;
while (Pointer(ptrptrItem^) <> nil) do with TTSVAccessedSegmentItem(Pointer(ptrptrItem^)^) do
  if (Segment = pSegment)
   then begin
    ptrDestroyItem:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=TTSVAccessedSegmentItem(ptrDestroyItem^).ptrNext;
    FreeMem(ptrDestroyItem,SizeOf(TTSVAccessedSegmentItem));
    Dec(SegmentsCount);
    Exit; //. ->
    end
   else ptrptrItem:=@ptrNext;
finally
Lock.Leave;
end;
end;

function TTSVAccessedSegmentsRevising.RemoveOld(const Count: integer; out RemoveList: TList): boolean;
var
  Delta: integer;
  ptrptrItem: pointer;
  ptrDestroyItem: pointer;
  I: integer;
begin
Result:=false;
RemoveList:=nil;
Lock.Enter;
try
Delta:=(SegmentsCount-Count);
if (Delta <= 0) then Exit; //. ->
RemoveList:=TList.Create;
try
RemoveList.Capacity:=Delta;
ptrptrItem:=@Segments;
//. skip normal items
I:=0;
while (Pointer(ptrptrItem^) <> nil) do with TTSVAccessedSegmentItem(Pointer(ptrptrItem^)^) do
  if (I < Count)
   then begin
    ptrptrItem:=@ptrNext;
    Inc(I);
    end
   else Break; //. >
//. remove the rest
while (Pointer(ptrptrItem^) <> nil) do
  if (NOT (TLevelItemOfTTileServerVisualizationCash(TTSVAccessedSegmentItem(Pointer(ptrptrItem^)^).ptrLevel^).flPersist))
   then with TTSVAccessedSegmentItem(Pointer(ptrptrItem^)^) do begin
    ptrDestroyItem:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=TTSVAccessedSegmentItem(ptrDestroyItem^).ptrNext;
    //.
    RemoveList.Add(ptrDestroyItem);
    end
   else ptrptrItem:=@TTSVAccessedSegmentItem(Pointer(ptrptrItem^)^).ptrNext; 
//.
Dec(SegmentsCount,Delta);
//.
Result:=true;
except
  FreeAndNil(RemoveList);
  Raise; //. =>
  end;
finally
Lock.Leave;
end;
end;

procedure TTSVAccessedSegmentsRevising.RemoveVisualizationSegments(const ptrVisualizationItem: pointer);
var
  ptrptrItem: pointer;
  ptrDestroyItem: pointer;
begin
Lock.Enter;
try
ptrptrItem:=@Segments;
while (Pointer(ptrptrItem^) <> nil) do with TTSVAccessedSegmentItem(Pointer(ptrptrItem^)^) do
  if (TLevelItemOfTTileServerVisualizationCash(ptrLevel^).ptrItem = ptrVisualizationItem)
   then begin
    ptrDestroyItem:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=TTSVAccessedSegmentItem(ptrDestroyItem^).ptrNext;
    FreeMem(ptrDestroyItem,SizeOf(TTSVAccessedSegmentItem));
    Dec(SegmentsCount); 
    end
   else ptrptrItem:=@ptrNext;
finally
Lock.Leave;
end;
end;

procedure TTSVAccessedSegmentsRevising.Clear;
var
  ptrDestroyItem: pointer;
begin
Lock.Enter;
try
while (Segments <> nil) do begin
  ptrDestroyItem:=Segments;
  Segments:=TTSVAccessedSegmentItem(ptrDestroyItem^).ptrNext;
  FreeMem(ptrDestroyItem,SizeOf(TTSVAccessedSegmentItem));
  end;
SegmentsCount:=0;
finally
Lock.Leave;
end;
end;

procedure TTSVAccessedSegmentsRevising.Execute;
const
  Delta = 7*7;
var
  R: boolean;
  ///? LevelFolder: string;
  ///? SegmentFileName: string;
  RemoveList: TList;
  RemoveTextureList: TList;
  I: integer;
begin
repeat
  //. check for items to remove
  Lock.Enter;
  try
  R:=((SegmentsCount > (SegmentsMaxCount+Delta)) AND RemoveOld(SegmentsMaxCount, RemoveList));
  finally
  Lock.Leave;
  end;
  //.
  if (R)
   then
    try
    RemoveTextureList:=TList.Create;
    try
    RemoveTextureList.Capacity:=RemoveList.Count;
    Cache.Lock.BeginRead;
    try
    for I:=0 to RemoveList.Count-1 do with TTSVAccessedSegmentItem(RemoveList[I]^) do begin
      TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.BeginRead;
      try
      ///? LevelFolder:=Cache.Item_Level__GetContextFolder(TItemTTileServerVisualizationCash(TLevelItemOfTTileServerVisualizationCash(ptrLevel^).ptrItem^).idObj,TItemTTileServerVisualizationCash(TLevelItemOfTTileServerVisualizationCash(ptrLevel^).ptrItem^).TileProviderID,TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.ID);
      ///? ForceDirectories(LevelFolder);
      with TSegmentItemOfTTileServerVisualizationCash(Segment^) do begin
      Cache.Segment_Lock(Segment);
      try
      if (Params._DATA <> nil)
       then begin
        {///? SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(Params.XIndex)+'Y'+IntToStr(Params.YIndex)+'.jpg';
        if ((Params._DATA.Size > 0) AND (NOT FileExists(SegmentFileName)))
         then begin
          Params._DATA.Position:=0;
          Params._DATA.SaveToFile(SegmentFileName);
          end;}
        //.
        Cache.Segment_SetDATA(Segment,nil);
        //.
        if (Cache.Segment_idOGLTexture(Segment) <> 0) then RemoveTextureList.Add(Segment);
        end;
      finally
      Cache.Segment_Unlock(Segment);
      end;
      end;  
      finally
      TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.EndRead;
      end;
      end;
    if (TSystemTTileServerVisualization(Cache.TypeSystem).SegmentsOGLTextures.flEnabled) then TSystemTTileServerVisualization(Cache.TypeSystem).SegmentsOGLTextures.DeleteSegmentsItemsTextures(RemoveTextureList);
    finally
    Cache.Lock.EndRead;
    end;
    finally
    RemoveTextureList.Destroy;
    end;
    finally
    for I:=0 to RemoveList.Count-1 do FreeMem(RemoveList[I],SizeOf(TTSVAccessedSegmentItem));
    RemoveList.Destroy;
    end;
  //.
  Sleep(100);
until Terminated;
end;


{TTSVPersistLevelsProviding}
Constructor TTSVPersistLevelsProviding.Create(const pCache: TTTileServerVisualizationCash);
const
  SegmentAvrSize = 16000; 
  MemFactorToLoadSegments = 0.1;
var
  MemStatus: TMemoryStatus;
begin
Cache:=pCache;
Lock:=TCriticalSection.Create;
evtQueryProviding:=CreateEvent(nil,false,false,nil);
if (NOT Cache.Space.flOffline)
 then flServerConnectionIsFast:=ServerConnectionIsFast()
 else flServerConnectionIsFast:=false;
//. get amount of segments to live in memory
MemStatus.dwLength:=sizeof(TMemoryStatus);
GlobalMemoryStatus(MemStatus);
PersistSegmentsMaxCount:=Round((MemStatus.dwTotalPhys*MemFactorToLoadSegments)/SegmentAvrSize);
//.
Inherited Create(false);
end;

Destructor TTSVPersistLevelsProviding.Destroy;
begin
Inherited;
CloseHandle(evtQueryProviding);
Lock.Free;
end;

procedure TTSVPersistLevelsProviding.Execute;
var
  R: DWord;
begin
if (Cache.Space.ProxySpaceServerType <> pssClient) then Exit; //. ->
//.
CoInitializeEx(nil, COINIT_MULTITHREADED);
try
repeat
  R:=WaitForSingleObject(evtQueryProviding, 100);
  if (R = WAIT_OBJECT_0)
   then
    try
    //. to avoid often calls
    while (WaitForSingleObject(evtQueryProviding, 300) = WAIT_OBJECT_0) do ;
    //.
    Providing();
    except
      On E: Exception do if (Cache.Space.State <> psstDestroying) then EventLog.WriteMajorEvent('SystemTTileServerVisualization.Cache.TTSVPersistLevelsProviding','Error during providing persist levels.',E.Message);
      end;
until Terminated;
finally
CoUninitialize;
end;
end;

function TTSVPersistLevelsProviding.ServerConnectionIsFast: boolean;
const
  TryesCount = 3;
var
  I: integer;
  LT: TDateTime;
  RequestTime,MinRequestTime: integer;
begin
Result:=false;
(*///? to avoid blocking from map servers
MinRequestTime:=MaxInt;
for I:=0 to TryesCount-1 do begin
  Cache.Space.GlobalSpaceManagerLock.Enter;
  try
  LT:=Now;
  Cache.Space.GlobalSpaceManager.SpaceSize;
  RequestTime:=Round((Now-LT)*24*3600*1000);
  finally
  Cache.Space.GlobalSpaceManagerLock.Leave;
  end;
  if (RequestTime < MinRequestTime)
   then MinRequestTime:=RequestTime;
  end;
Result:=(MinRequestTime < 100{milliseconds});*)
end;

procedure TTSVPersistLevelsProviding.Provide();
begin
SetEvent(evtQueryProviding);
end;

procedure TTSVPersistLevelsProviding.Providing;

  procedure ProcessVisualizationsForPersistLevels(out NewPersistLevels: TList);
  const
    PersistLevelVisualizationsMaxCount = 4;
    PersistLevelIndex = 3;
  var
    PersistLevelVisualizationsCount: integer;
    ptrItem,ptrLevel: pointer;
    PersistSegmentsCount,SC: integer;
  begin
  NewPersistLevels:=TList.Create;
  try
  PersistLevelVisualizationsCount:=PersistLevelVisualizationsMaxCount;
  Cache.Lock.BeginRead;
  try
  PersistSegmentsCount:=0;
  ptrItem:=Cache.FItems;
  while (ptrItem <> nil) do with TItemTTileServerVisualizationCash(ptrItem^) do begin
    ptrLevel:=Levels;
    while (ptrLevel <> nil) do with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
      Lock.BeginRead;
      try
      if (PersistLevelVisualizationsCount > 0)
       then begin
        if ((LevelIndex = 0) OR (LevelIndex = PersistLevelIndex))
         then begin
          SC:=Params.DivX*Params.DivY;
          if ((PersistSegmentsCount+SC) <= PersistSegmentsMaxCount)
           then begin
            if (NOT flPersist)
             then begin
              Lock.BeginWrite;
              try
              flPersist:=true;
              finally
              Lock.EndWrite;
              end;
              Inc(PersistSegmentsCount,SC);
              //.
              NewPersistLevels.Add(Pointer(Params.id));
              end;
            end
           else begin
            EventLog.WriteCriticalEvent('Providing.ProcessVisualizationsForPersistLevels','Persist Level has been reset','((PersistSegmentsCount+SC) <= PersistSegmentsMaxCount)');
            if (flPersist)
             then begin
              Lock.BeginWrite;
              try
              flPersist:=false;
              finally
              Lock.EndWrite;
              end;
              end;
            end;
          end
         else begin
          if (flPersist)
           then begin
            Lock.BeginWrite;
            try
            flPersist:=false;
            finally
            Lock.EndWrite;
            end;
            end;
          end;
        end
       else begin
        if (flPersist)
         then begin
          Lock.BeginWrite;
          try
          flPersist:=false;
          finally
          Lock.EndWrite;
          end;
          end;
        end;
      finally
      Lock.EndRead;
      end;
      //. next level
      ptrLevel:=ptrNext;
      end;
    if (PersistLevelVisualizationsCount > 0) then Dec(PersistLevelVisualizationsCount);
    //. next visualization
    ptrItem:=ptrNext;
    end;
  finally
  Cache.Lock.EndRead;
  end;
  except
    FreeAndNil(NewPersistLevels);
    Raise; //. =>
    end;
  end;

  procedure ProvidePersistLevelsWithSegments(const PersistLevels: TList);
  const
    SegmentsGeneration_MaxDepth = 3;
  var
    ptrItem: pointer;
    TPI: integer;
    flLaysAreIndependent: boolean;
    ptrLevel: pointer;
    LevelsList: TList;
    SegmentID: integer;
    flAllItemsExists,flHasEmptySegment: boolean;
    ItemsTable: pointer;
    ItemsTableSize: integer;
    ExceptSegments: TByteArray;
    BA: TByteArray;
    IL,ReceivedSegmentsList: TList;
    LI: integer;
  begin
  try
  Cache.Lock.BeginRead;
  try
  ptrItem:=Cache.FItems;
  while (ptrItem <> nil) do begin //. processing ...
    if (TItemTTileServerVisualizationCash(ptrItem^).ServerParsedData <> nil)
     then begin
      TPI:=TItemTTileServerVisualizationCash(ptrItem^).ServerParsedData.TileProviders_ItemIndex(TItemTTileServerVisualizationCash(ptrItem^).TileProviderID);
      flLaysAreIndependent:=((TPI >= 0) AND TItemTTileServerVisualizationCash(ptrItem^).ServerParsedData.TileProviders[TPI].flIndependentLevels);
      end
     else flLaysAreIndependent:=false;
    LevelsList:=TList.Create;
    try
    ptrLevel:=TItemTTileServerVisualizationCash(ptrItem^).Levels;
    while (ptrLevel <> nil) do with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
      Lock.BeginRead;
      try
      if (PersistLevels.IndexOf(Pointer(Params.id)) <> -1)
       then LevelsList.Add(ptrLevel);
      finally
      Lock.EndRead;
      end;
      //. next level
      ptrLevel:=ptrNext;
      end;
    for LI:=LevelsList.Count-1 downto 0 do begin
      ptrLevel:=LevelsList[LI];
      //.
      try
      TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.BeginRead;
      try
      //. get local segments
      flAllItemsExists:=Cache.Item_Level__GetVisibleSegmentsLocal(ptrItem, TItemTTileServerVisualizationCash(ptrItem^).TileProviderID, ptrLevel, 0,TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.DivX-1,0,TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.DivY-1, false, true, nil,  ItemsTable,ItemsTableSize, ExceptSegments, @flHasEmptySegment);
      try
      if (NOT flAllItemsExists OR flHasEmptySegment)
       then begin
        //. try to restore segments from saved context
        try
        flAllItemsExists:=Cache.Item_Level__RestoreSegmentsLocal(ptrItem, TItemTTileServerVisualizationCash(ptrItem^).TileProviderID, ptrLevel, 0,TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.DivX-1,0,TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.DivY-1, nil,  IL, ExceptSegments);
        except
          On E: Exception do begin
            EventLog.WriteMinorEvent('TTSVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of RestoreSegmentsLocal() of TileServer visualization (ID: '+IntToStr(TItemTTileServerVisualizationCash(ptrItem^).idObj)+')',E.Message);
            Raise; //. =>
            end;
          end;
        if (IL <> nil)
         then IL.Destroy;
        //.
        if (NOT flAllItemsExists)
         then begin
          if (NOT flLaysAreIndependent)
           then begin
            //. try to generate segments from down levels
            try
            flAllItemsExists:=Cache.Item_Level__GenerateSegmentsLocal(ptrItem, TItemTTileServerVisualizationCash(ptrItem^).TileProviderID, ptrLevel, 0,TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.DivX-1,0,TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.DivY-1, SegmentsGeneration_MaxDepth, nil,  IL, ExceptSegments);
            except
              On E: Exception do begin
                EventLog.WriteMinorEvent('TTSVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of GenerateSegmentsLocal() of TileServer visualization (ID: '+IntToStr(TItemTTileServerVisualizationCash(ptrItem^).idObj)+')',E.Message);
                Raise; //. =>
                end;
              end;
            if (IL <> nil)
             then IL.Destroy;
            end;
          //. segments getting from remote server
          if (NOT flAllItemsExists AND (NOT Cache.Space.flOffline) AND flServerConnectionIsFast)
           then begin
            with TTileServerVisualizationFunctionality(TComponentFunctionality_Create(idTTileServerVisualization,TItemTTileServerVisualizationCash(ptrItem^).idObj)) do
            try
            try
            Level_GetSegments(TItemTTileServerVisualizationCash(ptrItem^).TileProviderID, TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.id, 0,TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.DivX-1,0,TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.DivY-1, ExceptSegments, BA);
            except
              On E: Exception do begin
                EventLog.WriteMinorEvent('TTSVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of Level_GetSegments(idLevel = '+IntToStr(TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.id)+') of TileServer visualization (ID: '+IntToStr(TItemTTileServerVisualizationCash(ptrItem^).idObj)+')',E.Message);
                Raise; //. =>
                end;
              end;
            finally
            Release;
            end;
            //.
            ReceivedSegmentsList:=TList.Create;
            try
            TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.BeginRead;
            try
            try
            TTileServerVisualizationCashItemLevel_PrepareSegmentsFromByteArray(TSystemTTileServerVisualization(Cache.TypeSystem), TItemTTileServerVisualizationCash(ptrItem^).idObj, TItemTTileServerVisualizationCash(ptrItem^).TileProviderID, ptrLevel,BA, ReceivedSegmentsList);
            except
              On E: Exception do begin
                EventLog.WriteMinorEvent('TTSVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of PrepareSegmentsFromByteArray(idLevel = '+IntToStr(TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.id)+') of TileServer visualization (ID: '+IntToStr(TItemTTileServerVisualizationCash(ptrItem^).idObj)+')',E.Message);
                Raise; //. =>
                end;
              end;
            if (ReceivedSegmentsList.Count > 0)
             then begin
              //. update OpenGL segments textures
              try
              if (TSystemTTileServerVisualization(Cache.TypeSystem).SegmentsOGLTextures.flEnabled)
               then TSystemTTileServerVisualization(Cache.TypeSystem).SegmentsOGLTextures.GenerateSegmentItemsTextures(ReceivedSegmentsList);
              except
                On E: Exception do begin
                  EventLog.WriteMinorEvent('TTSVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of GenerateSegmentItemsTextures() of TileServer visualization (ID: '+IntToStr(TItemTTileServerVisualizationCash(ptrItem^).idObj)+')',E.Message);
                  Raise; //. =>
                  end;
                end;
              end;
            finally
            TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.EndRead;
            end;
            finally
            ReceivedSegmentsList.Destroy;
            end;
            if (true) ///? (NOT flLaysAreIndependent)
             then begin
              //. empty segments degeneration
              try
              if (Cache.Item_Level__DegenerateSegmentsLocal(ptrItem, TItemTTileServerVisualizationCash(ptrItem^).TileProviderID, ptrLevel, 0,TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.DivX-1,0,TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.DivY-1, nil,  IL))
               then IL.Destroy;
              except
                On E: Exception do begin
                  EventLog.WriteMinorEvent('TTSVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of DegenerateSegmentsLocal(idLevel = '+IntToStr(TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Params.id)+') of TileServer visualization (ID: '+IntToStr(TItemTTileServerVisualizationCash(ptrItem^).idObj)+')',E.Message);
                  Raise; //. =>
                  end;
                end;
              end;
            end;
          end;
        end;
      finally
      if (ItemsTable <> nil) then FreeMem(ItemsTable,ItemsTableSize);
      end;
      finally
      TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.EndRead;
      end;
      except
        On E: Exception do begin
          EventLog.WriteMinorEvent('TTSVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of processing TileServer visualization (ID: '+IntToStr(TItemTTileServerVisualizationCash(ptrItem^).idObj)+')',E.Message);
          Raise; //. =>
          end;
        end;
      end;
    finally
    LevelsList.Destroy;
    end;
    //. next cache visualization
    ptrItem:=TItemTTileServerVisualizationCash(ptrItem^).ptrNext;
    end;
  finally
  Cache.Lock.EndRead;
  end;
  except
    On E: Exception do EventLog.WriteMinorEvent('TileServerDeferredReflecting.Execute','Unexpected error of processing TileServer visualization (ID: '+IntToStr(TItemTTileServerVisualizationCash(ptrItem^).idObj)+')',E.Message);
    end;
  end;

var
  NewPersistLevels: TList;
begin
ProcessVisualizationsForPersistLevels(NewPersistLevels);
try
ProvidePersistLevelsWithSegments(NewPersistLevels);
finally
NewPersistLevels.Destroy;
end;
end;


//. TTSVSegmentsOGLTextures
Constructor TTSVSegmentsOGLTextures.Create(const pTypeSystem: TSystemTTileServerVisualization);
const
  TextureSize = 256*256*3;
  MemFactorToLoadTextures = 0.125;
var
  BitsPtr: pointer;
  I: integer;
  MemStatus: TMemoryStatus;
begin
TypeSystem:=pTypeSystem;
//.
{$IFNDEF SpaceWindowReflectingTesting}
flEnabled:=(NOT (unitSpaceFunctionalServer.flYes OR unitAreaNotificationServer.flYes));
{$ELSE}
flEnabled:=false;
{$ENDIF}
//.
Texture_DC:=0;
DIB:=0;
DIB_DC:=0;
OperationLock:=nil;
evtStart:=0;
evtFinished:=0;
//.
_DrawCanvas_Functionality:=nil;
_DrawCanvas_Segments:=nil;
_DrawCanvas_Result:=false;
_NewTextureSegment:=nil;
_NewTexturesSegments:=nil;
_DeleteTextureSegment:=nil;
_DeleteSegmentsTextures:=nil;
//.
LastAccessTextureSegments:=nil;
LastAccessTextureSegmentsCount:=0;
//.
if (flEnabled)
 then begin
  Texture_DC:=CreateCompatibleDC(0);
  DIB_DC:=CreateCompatibleDC(0);
  ZeroMemory(@DIB_BitInfo,sizeof(BITMAPINFO));
  with DIB_BitInfo.bmiHeader do begin
  biSize:=sizeOf(DIB_BitInfo.bmiHeader);
  biBitCount:=24;
  biCompression:=BI_RGB;
  biPlanes:=1;
  biWidth :=Screen.Width+16{additional size to avoid clipped image (don't know why)};
  biHeight:=Screen.Height+16{additional size to avoid clipped image (don't know why)};
  biSizeImage:=(biWidth*(biBitCount div 8))*biHeight;
  end;
  DIB:=CreateDIBSection(DIB_DC, DIB_BitInfo, DIB_RGB_COLORS, BitsPtr, 0, 0);
  SelectObject(DIB_DC, DIB);
  OperationLock:=TCriticalSection.Create;
  evtStart:=CreateEvent(nil,false,false,nil);
  evtFinished:=CreateEvent(nil,false,false,nil);
  flInitialized:=false;
  flStarted:=false;
  //. calculate maximum number of textures in memory
  MemStatus.dwLength:=sizeof(TMemoryStatus);
  GlobalMemoryStatus(MemStatus);
  TexturesMaxCount:=Round((MemStatus.dwTotalPhys*MemFactorToLoadTextures)/TextureSize);
  end;
//.
Inherited Create(true);
//.
if (flEnabled)
 then begin
  Priority:=tpHigher;
  Resume();
  while (NOT flStarted) do Sleep(30);
  //.
  if (NOT flInitialized) then Raise Exception.Create('could not initialize OpenGL textures'); //. =>
  end;
end;

Destructor TTSVSegmentsOGLTextures.Destroy;
begin
if (OperationLock <> nil)
 then begin
  OperationLock.Enter;
  SetEvent(evtStart);
  OperationLock.Leave;
  OperationLock.Destroy;
  end;
//.
Inherited;
//.
if (evtStart <> 0) then CloseHandle(evtStart);
if (evtFinished <> 0) then CloseHandle(evtFinished);
//.
LastAccessTextureSegments_Clear();
//.
if (DIB <> 0)
 then begin
  SelectObject(DIB_DC,0);
  DeleteObject(DIB);
  end;
if (DIB_DC <> 0) then DeleteDC(DIB_DC);
if (Texture_DC <> 0) then DeleteDC(Texture_DC);
end;

procedure TTSVSegmentsOGLTextures.Execute;
var
  I: integer;
  idOldTexture: cardinal;
  OldTextureSegmentList: TList;
begin
OperationException:=nil;
try
OGLContext:=CreateRenderingContext(DIB_DC,[],24,0);
if (OGLContext = 0)
 then begin
  flStarted:=true;
  Raise Exception.Create('could not CreateRenderingContext()'); //. =>
  end;
wglMakeCurrent(DIB_DC,OGLContext);
try
glViewport(0,0, DIB_BitInfo.bmiHeader.biWidth,DIB_BitInfo.bmiHeader.biHeight);
glDisable(GL_LIGHTING);
glDisable(GL_FOG);
glDisable(GL_DEPTH_TEST);
glDisable(GL_ALPHA_TEST);
glDisable(GL_STENCIL_TEST);
glDisable(GL_SCISSOR_TEST);
glEnable(GL_TEXTURE_2D);
//.
flInitialized:=true;
flStarted:=true;
repeat
  if (WaitForSingleObject(evtStart,100) = WAIT_OBJECT_0)
   then begin
    OperationException:=nil;
    try
    //.
    if (_DrawCanvas_Segments <> nil)
     then begin
      _DrawCanvas_Result:=DoDrawOnCanvas(_DrawCanvas_Functionality,_DrawCanvas_Segments,_DrawCanvas_SegmentsSize, _DrawCanvas_SegmentWidth, _DrawCanvas_SegmentHeight, _DrawCanvas_XIndexMin,_DrawCanvas_YIndexMin, _DrawCanvas_dX,_DrawCanvas_dY,_DrawCanvas_WidthScale,_DrawCanvas_HeightScale,_DrawCanvas_Rotation,_DrawCanvas_flBestQuality);
      _DrawCanvas_Segments:=nil;
      end
     else
      if (_NewTexturesSegments <> nil)
       then begin
        for I:=0 to _NewTexturesSegments.Count-1 do begin
          TypeSystem.Cash.Segment_Lock(_NewTexturesSegments[I]);
          try
          if ((TSegmentItemOfTTileServerVisualizationCash(_NewTexturesSegments[I]^).Params._DATA <> nil) AND (TSegmentItemOfTTileServerVisualizationCash(_NewTexturesSegments[I]^).Params._DATA.Size > 0))
           then begin
            idOldTexture:=TypeSystem.Cash.Segment_SetidOGLTexture(_NewTexturesSegments[I],InstallTexture(TSegmentItemOfTTileServerVisualizationCash(_NewTexturesSegments[I]^).Params._DATA));
            if (idOldTexture <> 0) then glDeleteTextures(1,@idOldTexture);
            LastAccessTextureSegments_Insert(_NewTexturesSegments[I]);
            end;
          finally
          TypeSystem.Cash.Segment_Unlock(_NewTexturesSegments[I]);
          end;
          end;
        //.
        _NewTexturesSegments:=nil;
        end
       else
        if (_NewTextureSegment <> nil)
         then begin
          TypeSystem.Cash.Segment_Lock(_NewTextureSegment);
          try
          if ((TSegmentItemOfTTileServerVisualizationCash(_NewTextureSegment^).Params._DATA <> nil) AND (TSegmentItemOfTTileServerVisualizationCash(_NewTextureSegment^).Params._DATA.Size > 0))
           then begin
            idOldTexture:=TypeSystem.Cash.Segment_SetidOGLTexture(_NewTextureSegment,InstallTexture(TSegmentItemOfTTileServerVisualizationCash(_NewTextureSegment^).Params._DATA));
            if (idOldTexture <> 0) then glDeleteTextures(1,@idOldTexture);
            LastAccessTextureSegments_Insert(_NewTextureSegment);
            end;
          finally
          TypeSystem.Cash.Segment_Unlock(_NewTextureSegment);
          end;
          //.
          _NewTextureSegment:=nil;
          end
         else
          if (_DeleteSegmentsTextures <> nil)
           then begin
            for I:=0 to _DeleteSegmentsTextures.Count-1 do begin
              idOldTexture:=TypeSystem.Cash.Segment_SetidOGLTexture(_DeleteSegmentsTextures[I],0);
              if (idOldTexture <> 0)
               then begin
                glDeleteTextures(1,@idOldTexture);
                LastAccessTextureSegments_Remove(_DeleteSegmentsTextures[I]);
                end;
              end;
            //.
            _DeleteSegmentsTextures:=nil;
            end
           else
            if (_DeleteTextureSegment <> nil)
             then begin
              idOldTexture:=TypeSystem.Cash.Segment_SetidOGLTexture(_DeleteTextureSegment,0);
              if (idOldTexture <> 0)
               then begin
                glDeleteTextures(1,@idOldTexture);
                LastAccessTextureSegments_Remove(_DeleteTextureSegment);
                end;
              //.
              _DeleteTextureSegment:=nil;
              end
    except
      on E: Exception do begin OperationException:=E; end;
      end;
    //.
    SetEvent(evtFinished);
    end
   else begin
    //. remove textures from old segments
    if (LastAccessTextureSegmentsCount > TexturesMaxCount)
     then begin
      LastAccessTextureSegments_RemoveOld(TexturesMaxCount-(TexturesMaxCount SHR 2), OldTextureSegmentList);
      if (OldTextureSegmentList <> nil)
       then begin
        try
        for I:=0 to OldTextureSegmentList.Count-1 do begin
          idOldTexture:=TypeSystem.Cash.Segment_SetidOGLTexture(OldTextureSegmentList[I],0);
          if (idOldTexture <> 0)
           then begin
            glDeleteTextures(1,@idOldTexture);
            LastAccessTextureSegments_Remove(OldTextureSegmentList[I]);
            end;
          end;
        finally
        OldTextureSegmentList.Destroy;
        end;
        end
      end;
    end;
until Terminated;
finally
wglMakeCurrent(DIB_DC,0);
wglDeleteContext(OGLContext);
end;
except
  On E: Exception do begin
    OperationException:=E;
    EventLog.WriteMinorEvent('TTSVSegmentsOGLTextures.Execute','Fatal error',E.Message);
    end;
  end;
end;

procedure TTSVSegmentsOGLTextures.GenerateSegmentTexture(const Segment: pointer);
begin
if (NOT flEnabled) then Raise Exception.Create('OpenGL is disabled'); //. =>
OperationLock.Enter;
try
_NewTextureSegment:=Segment;
//. set start
ResetEvent(evtFinished);
SetEvent(evtStart);
//. wait operation end
WaitForSingleObject(evtFinished,INFINITE);
if (OperationException <> nil)
 then
  try
  Raise Exception.Create(OperationException.Message); //. =>
  finally
  FreeAndNil(OperationException);
  end;
finally
OperationLock.Leave;
end;
end;

procedure TTSVSegmentsOGLTextures.GenerateSegmentItemsTextures(const Segments: TList);
begin
if (NOT flEnabled) then Raise Exception.Create('OpenGL is disabled'); //. =>
OperationLock.Enter;
try
_NewTexturesSegments:=Segments;
//. set start
ResetEvent(evtFinished);
SetEvent(evtStart);
//. wait operation end
WaitForSingleObject(evtFinished,INFINITE);
if (OperationException <> nil)
 then
  try
  Raise Exception.Create(OperationException.Message); //. =>
  finally
  FreeAndNil(OperationException);
  end;
finally
OperationLock.Leave;
end;
end;

procedure TTSVSegmentsOGLTextures.DeleteSegmentTexture(const Segment: pointer);
begin
if (NOT flEnabled) then Raise Exception.Create('OpenGL is disabled'); //. =>
OperationLock.Enter;
try
_DeleteTextureSegment:=Segment;
//. set start
ResetEvent(evtFinished);
SetEvent(evtStart);
//. wait operation end
WaitForSingleObject(evtFinished,INFINITE);
if (OperationException <> nil)
 then
  try
  Raise Exception.Create(OperationException.Message); //. =>
  finally
  FreeAndNil(OperationException);
  end;
finally
OperationLock.Leave;
end;
end;

procedure TTSVSegmentsOGLTextures.DeleteSegmentsItemsTextures(const Segments: TList);
begin
if (NOT flEnabled) then Raise Exception.Create('OpenGL is disabled'); //. =>
OperationLock.Enter;
try
_DeleteSegmentsTextures:=Segments;
//. set start
ResetEvent(evtFinished);
SetEvent(evtStart);
//. wait operation end
WaitForSingleObject(evtFinished,INFINITE);
if (OperationException <> nil)
 then
  try
  Raise Exception.Create(OperationException.Message); //. =>
  finally
  FreeAndNil(OperationException);
  end;
finally
OperationLock.Leave;
end;
end;

function TTSVSegmentsOGLTextures.DrawOnCanvas(const Functionality: TBase2DVisualizationFunctionality; const Canvas: TCanvas; const Segments: pointer; const SegmentsSize: integer; const SegmentWidth: double; const SegmentHeight: double; const XIndexMin: integer; const YIndexMin: integer; const dX: Extended; const dY: Extended; const WidthScale: Extended; const HeightScale: Extended; const Rotation: Extended; const flBestQuality: boolean): boolean;
begin
if (NOT flEnabled) then Raise Exception.Create('OpenGL is disabled'); //. =>
OperationLock.Enter;
try
//. draw canvas to temp bitmap
BitBlt(DIB_DC, 0,0,DIB_BitInfo.bmiHeader.biWidth,DIB_BitInfo.bmiHeader.biHeight, Canvas.Handle, 0,0, SRCCOPY);
//.
_DrawCanvas_Functionality:=Functionality;
_DrawCanvas_Segments:=Segments;
_DrawCanvas_SegmentsSize:=SegmentsSize;
_DrawCanvas_SegmentWidth:=SegmentWidth;
_DrawCanvas_SegmentHeight:=SegmentHeight;
_DrawCanvas_XIndexMin:=XIndexMin;
_DrawCanvas_YIndexMin:=YIndexMin;
_DrawCanvas_dX:=dX;
_DrawCanvas_dY:=dY;
_DrawCanvas_WidthScale:=WidthScale;
_DrawCanvas_HeightScale:=HeightScale;
_DrawCanvas_Rotation:=Rotation;
_DrawCanvas_flBestQuality:=flBestQuality;
//. set start
ResetEvent(evtFinished);
SetEvent(evtStart);
//. wait operation end
WaitForSingleObject(evtFinished,INFINITE);
if (OperationException <> nil)
 then
  try
  Raise Exception.Create(OperationException.Message); //. =>
  finally
  FreeAndNil(OperationException);
  end;
//. draw back to canvas
BitBlt(Canvas.Handle, 0,0,DIB_BitInfo.bmiHeader.biWidth,DIB_BitInfo.bmiHeader.biHeight, DIB_DC, 0, 0, SRCCOPY);
//.
Result:=_DrawCanvas_Result;
finally
OperationLock.Leave;
end;
end;

procedure TTSVSegmentsOGLTextures.LastAccessTextureSegments_Insert(const pSegment: pointer);
var
  ptrptrItem: pointer;
  ptrItem: pointer;
begin
ptrItem:=nil;
ptrptrItem:=@LastAccessTextureSegments;
while Pointer(ptrptrItem^) <> nil do with TTSVTextureSegmentItem(Pointer(ptrptrItem^)^) do begin
  if Segment = pSegment
   then begin
    ptrItem:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TTSVTextureSegmentItem(ptrItem^).ptrNext:=LastAccessTextureSegments;
    LastAccessTextureSegments:=ptrItem;
    Break; //. >
    end;
  ptrptrItem:=@ptrNext;
  end;
if (ptrItem = nil)
 then begin
  GetMem(ptrItem,SizeOf(TTSVTextureSegmentItem));
  with TTSVTextureSegmentItem(ptrItem^) do begin
  ptrNext:=LastAccessTextureSegments;
  Segment:=pSegment;
  end;
  LastAccessTextureSegments:=ptrItem;
  Inc(LastAccessTextureSegmentsCount);
  end;
end;

procedure TTSVSegmentsOGLTextures.LastAccessTextureSegments_Remove(const pSegment: pointer);
var
  ptrptrItem: pointer;
  ptrDestroyItem: pointer;
begin
ptrptrItem:=@LastAccessTextureSegments;
while (Pointer(ptrptrItem^) <> nil) do with TTSVTextureSegmentItem(Pointer(ptrptrItem^)^) do
  if (Segment = pSegment)
   then begin
    ptrDestroyItem:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=TTSVTextureSegmentItem(ptrDestroyItem^).ptrNext;
    FreeMem(ptrDestroyItem,SizeOf(TTSVTextureSegmentItem));
    Dec(LastAccessTextureSegmentsCount);
    Exit; //. ->
    end
   else ptrptrItem:=@ptrNext;
end;

procedure TTSVSegmentsOGLTextures.LastAccessTextureSegments_RemoveOld(const Count: integer; out RemoveList: TList);
var
  Delta: integer;
  ptrptrItem: pointer;
  ptrDestroyItem: pointer;
  I: integer;
begin
RemoveList:=nil;
Delta:=(LastAccessTextureSegmentsCount-Count);
if (Delta <= 0) then Exit; //. ->
RemoveList:=TList.Create;
try
RemoveList.Capacity:=Delta;
ptrptrItem:=@LastAccessTextureSegments;
//. skip normal items
I:=0;
while (Pointer(ptrptrItem^) <> nil) do with TTSVTextureSegmentItem(Pointer(ptrptrItem^)^) do
  if (I < Count)
   then begin
    ptrptrItem:=@ptrNext;
    Inc(I);
    end
   else Break; //. >
//. remove the rest
while (Pointer(ptrptrItem^) <> nil) do with TTSVTextureSegmentItem(Pointer(ptrptrItem^)^) do begin
  ptrDestroyItem:=Pointer(ptrptrItem^);
  Pointer(ptrptrItem^):=TTSVTextureSegmentItem(ptrDestroyItem^).ptrNext;
  //.
  RemoveList.Add(TTSVTextureSegmentItem(ptrDestroyItem^).Segment);
  //.
  FreeMem(ptrDestroyItem,SizeOf(TTSVTextureSegmentItem));
  end;
//.
Dec(LastAccessTextureSegmentsCount,Delta);
except
  FreeAndNil(RemoveList);
  Raise; //. =>
  end;
end;

procedure TTSVSegmentsOGLTextures.LastAccessTextureSegments_Clear;
var
  ptrDestroyItem: pointer;
begin
while (LastAccessTextureSegments <> nil) do begin
  ptrDestroyItem:=LastAccessTextureSegments;
  LastAccessTextureSegments:=TTSVTextureSegmentItem(ptrDestroyItem^).ptrNext;
  FreeMem(ptrDestroyItem,SizeOf(TTSVTextureSegmentItem));
  end;
LastAccessTextureSegmentsCount:=0;
end;

function TTSVSegmentsOGLTextures.InstallTexture(const ImageStream: TMemoryStream): cardinal;

  function RoundDownToPowerOf2(Value: Integer): Integer;
  var
    LogTwo: Double;
  begin
  LogTwo:=log2(Value);
  if Trunc(LogTwo) < LogTwo then Result:=Trunc(Power(2,Trunc(LogTwo))) else Result:=Value;
  end;

  function CreateTextureObject(const DC: HDC; const MS: TMemoryStream; const MinFilter: Cardinal): cardinal;
  type
    TBA = array[0..0] of byte;
    PByteArray = ^TBA;

  var
    iWidth, iHeight, iNChannels: Integer;
    iDIBChannels: integer;
    iStatus: integer;
    jcprops: TJPEG_CORE_PROPERTIES;
    DIB: cardinal;
    DIB_BitInfo: TBitmapInfo;
    BitsPtr: PByteArray;
    AlignedWidth,AlignedHeight: integer;
    StretchedDC: cardinal;
    StretchedDIB: cardinal;
    StretchedDIB_BitInfo: TBitmapInfo;
    StretchedBitsPtr: PByteArray;
    ImageSize: Cardinal;
    Temp: Byte;
    J: integer;
  begin
  Result:=0;
  //.
  IJL_Lock.Enter;
  try
  iDIBchannels := 3;
  FillChar(jcprops,SizeOf(jcprops),0);
  iStatus:=ijlInit(@jcprops);
  if iStatus = IJL_OK
   then
    try
    jcprops.JPGBytes:=MS.Memory;
    jcprops.JPGSizeBytes:=MS.Size;
    iStatus:=ijlRead(@jcprops,IJL_JBUFF_READPARAMS);
    if iStatus = IJL_OK
     then begin
      iWidth:=jcprops.JPGWidth;
      iHeight:=jcprops.JPGHeight;
      iNChannels:=jcprops.JPGChannels;
      if (iNChannels = 3)
       then begin
        iDIBChannels:=iNChannels;
        //. create bitmap DIB
        ZeroMemory(@DIB_BitInfo,sizeof(BITMAPINFO));
        with DIB_BitInfo.bmiHeader do begin
        biSize:=sizeOf(DIB_BitInfo.bmiHeader);
        biBitCount:=24;
        biCompression:=BI_RGB;
        biPlanes:=1;
        biWidth:=iWidth;
        biHeight:=iHeight;
        biSizeImage:=(biWidth*(biBitCount div 8))*biHeight;
        end;
        //.
        DIB:=0;
        DIB:=CreateDIBSection(DC, DIB_BitInfo, DIB_RGB_COLORS, Pointer(BitsPtr), 0, 0);
        try
        jcprops.DIBWidth:=iWidth;
        jcprops.DIBHeight:=-iHeight;
        jcprops.DIBChannels:=iDIBChannels;
        jcprops.DIBColor:=IJL_BGR;
        jcprops.DIBPadBytes:=((((iWidth*iDIBChannels)+3) div 4)*4)-(iWidth*iDIBChannels);
        jcprops.DIBBytes:=Pointer(BitsPtr);
        iStatus:=ijlRead(@jcprops,IJL_JBUFF_READWHOLEIMAGE);
        if (iStatus < 0) then Exit; //. ->
        //.
        SelectObject(DC, DIB);
        //. aligning sizes if needed
        AlignedWidth:=RoundDownToPowerOf2(iWidth);
        AlignedHeight:=RoundDownToPowerOf2(iHeight);
        if ((AlignedWidth <> iWidth) OR (AlignedHeight <> iHeight))
         then begin
          StretchedDC:=CreateCompatibleDC(0);
          try
          ZeroMemory(@StretchedDIB_BitInfo,sizeof(BITMAPINFO));
          with StretchedDIB_BitInfo.bmiHeader do begin
          biSize:=sizeOf(StretchedDIB_BitInfo.bmiHeader);
          biBitCount:=24;
          biCompression:=BI_RGB;
          biPlanes:=1;
          biWidth:=AlignedWidth;
          biHeight:=AlignedHeight;
          biSizeImage:=(biWidth*(biBitCount div 8))*biHeight;
          end;
          //.
          StretchedDIB:=CreateDIBSection(StretchedDC, StretchedDIB_BitInfo, DIB_RGB_COLORS, Pointer(StretchedBitsPtr), 0, 0);
          try
          SelectObject(StretchedDC, StretchedDIB);
          //.
          SetStretchBltMode(StretchedDC,HALFTONE);
          StretchBlt(StretchedDC,0,0,AlignedWidth,AlignedHeight,DC,0,0,iWidth,iHeight,SRCCOPY);
          //.
          //. creating texture
          glGenTextures(1, @Result);
          glBindTexture(GL_TEXTURE_2D, Result);
          if (GL_EXT_bgra)
           then
            if (MinFilter = GL_NEAREST) or (MinFilter = GL_LINEAR)
              then glTexImage2d(GL_TEXTURE_2D, 0, 3, AlignedWidth, AlignedHeight, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE, StretchedBitsPtr)
              else gluBuild2DMipmaps(GL_TEXTURE_2D, 3, AlignedWidth, AlignedHeight, GL_BGR_EXT, GL_UNSIGNED_BYTE, StretchedBitsPtr)
           else begin
            {$ifopt R+} {$define RangeCheck} {$R-} {$endif}
            ImageSize:=AlignedWidth*AlignedHeight;
            for J := 0 to ImageSize - 1 do // swap blue with red to go from bgr to rgb
            begin
              Temp := StretchedBitsPtr[J * 3];
              StretchedBitsPtr[J * 3]:=StretchedBitsPtr[J * 3 + 2];
              StretchedBitsPtr[J * 3 + 2]:=Temp;
            end;
            {$ifdef RangeCheck} {$undef RangeCheck} {$R+} {$endif}
            if (MinFilter = GL_NEAREST) or (MinFilter = GL_LINEAR)
              then glTexImage2d(GL_TEXTURE_2D, 0, 3, AlignedWidth, AlignedHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, StretchedBitsPtr)
              else gluBuild2DMipmaps(GL_TEXTURE_2D, 3, AlignedWidth, AlignedHeight, GL_RGB, GL_UNSIGNED_BYTE, StretchedBitsPtr);
            end;
          finally
          if (StretchedDIB <> 0)
           then begin
            SelectObject(StretchedDC,0);
            DeleteObject(StretchedDIB);
            end;
          end;
          finally
          if (StretchedDC <> 0) then DeleteDC(StretchedDC);
          end;
          end
         else begin //. creating texture
          glGenTextures(1, @Result);
          glBindTexture(GL_TEXTURE_2D, Result);
          if (GL_EXT_bgra)
           then
            if (MinFilter = GL_NEAREST) or (MinFilter = GL_LINEAR)
              then glTexImage2d(GL_TEXTURE_2D, 0, 3, iWidth, iHeight, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE, BitsPtr)
              else gluBuild2DMipmaps(GL_TEXTURE_2D, 3, iWidth, iHeight, GL_BGR_EXT, GL_UNSIGNED_BYTE, BitsPtr)
           else begin
            {$ifopt R+} {$define RangeCheck} {$R-} {$endif}
            ImageSize:=iWidth*iHeight;
            for J := 0 to ImageSize - 1 do // swap blue with red to go from bgr to rgb
            begin
              Temp := BitsPtr[J * 3];
              BitsPtr[J * 3]:=BitsPtr[J * 3 + 2];
              BitsPtr[J * 3 + 2]:=Temp;
            end;
            {$ifdef RangeCheck} {$undef RangeCheck} {$R+} {$endif}
            if (MinFilter = GL_NEAREST) or (MinFilter = GL_LINEAR)
              then glTexImage2d(GL_TEXTURE_2D, 0, 3, iWidth, iHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, BitsPtr)
              else gluBuild2DMipmaps(GL_TEXTURE_2D, 3, iWidth, iHeight, GL_RGB, GL_UNSIGNED_BYTE, BitsPtr);
            end;
          end;
        finally
        if (DIB <> 0)
         then begin
          SelectObject(DC,0);
          DeleteObject(DIB);
          end;
        end;
        end;
      end;
    finally
    ijlFree(@jcprops);
    end;
  finally
  IJL_Lock.Leave;
  end;
  end;

begin
Result:=CreateTextureObject(Texture_DC,ImageStream,GL_NEAREST);
end;

function TTSVSegmentsOGLTextures.DoDrawOnCanvas(const Functionality: TBase2DVisualizationFunctionality; const Segments: pointer; const SegmentsSize: integer; const SegmentWidth: double; const SegmentHeight: double; const XIndexMin: integer; const YIndexMin: integer; const dX: Extended; const dY: Extended; const WidthScale: Extended; const HeightScale: Extended; const Rotation: Extended; const flBestQuality: boolean): boolean;
var
  I: integer;
  Segment: pointer;
begin
Result:=false;
//. draw
glMatrixMode(GL_PROJECTION);
glLoadIdentity;
glOrtho(0,DIB_BitInfo.bmiHeader.biWidth,0,DIB_BitInfo.bmiHeader.biHeight, 0, 1);
glTranslated(dX,DIB_BitInfo.bmiHeader.biHeight-dY, 0);
glMatrixMode(GL_MODELVIEW);
glLoadIdentity;
//. transformations
glRotated(-((180.0/PI)*Rotation),0,0,1);
glScaled(WidthScale,HeightScale,0);
//.
for I:=0 to (SegmentsSize DIV SizeOf(Pointer))-1 do begin
  Segment:=Pointer(Pointer(Integer(Segments)+I*SizeOf(Pointer))^);
  //.
  TypeSystem.Cash.Segment_Lock(Segment);
  try
  with TSegmentItemOfTTileServerVisualizationCash(Segment^) do begin
  if ((Params._DATA <> nil) AND (Params._DATA.Size > 0))
   then begin
    if (_idOGLTexture = 0) then _idOGLTexture:=InstallTexture(Params._DATA);
    //. drawing ...
    with Params do begin
    glPushMatrix;
    glTranslated(((XIndex-XIndexMin)*SegmentWidth),-((YIndex-YIndexMin)*SegmentHeight),0);
    glBindTexture(GL_TEXTURE_2D, _idOGLTexture);
    if (flBestQuality)
     then begin
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
      end
     else begin
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
      end;
    glBegin(GL_QUAD_STRIP);
      glTexCoord2d(0, 1);
      glVertex2d(0, 0);
      glTexCoord2d(1, 1);
      glVertex2d(SegmentWidth, 0);
      glTexCoord2d(0, 0);
      glVertex2d(0, -SegmentHeight);
      glTexCoord2d(1, 0);
      glVertex2d(SegmentWidth,-SegmentHeight);
    glEnd;
    glPopMatrix;
    end;
    //. segment accessed
    LastAccessTextureSegments_Insert(Segment);
    end;
  end;
  finally
  TypeSystem.Cash.Segment_Unlock(Segment);
  end;
  //.
  //. ? if ((Functionality <> nil) AND (Now > Functionality.BestBeforeTime)) then Break; //. >
  end;
//.
glFlush;
//.
Result:=true;
end;


{TTileServerParsedData}
class function TTileServerParsedData.GetParsedData(const ServerType: TTileServerType; const ServerData: TByteArray): TTileServerParsedData;
begin
case ServerType of
tstNative:              Result:=TNativeTileServerParsedData.Create(ServerData);
tstYandexMaps:          Result:=TYandexMapsTileServerParsedData.Create(ServerData);
tstGoogleMaps:          Result:=TGoogleMapsTileServerParsedData.Create(ServerData);
tstOpenStreetMaps:      Result:=TOpenStreetMapsTileServerParsedData.Create(ServerData);
tstNavitelMaps:         Result:=TNavitelMapsTileServerParsedData.Create(ServerData);
else
  Result:=nil;
end;
end;

Destructor TTileServerParsedData.Destroy();
begin
TileProviders_Clear();
Inherited;
end;

function  TTileServerParsedData.TileProviders_ItemIndex(const pID: integer): integer;
var
  I: integer;
begin
Result:=-1;
for I:=0 to Length(TileProviders)-1 do
  if (TileProviders[I].ID = pID)
   then begin
    Result:=I;
    Exit; //. ->
    end;
end;

function  TTileServerParsedData.TileProviders_GetItemIndex(const pID: integer): integer;
begin
Result:=TileProviders_ItemIndex(pID);
if (Result < 0) then Raise Exception.Create('TTileServerParsedData.TileProviders_GetItemIndex: unknown provider, ID: '+IntToStr(pID)); //. =>
end;

procedure TTileServerParsedData.TileProviders_FreeItem(const ItemIndex: integer);
begin
with TileProviders[ItemIndex] do begin
SetLength(Name,0);
SetLength(URL,0);
SetLength(Format,0);
end;
end;

procedure TTileServerParsedData.TileProviders_Clear();
var
  I: integer;
begin
for I:=0 to Length(TileProviders)-1 do TileProviders_FreeItem(I);
SetLength(TileProviders,0);
end;

function  TTileServerParsedData.TileProviders_GetNextID(): integer;
var
  I: integer;
begin
Result:=0;
for I:=0 to Length(TileProviders)-1 do
  if (TileProviders[I].ID > Result) then Result:=TileProviders[I].ID;
Inc(Result);
end;

function  TTileServerParsedData.TileProviders_AddNew(const TileProvider: TTileServerTileProvider): integer;
begin
Result:=Length(TileProviders);
SetLength(TileProviders,Result+1);
TileProviders[Result]:=TileProvider;
end;

procedure TTileServerParsedData.TileProviders_Delete(const ProviderIndex: integer);
var
  I: integer;
  NewTileProviders: TTileServerTileProviders;
  Idx: integer;
begin
if ((ProviderIndex < 0) OR (ProviderIndex >= Length(TileProviders))) then Raise Exception.Create('TTileServerParsedData.TileProviders_Delete: ProviderIndex out of bound '); //. =>
SetLength(NewTileProviders,Length(TileProviders)-1);
Idx:=0;
for I:=0 to Length(TileProviders)-1 do
  if (I <> ProviderIndex)
   then begin
    NewTileProviders[Idx]:=TileProviders[I];
    Inc(Idx);
    end
   else TileProviders_FreeItem(I);
SetLength(TileProviders,0);
TileProviders:=NewTileProviders;
end;

procedure TTileServerParsedData.TileProviders_Set(const ProviderIndex: integer; const TileProvider: TTileServerTileProvider);
begin
if ((ProviderIndex < 0) OR (ProviderIndex >= Length(TileProviders))) then Raise Exception.Create('TTileServerParsedData.TileProviders_Set: ProviderIndex out of bound '); //. =>
TileProviders_FreeItem(ProviderIndex);
TileProviders[ProviderIndex]:=TileProvider;
end;


{TNativeTileServerParsedData}
Constructor TNativeTileServerParsedData.Create();
begin
Inherited Create();
//.
SetDefaults();
end;

Constructor TNativeTileServerParsedData.Create(const ServerData: TByteArray);
var
  MS: TMemoryStream;
  OLEStream: IStream;
  Doc: IXMLDOMDocument;
  RootNode: IXMLDOMNode;
  VersionNode: IXMLDOMNode;
  Version: integer;
  TileProvidersNode,TileProviderNode,Node: IXMLDOMNode;
  I: integer;
begin
Inherited Create();
//.
SetDefaults();
//.
if (Length(ServerData) > 0)
 then begin
  MS:=TMemoryStream.Create();
  try
  MS.Write(Pointer(@ServerData[0])^,Length(ServerData));
  MS.Position:=0;
  OLEStream:=TStreamAdapter.Create(MS);
  Doc:=CoDomDocument.Create;
  Doc.Set_Async(false);
  Doc.Load(OLEStream);
  RootNode:=Doc.documentElement.selectSingleNode('/ROOT');
  VersionNode:=RootNode.selectSingleNode('Version');
  if VersionNode <> nil
   then Version:=VersionNode.nodeTypedValue
   else Version:=0;
  if (Version <> 1) then Raise Exception.Create('unknown version'); //. =>
  //.
  SetLength(TileProviders,0);
  TileProvidersNode:=RootNode.selectSingleNode('TileProviders');
  if (TileProvidersNode <> nil)
   then begin
    SetLength(TileProviders,TileProvidersNode.childNodes.length);
    for I:=0 to TileProvidersNode.childNodes.length-1 do begin
      TileProviderNode:=TileProvidersNode.childNodes[I];
      //.
      TileProviders[I].ServerType:=TileProviderNode.selectSingleNode('ServerType').nodeTypedValue;
      TileProviders[I].ID:=TileProviderNode.selectSingleNode('ID').nodeTypedValue;
      TileProviders[I].Name:=TileProviderNode.selectSingleNode('Name').nodeTypedValue;
      TileProviders[I].URL:=TileProviderNode.selectSingleNode('URL').nodeTypedValue;
      TileProviders[I].Format:=TileProviderNode.selectSingleNode('Format').nodeTypedValue;
      Node:=TileProviderNode.selectSingleNode('IndependentLevels'); if (Node <> nil) then TileProviders[I].flIndependentLevels:=(Node.nodeTypedValue <> 0) else TileProviders[I].flIndependentLevels:=false;
      end;
    end
  finally
  MS.Destroy();
  end;
  end;
end;

procedure TNativeTileServerParsedData.SetDefaults();
begin
end;

function TNativeTileServerParsedData.Clone(): TTileServerParsedData;
var
  C: TNativeTileServerParsedData;
  I: integer;
begin
C:=TNativeTileServerParsedData.Create();
SetLength(C.TileProviders,Length(TileProviders));
for I:=0 to Length(TileProviders)-1 do C.TileProviders[I]:=TileProviders[I];
Result:=C;
end;

function TNativeTileServerParsedData.ToByteArray(): TByteArray;
var
  Doc: IXMLDOMDocument;
  PI: IXMLDOMProcessingInstruction;
  Root: IXMLDOMElement;
  VersionNode: IXMLDOMElement;
  Node: IXMLDOMElement;
  TileProvidersNode,TileProviderNode: IXMLDOMElement;
  I: integer;
  MS: TMemoryStream;
  OLEStream: IStream;
begin
Doc:=CoDomDocument.Create();
Doc.Set_Async(false);
PI:=Doc.createProcessingInstruction('xml', 'version=''1.0''');
Doc.insertBefore(PI, Doc.childNodes.Item[0]);
Root:=Doc.createElement('ROOT');
Root.setAttribute('xmlns:dt', 'urn:schemas-microsoft-com:datatypes');
Doc.documentElement:=Root;
VersionNode:=Doc.createElement('Version');
VersionNode.nodeTypedValue:=1;
Root.appendChild(VersionNode);
//.
TileProvidersNode:=Doc.createElement('TileProviders');
for I:=0 to Length(TileProviders)-1 do begin
  TileProviderNode:=Doc.createElement('P'+IntToStr(TileProviders[I].ID));
  //.
  Node:=Doc.createElement('ServerType');
  Node.nodeTypedValue:=TileProviders[I].ServerType;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('ID');
  Node.nodeTypedValue:=TileProviders[I].ID;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('Name');
  Node.nodeTypedValue:=TileProviders[I].Name;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('URL');
  Node.nodeTypedValue:=TileProviders[I].URL;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('Format');
  Node.nodeTypedValue:=TileProviders[I].Format;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('IndependentLevels');
  if (TileProviders[I].flIndependentLevels) then Node.nodeTypedValue:=1 else Node.nodeTypedValue:=0;
  TileProviderNode.appendChild(Node);
  //.
  TileProvidersNode.appendChild(TileProviderNode);
  end;
Root.appendChild(TileProvidersNode);
//.
MS:=TMemoryStream.Create();
try
OLEStream:=TStreamAdapter.Create(MS);
Doc.Save(OLEStream);
SetLength(Result,MS.Size);
if (MS.Size > 0) then Move(MS.Memory^,Pointer(@Result[0])^,MS.Size);
finally
MS.Destroy();
end;
end;


{TYandexMapsTileServerParsedData}
Constructor TYandexMapsTileServerParsedData.Create();
begin
Inherited Create();
//.
SetDefaults();
end;

Constructor TYandexMapsTileServerParsedData.Create(const ServerData: TByteArray);
var
  MS: TMemoryStream;
  OLEStream: IStream;
  Doc: IXMLDOMDocument;
  RootNode: IXMLDOMNode;
  VersionNode: IXMLDOMNode;
  Version: integer;
  TileProvidersNode,TileProviderNode,Node: IXMLDOMNode;
  I: integer;
begin
Inherited Create();
//.
SetDefaults();
//.
if (Length(ServerData) > 0)
 then begin
  MS:=TMemoryStream.Create();
  try
  MS.Write(Pointer(@ServerData[0])^,Length(ServerData));
  MS.Position:=0;
  OLEStream:=TStreamAdapter.Create(MS);
  Doc:=CoDomDocument.Create;
  Doc.Set_Async(false);
  Doc.Load(OLEStream);
  RootNode:=Doc.documentElement.selectSingleNode('/ROOT');
  VersionNode:=RootNode.selectSingleNode('Version');
  if VersionNode <> nil
   then Version:=VersionNode.nodeTypedValue
   else Version:=0;
  if (Version <> 1) then Raise Exception.Create('unknown version'); //. =>
  //.
  SetLength(TileProviders,0);
  TileProvidersNode:=RootNode.selectSingleNode('TileProviders');
  if (TileProvidersNode <> nil)
   then begin
    SetLength(TileProviders,TileProvidersNode.childNodes.length);
    for I:=0 to TileProvidersNode.childNodes.length-1 do begin
      TileProviderNode:=TileProvidersNode.childNodes[I];
      //.
      Node:=TileProviderNode.selectSingleNode('ServerType'); if (Node <> nil) then TileProviders[I].ServerType:=Node.nodeTypedValue else TileProviders[I].ServerType:=-1;
      TileProviders[I].ID:=TileProviderNode.selectSingleNode('ID').nodeTypedValue;
      TileProviders[I].Name:=TileProviderNode.selectSingleNode('Name').nodeTypedValue;
      TileProviders[I].URL:=TileProviderNode.selectSingleNode('URL').nodeTypedValue;
      TileProviders[I].Format:=TileProviderNode.selectSingleNode('Format').nodeTypedValue;
      Node:=TileProviderNode.selectSingleNode('IndependentLevels'); if (Node <> nil) then TileProviders[I].flIndependentLevels:=(Node.nodeTypedValue <> 0) else TileProviders[I].flIndependentLevels:=false;
      end;
    end
  finally
  MS.Destroy();
  end;
  end;
end;

procedure TYandexMapsTileServerParsedData.SetDefaults();
begin
end;

function TYandexMapsTileServerParsedData.Clone(): TTileServerParsedData;
var
  C: TYandexMapsTileServerParsedData;
  I: integer;
begin
C:=TYandexMapsTileServerParsedData.Create();
SetLength(C.TileProviders,Length(TileProviders));
for I:=0 to Length(TileProviders)-1 do C.TileProviders[I]:=TileProviders[I];
Result:=C;
end;

function TYandexMapsTileServerParsedData.ToByteArray(): TByteArray;
var
  Doc: IXMLDOMDocument;
  PI: IXMLDOMProcessingInstruction;
  Root: IXMLDOMElement;
  VersionNode: IXMLDOMElement;
  Node: IXMLDOMElement;
  TileProvidersNode,TileProviderNode: IXMLDOMElement;
  I: integer;
  MS: TMemoryStream;
  OLEStream: IStream;
begin
Doc:=CoDomDocument.Create();
Doc.Set_Async(false);
PI:=Doc.createProcessingInstruction('xml', 'version=''1.0''');
Doc.insertBefore(PI, Doc.childNodes.Item[0]);
Root:=Doc.createElement('ROOT');
Root.setAttribute('xmlns:dt', 'urn:schemas-microsoft-com:datatypes');
Doc.documentElement:=Root;
VersionNode:=Doc.createElement('Version');
VersionNode.nodeTypedValue:=1;
Root.appendChild(VersionNode);
//.
TileProvidersNode:=Doc.createElement('TileProviders');
for I:=0 to Length(TileProviders)-1 do begin
  TileProviderNode:=Doc.createElement('P'+IntToStr(TileProviders[I].ID));
  //.
  Node:=Doc.createElement('ServerType');
  Node.nodeTypedValue:=TileProviders[I].ServerType;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('ID');
  Node.nodeTypedValue:=TileProviders[I].ID;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('Name');
  Node.nodeTypedValue:=TileProviders[I].Name;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('URL');
  Node.nodeTypedValue:=TileProviders[I].URL;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('Format');
  Node.nodeTypedValue:=TileProviders[I].Format;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('IndependentLevels');
  if (TileProviders[I].flIndependentLevels) then Node.nodeTypedValue:=1 else Node.nodeTypedValue:=0;
  TileProviderNode.appendChild(Node);
  //.
  TileProvidersNode.appendChild(TileProviderNode);
  end;
Root.appendChild(TileProvidersNode);
//.
MS:=TMemoryStream.Create();
try
OLEStream:=TStreamAdapter.Create(MS);
Doc.Save(OLEStream);
SetLength(Result,MS.Size);
if (MS.Size > 0) then Move(MS.Memory^,Pointer(@Result[0])^,MS.Size);
finally
MS.Destroy();
end;
end;


{TGoogleMapsTileServerParsedData}
Constructor TGoogleMapsTileServerParsedData.Create();
begin
Inherited Create();
//.
SetDefaults();
end;

Constructor TGoogleMapsTileServerParsedData.Create(const ServerData: TByteArray);
var
  MS: TMemoryStream;
  OLEStream: IStream;
  Doc: IXMLDOMDocument;
  RootNode: IXMLDOMNode;
  VersionNode: IXMLDOMNode;
  Version: integer;
  TileProvidersNode,TileProviderNode,Node: IXMLDOMNode;
  I: integer;
begin
Inherited Create();
//.
SetDefaults();
//.
if (Length(ServerData) > 0)
 then begin
  MS:=TMemoryStream.Create();
  try
  MS.Write(Pointer(@ServerData[0])^,Length(ServerData));
  MS.Position:=0;
  OLEStream:=TStreamAdapter.Create(MS);
  Doc:=CoDomDocument.Create;
  Doc.Set_Async(false);
  Doc.Load(OLEStream);
  RootNode:=Doc.documentElement.selectSingleNode('/ROOT');
  VersionNode:=RootNode.selectSingleNode('Version');
  if VersionNode <> nil
   then Version:=VersionNode.nodeTypedValue
   else Version:=0;
  if (Version <> 1) then Raise Exception.Create('unknown version'); //. =>
  //.
  SetLength(TileProviders,0);
  TileProvidersNode:=RootNode.selectSingleNode('TileProviders');
  if (TileProvidersNode <> nil)
   then begin
    SetLength(TileProviders,TileProvidersNode.childNodes.length);
    for I:=0 to TileProvidersNode.childNodes.length-1 do begin
      TileProviderNode:=TileProvidersNode.childNodes[I];
      //.
      Node:=TileProviderNode.selectSingleNode('ServerType'); if (Node <> nil) then TileProviders[I].ServerType:=Node.nodeTypedValue else TileProviders[I].ServerType:=-1;
      TileProviders[I].ID:=TileProviderNode.selectSingleNode('ID').nodeTypedValue;
      TileProviders[I].Name:=TileProviderNode.selectSingleNode('Name').nodeTypedValue;
      TileProviders[I].URL:=TileProviderNode.selectSingleNode('URL').nodeTypedValue;
      TileProviders[I].Format:=TileProviderNode.selectSingleNode('Format').nodeTypedValue;
      Node:=TileProviderNode.selectSingleNode('IndependentLevels'); if (Node <> nil) then TileProviders[I].flIndependentLevels:=(Node.nodeTypedValue <> 0) else TileProviders[I].flIndependentLevels:=false;
      end;
    end
  finally
  MS.Destroy();
  end;
  end;
end;

procedure TGoogleMapsTileServerParsedData.SetDefaults();
begin
end;

function TGoogleMapsTileServerParsedData.Clone(): TTileServerParsedData;
var
  C: TGoogleMapsTileServerParsedData;
  I: integer;
begin
C:=TGoogleMapsTileServerParsedData.Create();
SetLength(C.TileProviders,Length(TileProviders));
for I:=0 to Length(TileProviders)-1 do C.TileProviders[I]:=TileProviders[I];
Result:=C;
end;

function TGoogleMapsTileServerParsedData.ToByteArray(): TByteArray;
var
  Doc: IXMLDOMDocument;
  PI: IXMLDOMProcessingInstruction;
  Root: IXMLDOMElement;
  VersionNode: IXMLDOMElement;
  Node: IXMLDOMElement;
  TileProvidersNode,TileProviderNode: IXMLDOMElement;
  I: integer;
  MS: TMemoryStream;
  OLEStream: IStream;
begin
Doc:=CoDomDocument.Create();
Doc.Set_Async(false);
PI:=Doc.createProcessingInstruction('xml', 'version=''1.0''');
Doc.insertBefore(PI, Doc.childNodes.Item[0]);
Root:=Doc.createElement('ROOT');
Root.setAttribute('xmlns:dt', 'urn:schemas-microsoft-com:datatypes');
Doc.documentElement:=Root;
VersionNode:=Doc.createElement('Version');
VersionNode.nodeTypedValue:=1;
Root.appendChild(VersionNode);
//.
TileProvidersNode:=Doc.createElement('TileProviders');
for I:=0 to Length(TileProviders)-1 do begin
  TileProviderNode:=Doc.createElement('P'+IntToStr(TileProviders[I].ID));
  //.
  Node:=Doc.createElement('ServerType');
  Node.nodeTypedValue:=TileProviders[I].ServerType;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('ID');
  Node.nodeTypedValue:=TileProviders[I].ID;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('Name');
  Node.nodeTypedValue:=TileProviders[I].Name;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('URL');
  Node.nodeTypedValue:=TileProviders[I].URL;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('Format');
  Node.nodeTypedValue:=TileProviders[I].Format;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('IndependentLevels');
  if (TileProviders[I].flIndependentLevels) then Node.nodeTypedValue:=1 else Node.nodeTypedValue:=0;
  TileProviderNode.appendChild(Node);
  //.
  TileProvidersNode.appendChild(TileProviderNode);
  end;
Root.appendChild(TileProvidersNode);
//.
MS:=TMemoryStream.Create();
try
OLEStream:=TStreamAdapter.Create(MS);
Doc.Save(OLEStream);
SetLength(Result,MS.Size);
if (MS.Size > 0) then Move(MS.Memory^,Pointer(@Result[0])^,MS.Size);
finally
MS.Destroy();
end;
end;


{TOpenStreetMapsTileServerParsedData}
Constructor TOpenStreetMapsTileServerParsedData.Create();
begin
Inherited Create();
//.
SetDefaults();
end;

Constructor TOpenStreetMapsTileServerParsedData.Create(const ServerData: TByteArray);
var
  MS: TMemoryStream;
  OLEStream: IStream;
  Doc: IXMLDOMDocument;
  RootNode: IXMLDOMNode;
  VersionNode: IXMLDOMNode;
  Version: integer;
  TileProvidersNode,TileProviderNode,Node: IXMLDOMNode;
  I: integer;
begin
Inherited Create();
//.
SetDefaults();
//.
if (Length(ServerData) > 0)
 then begin
  MS:=TMemoryStream.Create();
  try
  MS.Write(Pointer(@ServerData[0])^,Length(ServerData));
  MS.Position:=0;
  OLEStream:=TStreamAdapter.Create(MS);
  Doc:=CoDomDocument.Create;
  Doc.Set_Async(false);
  Doc.Load(OLEStream);
  RootNode:=Doc.documentElement.selectSingleNode('/ROOT');
  VersionNode:=RootNode.selectSingleNode('Version');
  if VersionNode <> nil
   then Version:=VersionNode.nodeTypedValue
   else Version:=0;
  if (Version <> 1) then Raise Exception.Create('unknown version'); //. =>
  //.
  SetLength(TileProviders,0);
  TileProvidersNode:=RootNode.selectSingleNode('TileProviders');
  if (TileProvidersNode <> nil)
   then begin
    SetLength(TileProviders,TileProvidersNode.childNodes.length);
    for I:=0 to TileProvidersNode.childNodes.length-1 do begin
      TileProviderNode:=TileProvidersNode.childNodes[I];
      //.
      Node:=TileProviderNode.selectSingleNode('ServerType'); if (Node <> nil) then TileProviders[I].ServerType:=Node.nodeTypedValue else TileProviders[I].ServerType:=-1;
      TileProviders[I].ID:=TileProviderNode.selectSingleNode('ID').nodeTypedValue;
      TileProviders[I].Name:=TileProviderNode.selectSingleNode('Name').nodeTypedValue;
      TileProviders[I].URL:=TileProviderNode.selectSingleNode('URL').nodeTypedValue;
      TileProviders[I].Format:=TileProviderNode.selectSingleNode('Format').nodeTypedValue;
      Node:=TileProviderNode.selectSingleNode('IndependentLevels'); if (Node <> nil) then TileProviders[I].flIndependentLevels:=(Node.nodeTypedValue <> 0) else TileProviders[I].flIndependentLevels:=false;
      end;
    end
  finally
  MS.Destroy();
  end;
  end;
end;

procedure TOpenStreetMapsTileServerParsedData.SetDefaults();
begin
end;

function TOpenStreetMapsTileServerParsedData.Clone(): TTileServerParsedData;
var
  C: TOpenStreetMapsTileServerParsedData;
  I: integer;
begin
C:=TOpenStreetMapsTileServerParsedData.Create();
SetLength(C.TileProviders,Length(TileProviders));
for I:=0 to Length(TileProviders)-1 do C.TileProviders[I]:=TileProviders[I];
Result:=C;
end;

function TOpenStreetMapsTileServerParsedData.ToByteArray(): TByteArray;
var
  Doc: IXMLDOMDocument;
  PI: IXMLDOMProcessingInstruction;
  Root: IXMLDOMElement;
  VersionNode: IXMLDOMElement;
  Node: IXMLDOMElement;
  TileProvidersNode,TileProviderNode: IXMLDOMElement;
  I: integer;
  MS: TMemoryStream;
  OLEStream: IStream;
begin
Doc:=CoDomDocument.Create();
Doc.Set_Async(false);
PI:=Doc.createProcessingInstruction('xml', 'version=''1.0''');
Doc.insertBefore(PI, Doc.childNodes.Item[0]);
Root:=Doc.createElement('ROOT');
Root.setAttribute('xmlns:dt', 'urn:schemas-microsoft-com:datatypes');
Doc.documentElement:=Root;
VersionNode:=Doc.createElement('Version');
VersionNode.nodeTypedValue:=1;
Root.appendChild(VersionNode);
//.
TileProvidersNode:=Doc.createElement('TileProviders');
for I:=0 to Length(TileProviders)-1 do begin
  TileProviderNode:=Doc.createElement('P'+IntToStr(TileProviders[I].ID));
  //.
  Node:=Doc.createElement('ServerType');
  Node.nodeTypedValue:=TileProviders[I].ServerType;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('ID');
  Node.nodeTypedValue:=TileProviders[I].ID;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('Name');
  Node.nodeTypedValue:=TileProviders[I].Name;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('URL');
  Node.nodeTypedValue:=TileProviders[I].URL;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('Format');
  Node.nodeTypedValue:=TileProviders[I].Format;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('IndependentLevels');
  if (TileProviders[I].flIndependentLevels) then Node.nodeTypedValue:=1 else Node.nodeTypedValue:=0;
  TileProviderNode.appendChild(Node);
  //.
  TileProvidersNode.appendChild(TileProviderNode);
  end;
Root.appendChild(TileProvidersNode);
//.
MS:=TMemoryStream.Create();
try
OLEStream:=TStreamAdapter.Create(MS);
Doc.Save(OLEStream);
SetLength(Result,MS.Size);
if (MS.Size > 0) then Move(MS.Memory^,Pointer(@Result[0])^,MS.Size);
finally
MS.Destroy();
end;
end;


{TNavitelMapsTileServerParsedData}
Constructor TNavitelMapsTileServerParsedData.Create();
begin
Inherited Create();
//.
SetDefaults();
end;

Constructor TNavitelMapsTileServerParsedData.Create(const ServerData: TByteArray);
var
  MS: TMemoryStream;
  OLEStream: IStream;
  Doc: IXMLDOMDocument;
  RootNode: IXMLDOMNode;
  VersionNode: IXMLDOMNode;
  Version: integer;
  TileProvidersNode,TileProviderNode,Node: IXMLDOMNode;
  I: integer;
begin
Inherited Create();
//.
SetDefaults();
//.
if (Length(ServerData) > 0)
 then begin
  MS:=TMemoryStream.Create();
  try
  MS.Write(Pointer(@ServerData[0])^,Length(ServerData));
  MS.Position:=0;
  OLEStream:=TStreamAdapter.Create(MS);
  Doc:=CoDomDocument.Create;
  Doc.Set_Async(false);
  Doc.Load(OLEStream);
  RootNode:=Doc.documentElement.selectSingleNode('/ROOT');
  VersionNode:=RootNode.selectSingleNode('Version');
  if VersionNode <> nil
   then Version:=VersionNode.nodeTypedValue
   else Version:=0;
  if (Version <> 1) then Raise Exception.Create('unknown version'); //. =>
  //.
  SetLength(TileProviders,0);
  TileProvidersNode:=RootNode.selectSingleNode('TileProviders');
  if (TileProvidersNode <> nil)
   then begin
    SetLength(TileProviders,TileProvidersNode.childNodes.length);
    for I:=0 to TileProvidersNode.childNodes.length-1 do begin
      TileProviderNode:=TileProvidersNode.childNodes[I];
      //.
      Node:=TileProviderNode.selectSingleNode('ServerType'); if (Node <> nil) then TileProviders[I].ServerType:=Node.nodeTypedValue else TileProviders[I].ServerType:=-1;
      TileProviders[I].ID:=TileProviderNode.selectSingleNode('ID').nodeTypedValue;
      TileProviders[I].Name:=TileProviderNode.selectSingleNode('Name').nodeTypedValue;
      TileProviders[I].URL:=TileProviderNode.selectSingleNode('URL').nodeTypedValue;
      TileProviders[I].Format:=TileProviderNode.selectSingleNode('Format').nodeTypedValue;
      Node:=TileProviderNode.selectSingleNode('IndependentLevels'); if (Node <> nil) then TileProviders[I].flIndependentLevels:=(Node.nodeTypedValue <> 0) else TileProviders[I].flIndependentLevels:=false;
      end;
    end
  finally
  MS.Destroy();
  end;
  end;
end;

procedure TNavitelMapsTileServerParsedData.SetDefaults();
begin
end;

function TNavitelMapsTileServerParsedData.Clone(): TTileServerParsedData;
var
  C: TNavitelMapsTileServerParsedData;
  I: integer;
begin
C:=TNavitelMapsTileServerParsedData.Create();
SetLength(C.TileProviders,Length(TileProviders));
for I:=0 to Length(TileProviders)-1 do C.TileProviders[I]:=TileProviders[I];
Result:=C;
end;

function TNavitelMapsTileServerParsedData.ToByteArray(): TByteArray;
var
  Doc: IXMLDOMDocument;
  PI: IXMLDOMProcessingInstruction;
  Root: IXMLDOMElement;
  VersionNode: IXMLDOMElement;
  Node: IXMLDOMElement;
  TileProvidersNode,TileProviderNode: IXMLDOMElement;
  I: integer;
  MS: TMemoryStream;
  OLEStream: IStream;
begin
Doc:=CoDomDocument.Create();
Doc.Set_Async(false);
PI:=Doc.createProcessingInstruction('xml', 'version=''1.0''');
Doc.insertBefore(PI, Doc.childNodes.Item[0]);
Root:=Doc.createElement('ROOT');
Root.setAttribute('xmlns:dt', 'urn:schemas-microsoft-com:datatypes');
Doc.documentElement:=Root;
VersionNode:=Doc.createElement('Version');
VersionNode.nodeTypedValue:=1;
Root.appendChild(VersionNode);
//.
TileProvidersNode:=Doc.createElement('TileProviders');
for I:=0 to Length(TileProviders)-1 do begin
  TileProviderNode:=Doc.createElement('P'+IntToStr(TileProviders[I].ID));
  //.
  Node:=Doc.createElement('ServerType');
  Node.nodeTypedValue:=TileProviders[I].ServerType;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('ID');
  Node.nodeTypedValue:=TileProviders[I].ID;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('Name');
  Node.nodeTypedValue:=TileProviders[I].Name;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('URL');
  Node.nodeTypedValue:=TileProviders[I].URL;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('Format');
  Node.nodeTypedValue:=TileProviders[I].Format;
  TileProviderNode.appendChild(Node);
  //.
  Node:=Doc.createElement('IndependentLevels');
  if (TileProviders[I].flIndependentLevels) then Node.nodeTypedValue:=1 else Node.nodeTypedValue:=0;
  TileProviderNode.appendChild(Node);
  //.
  TileProvidersNode.appendChild(TileProviderNode);
  end;
Root.appendChild(TileProvidersNode);
//.
MS:=TMemoryStream.Create();
try
OLEStream:=TStreamAdapter.Create(MS);
Doc.Save(OLEStream);
SetLength(Result,MS.Size);
if (MS.Size > 0) then Move(MS.Memory^,Pointer(@Result[0])^,MS.Size);
finally
MS.Destroy();
end;
end;


//. TTTileServerVisualizationCash
Constructor TTTileServerVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
Lock:=TMultiReadExclusiveWriteSynchronizer.Create;
AccessedSegmentsRevising:=TTSVAccessedSegmentsRevising.Create(Self);
PersistLevelsProviding:=TTSVPersistLevelsProviding.Create(Self);
FItems:=nil;
end;

destructor TTTileServerVisualizationCash.Destroy;
begin
Empty;
PersistLevelsProviding.Free;
AccessedSegmentsRevising.Free;
Lock.Free;
Inherited;
end;

procedure TTTileServerVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
Lock.BeginWrite;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTTileServerVisualizationCash(ptrDelItem^).ptrNext;
  //.
  SetLength(TItemTTileServerVisualizationCash(ptrDelItem^).ServerURL,0);
  SetLength(TItemTTileServerVisualizationCash(ptrDelItem^).ServerData,0);
  FreeAndNil(TItemTTileServerVisualizationCash(ptrDelItem^).ServerParsedData);
  TTileServerVisualizationCashItem_FreeAndNilLevels(TSystemTTileServerVisualization(TypeSystem),TItemTTileServerVisualizationCash(ptrDelItem^).Levels);
  //.
  FreeMem(ptrDelItem,SizeOf(TItemTTileServerVisualizationCash));
  end;
finally
Lock.EndWrite;
end;
end;

procedure TTTileServerVisualizationCash.ConvertDATAToBMP(const DS: TMemoryStream; out BMP: TBitmap);
var
  JI: TJPEGImage;
begin
JI:=TJPEGImage.Create;
with JI do
try
with TBitmap.Create do
try
if DS.Size > 0
 then begin
  JI.LoadFromStream(DS);
  Canvas.Lock();
  try
  Assign(JI);
  finally
  Canvas.Unlock();
  end;
  end;
BMP:=TBitmap.Create;
BMP.Canvas.Lock();
try
BMP.HandleType:=bmDIB;
BMP.PixelFormat:=pf24bit;
BMP.Assign(JI);
finally
BMP.Canvas.Unlock();
end;
finally
Destroy;
end;
finally
Destroy;
end;
end;

procedure TTTileServerVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TTileServerVisualizationFunctionality;
  BA: TByteArray;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTTileServerVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTTileServerVisualizationCash), 0);
    with TItemTTileServerVisualizationCash(ptrNewItem^) do begin
    ptrObj:=nilPtr;
    Levels:=nil;
    ServerType:=0;
    ServerURL:='';
    ServerData:=nil;
    ServerParsedData:=nil;
    TileProviderID:=0;
    Width:=0;
    Height:=0;
    CF:=TTileServerVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetParams(ServerType,ServerURL,ServerData,TileProviderID,Width,Height);
    ServerParsedData:=ParseServerData(TTileServerType(ServerType),ServerData);
    CF.GetLevelsInfo(BA);
    TTileServerVisualizationCashItem_PrepareLevelsFromByteArray(ptrNewItem,Levels,BA);
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    Lock.BeginWrite;
    try
    TItemTTileServerVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    Lock.EndWrite;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTTileServerVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTTileServerVisualizationCash), 0);
    with TItemTTileServerVisualizationCash(ptrNewItem^) do begin
    ptrObj:=nilPtr;
    Levels:=nil;
    ServerType:=0;
    ServerURL:='';
    ServerData:=nil;
    ServerParsedData:=nil;
    TileProviderID:=0;
    Width:=0;
    Height:=0;
    CF:=TTileServerVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try CF.GetParams(ServerType,ServerURL,ServerData,TileProviderID,Width,Height); except on E: EActionsGroup do ; else Raise; end;
    try CF.GetLevelsInfo(BA); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTTileServerVisualizationCash(ItemsList[I]^) do with TTileServerVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    with TItemTTileServerVisualizationCash(ItemsList[I]^) do begin
    GetParams(ServerType,ServerURL,ServerData,TileProviderID,Width,Height);
    ServerParsedData:=ParseServerData(TTileServerType(ServerType),ServerData);
    end;
    GetLevelsInfo(BA);
    TTileServerVisualizationCashItem_PrepareLevelsFromByteArray(ItemsList[I],Levels,BA);
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  Lock.BeginWrite;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTTileServerVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  Lock.EndWrite;
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;



procedure TTTileServerVisualizationCash.Update;
begin
Empty;
end;

function TTTileServerVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
Lock.BeginWrite;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTTileServerVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTTileServerVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit; //. ->
    end;
  ptrptrItem:=@ptrNext;
  end;
finally
Lock.EndWrite;
end;
end;

function TTTileServerVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if (ptrItem = nil) then Exit; //. ->
Result:=true;
end;

function TTTileServerVisualizationCash.NotRecombinatedGetPtrItem(const pidObj: integer): pointer;
begin
Lock.BeginRead;
try
Result:=FItems;
while (Result <> nil) do with TItemTTileServerVisualizationCash(Result^) do begin
  if (idObj = pidObj) then Exit; //. ->
  //. next item
  Result:=ptrNext;
  end;
finally
Lock.EndRead;
end;
end;

function TTTileServerVisualizationCash.NotRecombinatedGetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=NotRecombinatedGetPtrItem(pidObj);
if (ptrItem = nil) then Exit; //. ->
Result:=true;
end;

procedure TTTileServerVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
Lock.BeginRead;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTTileServerVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
Lock.EndRead;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTTileServerVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TTileServerVisualizationFunctionality;
    BA: TByteArray;
  begin
  with TItemTTileServerVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TTileServerVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  SetLength(ServerURL,0);
  SetLength(ServerData,0);
  FreeAndNil(ServerParsedData);
  TTileServerVisualizationCashItem_FreeAndNilLevels(TSystemTTileServerVisualization(TypeSystem),Levels);
  //.
  idObj:=CF.idObj;
  CF.GetParams(ServerType,ServerURL,ServerData,TileProviderID,Width,Height);
  ServerParsedData:=ParseServerData(ServerType,ServerData);
  CF.GetLevelsInfo(BA);
  TTileServerVisualizationCashItem_PrepareLevelsFromByteArray(ptrItem,Levels,BA);
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
  ptrDestroyItem: pointer;
begin
Lock.BeginWrite;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTTileServerVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTTileServerVisualizationCash), 0);
  with TItemTTileServerVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  ptrObj:=nilPtr;
  ServerType:=0;
  ServerURL:='';
  ServerData:=nil;
  ServerParsedData:=nil;
  TileProviderID:=0;
  Width:=0;
  Height:=0;
  Levels:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then begin
    //. remove segments
    AccessedSegmentsRevising.RemoveVisualizationSegments(ptrUpdateItem);
    Context_DestroyItemSegmentFiles(pidObj);
    //.
    UpdateItem(ptrUpdateItem);
    end
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTTileServerVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTTileServerVisualizationCash), 0);
    with TItemTTileServerVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    ptrObj:=nilPtr;
    ServerType:=0;
    ServerURL:='';
    ServerData:=nil;
    ServerParsedData:=nil;
    TileProviderID:=0;
    Width:=0;
    Height:=0;
    Levels:=nil;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  //. remove segments
  ptrDestroyItem:=GetPtrItem(pidObj);
  if (ptrDestroyItem <> nil) then AccessedSegmentsRevising.RemoveVisualizationSegments(ptrDestroyItem);
  Context_DestroyItemSegmentFiles(pidObj);
  //.
  RemoveItem(pidObj);
  end;
end;
finally
Lock.EndWrite;
end;
end;}

procedure TTTileServerVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TTileServerVisualizationFunctionality;
    BA: TByteArray;
  begin
  with TItemTTileServerVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TTileServerVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  SetLength(ServerURL,0);
  SetLength(ServerData,0);
  FreeAndNil(ServerParsedData);
  TTileServerVisualizationCashItem_FreeAndNilLevels(TSystemTTileServerVisualization(TypeSystem),Levels);
  //.
  idObj:=CF.idObj;
  CF.GetParams(ServerType,ServerURL,ServerData,TileProviderID,Width,Height);
  ServerParsedData:=ParseServerData(TTileServerType(ServerType),ServerData);
  CF.GetLevelsInfo(BA);
  TTileServerVisualizationCashItem_PrepareLevelsFromByteArray(ptrItem,Levels,BA);
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTTileServerVisualizationCash; const ptrItem: pointer);

    procedure Levels_ValidatePointers(const Levels: pointer; const ptrDestItem: pointer);
    var
      ptrLevel: pointer;
    begin
    ptrLevel:=Levels;
    while (ptrLevel <> nil) do with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
      ptrItem:=ptrDestItem;
      ptrLevel:=ptrNext;
      end;
    end;

  begin
  with TItemTTileServerVisualizationCash(ptrItem^) do begin
  //. defaults
  SetLength(ServerURL,0);
  SetLength(ServerData,0);
  FreeAndNil(ServerParsedData);
  TTileServerVisualizationCashItem_FreeAndNilLevels(TSystemTTileServerVisualization(TypeSystem),Levels);
  //.
  ServerType:=Item.ServerType;
  ServerURL:=Item.ServerURL;
  ServerData:=Item.ServerData;
  ServerParsedData:=Item.ServerParsedData;
  TileProviderID:=Item.TileProviderID;
  Width:=Item.Width;
  Height:=Item.Height;
  Levels:=Item.Levels;
  //. validate levels pointers to owner object
  Levels_ValidatePointers(Levels,ptrItem);
  end;
  end;

  procedure FreeItem(var Item: TItemTTileServerVisualizationCash);
  begin
  SetLength(Item.ServerURL,0);
  SetLength(Item.ServerData,0);
  FreeAndNil(Item.ServerParsedData);
  TTileServerVisualizationCashItem_FreeAndNilLevels(TSystemTTileServerVisualization(TypeSystem),Item.Levels);
  end;

var
  Item: TItemTTileServerVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
  ptrDestroyItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
Lock.BeginWrite;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTTileServerVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTTileServerVisualizationCash), 0);
  with TItemTTileServerVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  ptrObj:=nilPtr;
  ServerType:=0;
  ServerURL:='';
  ServerData:=nil;
  ServerParsedData:=nil;
  TileProviderID:=0;
  Width:=0;
  Height:=0;
  Levels:=nil;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then begin
    //. remove segments
    AccessedSegmentsRevising.RemoveVisualizationSegments(ptrUpdateItem);
    Context_DestroyItemSegmentFiles(pidObj);
    //.
    MoveItem(Item,ptrUpdateItem);
    end
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTTileServerVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTTileServerVisualizationCash), 0);
    with TItemTTileServerVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    ptrObj:=nilPtr;
    ServerType:=0;
    ServerURL:='';
    ServerData:=nil;
    ServerParsedData:=nil;
    TileProviderID:=0;
    Width:=0;
    Height:=0;
    Levels:=nil;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  //. remove segments
  ptrDestroyItem:=GetPtrItem(pidObj);
  if (ptrDestroyItem <> nil) then AccessedSegmentsRevising.RemoveVisualizationSegments(ptrDestroyItem);
  Context_DestroyItemSegmentFiles(pidObj);
  //.
  RemoveItem(pidObj);
  end;
end;
finally
Lock.EndWrite;
end;
end;

procedure TTTileServerVisualizationCash.UpdateLocalForPartialUpdate(const idObj: integer; const Data: TByteArray);
var
  ptrData: pointer;
  Version: word;
  idLevel: integer;
  XMinIndex,YMinIndex,XMaxIndex,YMaxIndex: integer;
  ptrItem: pointer;
  ptrLevel: pointer;
  ExceptSegments: TByteArray;
  I: integer;
begin
ptrData:=Pointer(@Data[0]);
Version:=Word(ptrData^); Inc(Integer(ptrData),SizeOf(Version));
case Version of
1: begin
  idLevel:=Integer(ptrData^); Inc(Integer(ptrData),SizeOf(idLevel));
  XMinIndex:=Integer(ptrData^); Inc(Integer(ptrData),SizeOf(XMinIndex));
  YMinIndex:=Integer(ptrData^); Inc(Integer(ptrData),SizeOf(YMinIndex));
  XMaxIndex:=Integer(ptrData^); Inc(Integer(ptrData),SizeOf(XMaxIndex));
  YMaxIndex:=Integer(ptrData^); Inc(Integer(ptrData),SizeOf(YMaxIndex));
  //. updating segments
  TSystemTTileServerVisualization(TypeSystem).Cash.Lock.BeginRead;
  try
  ptrItem:=NotRecombinatedGetPtrItem(idObj);
  if (ptrItem = nil) then Exit; //. ->
  ptrLevel:=TItemTTileServerVisualizationCash(ptrItem^).Levels;
  while (ptrLevel <> nil) do with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
    Lock.BeginRead;
    try
    if (Params.id = idLevel) then Break; //. >
    finally
    Lock.EndRead;
    end;
    //. next level
    ptrLevel:=ptrNext;
    end;
  if (ptrLevel = nil) then Exit; //. ->
  //.
  SetLength(ExceptSegments,0);
  if (TItemTTileServerVisualizationCash(ptrItem^).ServerParsedData <> nil)
   then
    for I:=0 to Length(TItemTTileServerVisualizationCash(ptrItem^).ServerParsedData.TileProviders)-1 do
      Item_Level__UpdateSegmentsLocal(ptrItem,TItemTTileServerVisualizationCash(ptrItem^).ServerParsedData.TileProviders[I].ID,ptrLevel, XMinIndex,XMaxIndex,YMinIndex,YMaxIndex, ExceptSegments, nil);
  finally
  TSystemTTileServerVisualization(TypeSystem).Cash.Lock.EndRead;
  end;
  end;
else
  EventLog.WriteMinorEvent('TTTileServerVisualizationCash.UpdateLocalForPartialUpdate','Unknown update data version, Version = '+IntToStr(Version),'Supported version(s): 1');
end;
end;

procedure TTTileServerVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
Lock.BeginWrite;
try
ptrptrDelItem:=@FItems;
while (Pointer(ptrptrDelItem^) <> nil) do with TItemTTileServerVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if (idObj = pidObj)
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTTileServerVisualizationCash(ptrDelItem^).ptrNext;
    //.
    SetLength(TItemTTileServerVisualizationCash(ptrDelItem^).ServerURL,0);
    SetLength(TItemTTileServerVisualizationCash(ptrDelItem^).ServerData,0);
    FreeAndNil(TItemTTileServerVisualizationCash(ptrDelItem^).ServerParsedData);
    TTileServerVisualizationCashItem_FreeAndNilLevels(TSystemTTileServerVisualization(TypeSystem),TItemTTileServerVisualizationCash(ptrDelItem^).Levels);
    //.
    FreeMem(ptrDelItem,SizeOf(TItemTTileServerVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTTileServerVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
Lock.EndWrite;
end;
end;

function TTTileServerVisualizationCash.Item_GetContextFolder(const Item_idObj: integer): string;
begin
with Space do Result:=WorkLocale+'\'+PathContexts+'\'+IntToStr(ID)+'\'+SUMMARYUserContextFolder+'\'+ChangeFileExt(ContextFileName,'')+'\'+'TypesSystem'+'\'+'TileServerVisualization'+'\'+IntToStr(Item_idObj);
end;

function TTTileServerVisualizationCash.Item_Level__GetContextFolder(const Item_idObj: integer; const TileProviderID: integer; const idLevel: integer): string;
begin
with Space do Result:=WorkLocale+'\'+PathContexts+'\'+IntToStr(ID)+'\'+SUMMARYUserContextFolder+'\'+ChangeFileExt(ContextFileName,'')+'\'+'TypesSystem'+'\'+'TileServerVisualization'+'\'+IntToStr(Item_idObj)+'\'+IntToStr(TileProviderID)+'\'+'L'+IntToStr(idLevel);
end;

function TTTileServerVisualizationCash.Item_Level__GetSegmentsLocal(const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; out LocalSegments: TByteArray): boolean;
var
  SizeX,SizeY: integer;
  ItemsList: TList;
  Segment: pointer;
  SegmentID: integer;
  I: integer;
begin
SizeX:=(XIndexMax-XIndexMin+1);
SizeY:=(YIndexMax-YIndexMin+1);
with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
Lock.BeginRead;
try
//. prepare cached segments
ItemsList:=TList.Create;
try
ItemsList.Capacity:=(SizeX*SizeY);
Segment:=Segments;
while (Segment <> nil) AND (TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.YIndex < YIndexMin) do Segment:=TSegmentItemOfTTileServerVisualizationCash(Segment^).ptrNext;
while (Segment <> nil) AND (TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.YIndex <= YIndexMax) do begin
  if ((XIndexMin <= TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.XIndex) AND (TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.XIndex <= XIndexMax))
   then ItemsList.Add(Segment);
  Segment:=TSegmentItemOfTTileServerVisualizationCash(Segment^).ptrNext;
  end;
if (ItemsList.Count > 0)
 then begin
  if (ItemsList.Count <> (SizeX*SizeY))
   then begin
    SetLength(LocalSegments,(ItemsList.Count*SizeOf(SegmentID)));
    for I:=0 to ItemsList.Count-1 do begin
      SegmentID:=TSegmentItemOfTTileServerVisualizationCash(ItemsList[I]^).Params.ID;
      Integer(Pointer(@LocalSegments[I*SizeOf(SegmentID)])^):=SegmentID;
      end;
    Result:=false;
    end
   else Result:=true;
  end
 else begin
  SetLength(LocalSegments,0);
  Result:=false;
  end;
finally
ItemsList.Destroy;
end;
finally
Lock.EndRead;
end;
end;
end;

function TTTileServerVisualizationCash.Item_Level__GetVisibleSegmentsLocal(const ptrItem: pointer; const pTileProviderID: integer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const flSegmentsInMemory: boolean; const flLoadFromContextFiles: boolean; const ptrCancelFlag: pointer; out ItemsTable: pointer; out ItemsTableSize: integer; out ExceptSegments: TByteArray; const ptrHasEmptySegmentFlag: pointer = nil): boolean;
var
  ItemsList: TList;
  Segment: pointer;
  SegmentID: integer;
  I: integer;
  SizeX,SizeY: integer;
  ptr: pointer;
  LevelFolder: string;
  SegmentFileName: string;
  flGenerateTexture: boolean;
begin
ItemsTable:=nil;
try
SizeX:=(XIndexMax-XIndexMin+1);
SizeY:=(YIndexMax-YIndexMin+1);
with TItemTTileServerVisualizationCash(ptrItem^) do
with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
//. prepare cached segments
ItemsList:=TList.Create;
try
ItemsList.Capacity:=(SizeX*SizeY);
Segment:=Segments;
while (Segment <> nil) AND (TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.YIndex < YIndexMin) do Segment:=TSegmentItemOfTTileServerVisualizationCash(Segment^).ptrNext;
while (Segment <> nil) AND (TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.YIndex <= YIndexMax) do begin
  if (
      ((XIndexMin <= TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.XIndex) AND (TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.XIndex <= XIndexMax)) AND
      (NOT flSegmentsInMemory OR (NOT Segment_DATAIsNull(Segment)))
  )
   then ItemsList.Add(Segment);
  Segment:=TSegmentItemOfTTileServerVisualizationCash(Segment^).ptrNext;
  end;
//.
if (ItemsList.Count > 0)
 then begin
  //. prepare items table
  ItemsTableSize:=ItemsList.Count*SizeOf(Pointer);
  GetMem(ItemsTable,ItemsTableSize);
  ptr:=ItemsTable;
  for I:=0 to ItemsList.Count-1 do begin
    Pointer(ptr^):=ItemsList[I];
    Inc(DWord(ptr),SizeOf(Pointer));
    end;
  {validate cached items}
  if ((NOT flSegmentsInMemory) AND flLoadFromContextFiles)
   then begin
    LevelFolder:=Item_Level__GetContextFolder(idObj,pTileProviderID,Params.ID);
    for I:=0 to ItemsList.Count-1 do with TSegmentItemOfTTileServerVisualizationCash(ItemsList[I]^).Params do begin
      Segment_Lock(ItemsList[I]);
      try
      if (_DATA = nil)
       then begin
        SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
        _DATA:=TMemoryStream.Create();
        if (FileExists(SegmentFileName)) then _DATA.LoadFromFile(SegmentFileName);
        //.
        flGenerateTexture:=true;
        end
       else flGenerateTexture:=false;
      finally
      Segment_Unlock(ItemsList[I]);
      end;
      //.
      if (TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.flEnabled AND flGenerateTexture) then TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentTexture(ItemsList[I]);
      //.
      if (ptrCancelFlag <> nil)
       then begin
        Sleep(0); //. exit from the current thread to alow the cancel flag to be set
        if (Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
        end;
      end;
    end;
  {check empty segments}
  if (ptrHasEmptySegmentFlag <> nil)
   then begin
    Boolean(ptrHasEmptySegmentFlag^):=false;
    for I:=0 to ItemsList.Count-1 do
      if (Segment_DATAIsEmpty(ItemsList[I]))
       then begin
        Boolean(ptrHasEmptySegmentFlag^):=true;
        Break; //. >
        end;
    end;
  //.
  if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
  {process items as accessed}
  AccessedSegmentsRevising.AddByList(ItemsList,ptrLevel,idObj);
  //.
  if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
  //.
  if (ItemsList.Count <> (SizeX*SizeY))
   then begin
    SetLength(ExceptSegments,(ItemsList.Count*SizeOf(SegmentID)));
    for I:=0 to ItemsList.Count-1 do begin
      SegmentID:=TSegmentItemOfTTileServerVisualizationCash(ItemsList[I]^).Params.ID;
      Integer(Pointer(@ExceptSegments[I*SizeOf(SegmentID)])^):=SegmentID;
      end;
    Result:=false;
    end
   else Result:=true;
  end
 else begin
  SetLength(ExceptSegments,0);
  Result:=false;
  end;
finally
ItemsList.Destroy;
end;
end;
except
  if (ItemsTable <> nil) then FreeMem(ItemsTable,ItemsTableSize);
  Raise; //. =>
  end;
end;

function TTTileServerVisualizationCash.Item_Level__RestoreSegmentsLocal(const ptrItem: pointer; const pTileProviderID: integer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ptrCancelFlag: pointer; out ItemsList: TList; var ExceptSegments: TByteArray): boolean;

  function ExceptSegments_SegmentFound(ExceptSegmentsPtr: pointer; ExceptSegmentsSize: integer; SegmentID: integer): boolean;
  begin
  asm
        PUSH EAX
        PUSH ECX
        PUSH EDI
        MOV EAX,SegmentID
        MOV EDI,ExceptSegmentsPtr
        CMP EDI,0 {nil}
        JE @M1
        MOV ECX,ExceptSegmentsSize
        JECXZ @M1
        CLD
        REPNE SCASD
        JNE @M1
          MOV Result,true
          JMP @M2
  @M1:  MOV Result,false
  @M2:  POP EDI
        POP ECX
        POP EAX
  end;
  end;

  function RestoreSegment(const idObj: integer; const LevelFolder: string; const X,Y: integer; out SegmentDATA: TMemoryStream): boolean;
  var
    SegmentFileName: string;
  begin
  Result:=false;
  SegmentDATA:=nil;
  SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(X)+'Y'+IntToStr(Y)+'.jpg';
  try
  if (NOT FileExists(SegmentFileName)) then Exit; //. ->
  SegmentDATA:=TMemoryStream.Create;
  SegmentDATA.LoadFromFile(SegmentFileName);
  Result:=true;
  except
    FreeAndNil(SegmentDATA);
    end;
  end;

var
  SizeX,SizeY: integer;
  LevelFolder: string;
  ExceptSegmentsPtr: pointer;
  ExceptSegmentsSize: integer;
  X,Y: integer;
  SegmentID: integer;
  RestoredSegmentDATA: TMemoryStream;
  RestoredSegment: pointer;
  ExistedSegment: pointer;
  Ofs: integer;
  I: integer;
begin
Result:=false;
ItemsList:=nil;
try
with TItemTTileServerVisualizationCash(ptrItem^) do begin
//.
with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
Lock.BeginRead;
try
LevelFolder:=Item_Level__GetContextFolder(idObj,pTileProviderID,Params.ID);
//.
SizeX:=(XIndexMax-XIndexMin+1);
SizeY:=(YIndexMax-YIndexMin+1);
//.
ExceptSegmentsPtr:=@ExceptSegments[0];
ExceptSegmentsSize:=(Length(ExceptSegments) DIV SizeOf(SegmentID));
//.
ItemsList:=TList.Create;
ItemsList.Capacity:=(SizeX*SizeY-ExceptSegmentsSize);
for Y:=YIndexMin to YIndexMax do
  for X:=XIndexMin to XIndexMax do begin
    SegmentID:=SegmentPositionHashCode(X,Y);
    if (NOT ExceptSegments_SegmentFound(ExceptSegmentsPtr,ExceptSegmentsSize,SegmentID))
     then begin
      if (RestoreSegment(idObj, LevelFolder, X,Y, RestoredSegmentDATA))
       then begin
        //. create and insert restored item
        GetMem(RestoredSegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
        with TSegmentItemOfTTileServerVisualizationCash(RestoredSegment^) do begin
        ptrNext:=nil;
        Lock:=TLevelItemOfTTileServerVisualizationCash(ptrLevel^).SegmentLock;
        with Params do begin
        id:=SegmentID;
        XIndex:=X;
        YIndex:=Y;
        _DATA:=RestoredSegmentDATA;
        end;
        _idOGLTexture:=0;
        end;
        //.
        Lock.BeginWrite;
        try
        if (TTileServerVisualizationCashItemLevelSegments_Insert(Segments,RestoredSegment, @ExistedSegment))
         then begin
          AccessedSegmentsRevising.Add(RestoredSegment,ptrLevel,idObj); //. process segment as accessed
          ItemsList.Add(RestoredSegment);
          end
         else begin
          ItemsList.Add(ExistedSegment);
          //.
          FreeAndNil(TSegmentItemOfTTileServerVisualizationCash(RestoredSegment^).Params._DATA);
          FreeMem(RestoredSegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
          end;
        finally
        Lock.EndWrite;
        end;
        //.
        if (ptrCancelFlag <> nil)
         then begin
          Sleep(0); //. exit from the current thread to alow the cancel flag to be set
          if (Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
          end;
        end;
      end;
    end;
if (ItemsList.Count > 0)
 then begin
  if ((ExceptSegmentsSize+ItemsList.Count) <> (SizeX*SizeY))
   then begin
    Ofs:=Length(ExceptSegments);
    SetLength(ExceptSegments,Length(ExceptSegments)+(ItemsList.Count*SizeOf(SegmentID)));
    for I:=0 to ItemsList.Count-1 do begin
      SegmentID:=TSegmentItemOfTTileServerVisualizationCash(ItemsList[I]^).Params.ID;
      Integer(Pointer(@ExceptSegments[Ofs+I*SizeOf(SegmentID)])^):=SegmentID;
      end;
    end
   else Result:=true;
  //. update OpenGL segments textures
  if (TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.flEnabled)
   then TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentItemsTextures(ItemsList);
  end;
finally
Lock.EndRead;
end;
end;
end;
except
  if (ItemsList <> nil) then FreeAndNil(ItemsList);
  Raise; //. =>
  end;
end;

function Bitmap_DrawToQuarterBitmap(const SrcBMP: TBitmap; const DestBMP: TBitmap): boolean;
var
  SrcDIB,DestDIB: TDIBSection;
  ptrSrcPixel,ptrDestPixel: pointer;
  XSize,YSize: integer;
  SrcRowSize,SrcRowWSize: integer;
begin
Result:=false;
if ((GetObject(SrcBMP.Handle,SizeOf(SrcDIB),@SrcDIB) = 0) OR (GetObject(DestBMP.Handle,SizeOf(DestDIB),@DestDIB) = 0)) then Exit; //. ->
XSize:=DestBMP.Width;
YSize:=DestBMP.Height;
SrcRowSize:=SrcBMP.Width*3;
SrcRowWSize:=2*SrcRowSize;
ptrSrcPixel:=System.PByte(SrcDIB.dsBm.bmBits);
ptrDestPixel:=System.PByte(DestDIB.dsBm.bmBits);
asm
      PUSH EAX
      PUSH EBX
      PUSH ECX
      PUSH EDX
      PUSH ESI
      PUSH EDI
      MOV ESI,ptrSrcPixel
      MOV EDI,ptrDestPixel
      MOV ECX,YSize
      CLD
  @M0:  PUSH ECX
        PUSH ESI
        MOV ECX,XSize
    @M1:  PUSH ECX
          XOR AX,AX
          XOR BX,BX
          XOR CX,CX
          XOR DX,DX
          //.
          LODSB //. get "B"
          MOV BX,AX
          LODSB //. get "G"
          MOV CX,AX
          LODSB //. get "R"
          MOV DX,AX
          //.
          LODSB //. get "B"
          ADD BX,AX
          LODSB //. get "G"
          ADD CX,AX
          LODSB //. get "R"
          ADD DX,AX
          //.
          PUSH ESI
          ADD ESI,SrcRowSize
          SUB ESI,6
          //.
          LODSB //. get "B"
          ADD BX,AX
          LODSB //. get "G"
          ADD CX,AX
          LODSB //. get "R"
          ADD DX,AX
          //.
          LODSB //. get "B"
          ADD BX,AX
          LODSB //. get "G"
          ADD CX,AX
          LODSB //. get "R"
          ADD DX,AX
          //.
          SHR BX,2
          SHR CX,2
          SHR DX,2
          //.
          MOV AL,BL
          STOSB
          //.
          MOV AL,CL
          STOSB
          //.
          MOV AL,DL
          STOSB
          //.
          POP ESI
          POP ECX
          LOOP @M1
        POP ESI
        POP ECX
        ADD ESI,SrcRowWSize
        LOOP @M0
      POP EDI
      POP ESI
      POP EDX
      POP ECX
      POP EBX
      POP EAX
end;
Result:=true;
end;

function TTTileServerVisualizationCash.Item_Level__GenerateSegmentsLocal(const ptrItem: pointer; const pTileProviderID: integer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const MaxDepth: integer; const ptrCancelFlag: pointer; out ItemsList: TList; var ExceptSegments: TByteArray): boolean;

  function ExceptSegments_SegmentFound(ExceptSegmentsPtr: pointer; ExceptSegmentsSize: integer; SegmentID: integer): boolean;
  begin
  asm
        PUSH EAX
        PUSH ECX
        PUSH EDI
        MOV EAX,SegmentID
        MOV EDI,ExceptSegmentsPtr
        CMP EDI,0 {nil}
        JE @M1
        MOV ECX,ExceptSegmentsSize
        JECXZ @M1
        CLD
        REPNE SCASD
        JNE @M1
          MOV Result,true
          JMP @M2
  @M1:  MOV Result,false
  @M2:  POP EDI
        POP ECX
        POP EAX
  end;
  end;

  function Level_GenerateSegment(const ptrItem: pointer; const ptrLevel: pointer; const X,Y: integer; const Depth,MaxDepth: integer; const ResultBMP,SegmentBMP: TBitmap; out SegmentDATA: TMemoryStream): boolean;

    function ProcessSegment(const ptrItem: pointer; const ptrLevel: pointer; const X,Y: integer; const Depth,MaxDepth: integer; const ResultBMP,SegmentBMP: TBitmap; out SegmentDATA: TMemoryStream): boolean;
    var
      Segment: pointer;
      flSegmentFound: boolean;
      LevelFolder,SegmentFileName: string;
      NewSegment: pointer;
    begin
    Result:=false;
    //.
    SegmentDATA:=nil;
    try
    with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
    Lock.BeginRead;
    try
    LevelFolder:=Item_Level__GetContextFolder(TItemTTileServerVisualizationCash(ptrItem^).idObj,pTileProviderID,Params.ID);
    flSegmentFound:=false;
    Segment:=Segments;
    while (Segment <> nil) AND (TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.YIndex <> Y) do Segment:=TSegmentItemOfTTileServerVisualizationCash(Segment^).ptrNext;
    while (Segment <> nil) AND (TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.YIndex = Y) do begin
      if (TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.XIndex = X)
       then begin
        flSegmentFound:=true;
        Break; //. >
        end;
      //. next
      Segment:=TSegmentItemOfTTileServerVisualizationCash(Segment^).ptrNext;
      end;
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //.
    if (flSegmentFound)
     then begin
      with TSegmentItemOfTTileServerVisualizationCash(Segment^).Params do begin
      SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
      Segment_Lock(Segment);
      try
      if (_DATA <> nil)
       then begin
        if (_DATA.Size = 0) then Exit; //. ->
        _DATA.Position:=0;
        SegmentDATA:=TMemoryStream.Create;
        SegmentDATA.LoadFromStream(_DATA);
        end
       else begin
        if (NOT FileExists(SegmentFileName)) then Exit; //. ->
        SegmentDATA:=TMemoryStream.Create;
        SegmentDATA.LoadFromFile(SegmentFileName);
        end;
      finally
      Segment_Unlock(Segment);
      end;
      end;
      Result:=true;
      Exit; //. ->
      end;
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //. try to generate segment
    if (Level_GenerateSegment(ptrItem, ptrLevel, X,Y, Depth+1,MaxDepth, ResultBMP,SegmentBMP,  SegmentDATA))
     then begin
      Result:=true;
      GetMem(NewSegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
      with TSegmentItemOfTTileServerVisualizationCash(NewSegment^) do begin
      Lock:=TLevelItemOfTTileServerVisualizationCash(ptrLevel^).SegmentLock;
      ptrNext:=nil;
      with Params do begin
      id:=SegmentPositionHashCode(X,Y);
      XIndex:=X;
      YIndex:=Y;
      _DATA:=TMemoryStream.Create;
      if (SegmentDATA.Size > 0)
       then begin
        SegmentDATA.Position:=0;
        SegmentDATA.SaveToStream(_DATA);
        end;
      end;
      _idOGLTexture:=0;
      end;
      //.
      TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.BeginWrite;
      try
      if (TTileServerVisualizationCashItemLevelSegments_Insert(Segments,NewSegment))
       then AccessedSegmentsRevising.Add(NewSegment,ptrLevel,TItemTTileServerVisualizationCash(ptrItem^).idObj) //. process segment as accessed
       else begin
        FreeAndNil(TSegmentItemOfTTileServerVisualizationCash(NewSegment^).Params._DATA);
        FreeMem(NewSegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
        NewSegment:=nil;
        end;
      finally
      TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.EndWrite;
      end;
      //.
      if (NewSegment <> nil)
       then with TSegmentItemOfTTileServerVisualizationCash(NewSegment^).Params do begin
        ForceDirectories(LevelFolder);
        Segment_Lock(NewSegment);
        try
        if (_DATA <> nil)
         then begin
          SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(X)+'Y'+IntToStr(Y)+'.jpg';
          if ((_DATA.Size > 0) AND (NOT FileExists(SegmentFileName)))
           then begin
            _DATA.Position:=0;
            _DATA.SaveToFile(SegmentFileName);
            end;
          Segment_SetDATA(NewSegment,nil);
          end;
        finally
        Segment_Unlock(NewSegment);
        end;
        end;
      //.
      if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
      end;
    finally
    Lock.EndRead;
    end;
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    end;
    except
      FreeAndNil(SegmentDATA);
      Raise; //. =>
      end;
    end;

  var
    ptrDownLevel: pointer;
    flAllSegmentsLocal: boolean;
    RSL: TList;
    LocalSegments: TByteArray;
    S00,S10,S01,S11: TMemoryStream;
    OfsX,OfsY: integer;
    SegmentJI: TJpegImage;
  begin
  Result:=false;
  //.
  if (NOT ((MaxDepth = -1) OR (Depth < MaxDepth))) then Exit; //. ->
  SegmentDATA:=nil;
  try
  with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
  if (ptrNext = nil) then Exit; //. =>
  ptrDownLevel:=ptrNext;
  //. check levels validity
  Lock.BeginRead;
  try
  TLevelItemOfTTileServerVisualizationCash(ptrDownLevel^).Lock.BeginRead;
  try
  if ((2*Params.DivX <> TLevelItemOfTTileServerVisualizationCash(ptrDownLevel^).Params.DivX) OR (2*Params.DivY <> TLevelItemOfTTileServerVisualizationCash(ptrDownLevel^).Params.DivY)) then Exit; //. ->
  //.
  flAllSegmentsLocal:=Item_Level__GetSegmentsLocal(ptrDownLevel, 2*X,2*X+1,2*Y,2*Y+1, LocalSegments);
  //. try to restore down level segments from the saved context
  if (NOT flAllSegmentsLocal)
   then begin
    TSystemTTileServerVisualization(TypeSystem).Cash.Item_Level__RestoreSegmentsLocal(ptrItem, pTileProviderID, ptrDownLevel, 2*X,2*X+1,2*Y,2*Y+1, ptrCancelFlag,  RSL, LocalSegments);
    RSL.Free;
    end;
  //.
  S00:=nil;
  S10:=nil;
  S01:=nil;
  S11:=nil;
  try
  Result:=(
    ProcessSegment(ptrItem, ptrDownLevel, 2*X,   2*Y,   Depth,MaxDepth, ResultBMP,SegmentBMP,  S00)
      AND
    ProcessSegment(ptrItem, ptrDownLevel, 2*X+1, 2*Y,   Depth,MaxDepth, ResultBMP,SegmentBMP,  S10)
      AND
    ProcessSegment(ptrItem, ptrDownLevel, 2*X,   2*Y+1, Depth,MaxDepth, ResultBMP,SegmentBMP,  S01)
      AND
    ProcessSegment(ptrItem, ptrDownLevel, 2*X+1, 2*Y+1, Depth,MaxDepth, ResultBMP,SegmentBMP,  S11)
  );
  //.
  if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
  //.
  if (Result)
   then begin
    Result:=false;
    //.
    ResultBMP.Width:=Round(TLevelItemOfTTileServerVisualizationCash(ptrDownLevel^).Params.SegmentWidth*2);
    ResultBMP.Height:=Round(TLevelItemOfTTileServerVisualizationCash(ptrDownLevel^).Params.SegmentHeight*2);
    //. (0;0)
    if (NOT GetBitmapFromJPEGStream(S00, SegmentBMP)) then Exit; //. ->
    BitBlt(ResultBMP.Canvas.Handle, 0,0, SegmentBMP.Width,SegmentBMP.Height,  SegmentBMP.Canvas.Handle, 0, 0, SRCCOPY);
    OfsX:=SegmentBMP.Width; OfsY:=SegmentBMP.Height;
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //. (1;0)
    if (NOT GetBitmapFromJPEGStream(S10, SegmentBMP)) then Exit; //. ->
    BitBlt(ResultBMP.Canvas.Handle, OfsX,0, SegmentBMP.Width,SegmentBMP.Height,  SegmentBMP.Canvas.Handle, 0, 0, SRCCOPY);
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //. (1;1)
    if (NOT GetBitmapFromJPEGStream(S11, SegmentBMP)) then Exit; //. ->
    BitBlt(ResultBMP.Canvas.Handle, OfsX,OfsY, SegmentBMP.Width,SegmentBMP.Height,  SegmentBMP.Canvas.Handle, 0, 0, SRCCOPY);
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //. (0;1)
    if (NOT GetBitmapFromJPEGStream(S01, SegmentBMP)) then Exit; //. ->
    BitBlt(ResultBMP.Canvas.Handle, 0,OfsY, SegmentBMP.Width,SegmentBMP.Height,  SegmentBMP.Canvas.Handle, 0, 0, SRCCOPY);
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //. save result
    SegmentBMP.Width:=Round(Params.SegmentWidth);
    SegmentBMP.Height:=Round(Params.SegmentHeight);
    //.
    if (NOT Bitmap_DrawToQuarterBitmap(ResultBMP, SegmentBMP)) then Exit; //. ->
    SegmentJI:=TJpegImage.Create;
    try
    SegmentJI.Assign(SegmentBMP);
    //. save segment to stream
    SegmentDATA:=TMemoryStream.Create;
    SegmentJI.SaveToStream(SegmentDATA);         
    finally
    SegmentJI.Destroy;
    end;
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //.
    Result:=true;
    end;
  finally
  S00.Free;
  S10.Free;
  S01.Free;
  S11.Free;
  end;
  finally
  TLevelItemOfTTileServerVisualizationCash(ptrDownLevel^).Lock.EndRead;
  end;
  finally
  Lock.EndRead;
  end;
  end;
  except
    FreeAndNil(SegmentDATA);
    Raise; //. =>
    end;
  end;

var
  StartupInput: TGDIPlusStartupInput;
  ResultBMP,SegmentBMP: TBitmap;
  LevelFolder,SegmentFileName: string;
  SizeX,SizeY: integer;
  ExceptSegmentsPtr: pointer;
  ExceptSegmentsSize: integer;
  X,Y: integer;
  SegmentID: integer;
  GeneratedSegmentDATA: TMemoryStream;
  GeneratedSegment: pointer;
  ExistedSegment: pointer;
  ptr: pointer;
  I: integer;
  Ofs: integer;
begin
Result:=false;
//.
ItemsList:=nil;
try
with TItemTTileServerVisualizationCash(ptrItem^) do begin
//.
with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
Lock.BeginRead;
try
if (ptrNext = nil) then Exit; //. =>
//. Initialize GDI+
StartupInput.DebugEventCallback := nil;
StartupInput.SuppressBackgroundThread:=False;
StartupInput.SuppressExternalCodecs:=False;
StartupInput.GdiplusVersion:=1;
GdiplusStartup(gdiplusToken, @StartupInput, nil);
try
ResultBMP:=TBitmap.Create;
ResultBMP.Canvas.Lock;
try
ResultBMP.HandleType:=bmDIB;
ResultBMP.PixelFormat:=pf24bit;
//.
SegmentBMP:=TBitmap.Create;
SegmentBMP.Canvas.Lock;
try
SegmentBMP.HandleType:=bmDIB;
SegmentBMP.PixelFormat:=pf24bit;
//.
LevelFolder:=Item_Level__GetContextFolder(TItemTTileServerVisualizationCash(ptrItem^).idObj,pTileProviderID,Params.ID);
//.
SizeX:=(XIndexMax-XIndexMin+1);
SizeY:=(YIndexMax-YIndexMin+1);
//.
ExceptSegmentsPtr:=@ExceptSegments[0];
ExceptSegmentsSize:=(Length(ExceptSegments) DIV SizeOf(SegmentID));
//.
ItemsList:=TList.Create;
ItemsList.Capacity:=(SizeX*SizeY-ExceptSegmentsSize);
for Y:=YIndexMin to YIndexMax do
  for X:=XIndexMin to XIndexMax do begin
    SegmentID:=SegmentPositionHashCode(X,Y);
    if (NOT ExceptSegments_SegmentFound(ExceptSegmentsPtr,ExceptSegmentsSize,SegmentID))
     then begin
      if (Level_GenerateSegment(ptrItem, ptrLevel, X,Y, 0,MaxDepth, ResultBMP,SegmentBMP,  GeneratedSegmentDATA))
       then begin
        //. create and insert generated item
        GetMem(GeneratedSegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
        with TSegmentItemOfTTileServerVisualizationCash(GeneratedSegment^) do begin
        ptrNext:=nil;
        Lock:=TLevelItemOfTTileServerVisualizationCash(ptrLevel^).SegmentLock;
        with Params do begin
        id:=SegmentID;
        XIndex:=X;
        YIndex:=Y;
        _DATA:=GeneratedSegmentDATA;
        end;
        _idOGLTexture:=0;
        end;                     
        //.
        TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.BeginWrite;
        try
        if (TTileServerVisualizationCashItemLevelSegments_Insert(Segments,GeneratedSegment, @ExistedSegment))
         then begin
          AccessedSegmentsRevising.Add(GeneratedSegment,ptrLevel,idObj); //. process segment as accessed
          ItemsList.Add(GeneratedSegment);
          end
         else begin
          ItemsList.Add(ExistedSegment);
          //.
          FreeAndNil(TSegmentItemOfTTileServerVisualizationCash(GeneratedSegment^).Params._DATA);
          FreeMem(GeneratedSegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
          GeneratedSegment:=nil;
          end;
        finally
        TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.EndWrite;
        end;
        //.
        if (GeneratedSegment <> nil)
         then with TSegmentItemOfTTileServerVisualizationCash(GeneratedSegment^).Params do begin
          ForceDirectories(LevelFolder);
          Segment_Lock(GeneratedSegment);
          try
          if ((_DATA <> nil) AND (_DATA.Size > 0))
           then begin
            SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(X)+'Y'+IntToStr(Y)+'.jpg';
            if (NOT FileExists(SegmentFileName))
             then begin
              _DATA.Position:=0;
              _DATA.SaveToFile(SegmentFileName);
              end;
            end;
          finally
          Segment_Unlock(GeneratedSegment);
          end;
          end;
        //.
        if (ptrCancelFlag <> nil)
         then begin
          Sleep(0); //. exit from the current thread to alow the cancel flag to be set
          if (Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
          end;
        end;
      end;
    end;
if (ItemsList.Count > 0)
 then begin
  if ((ExceptSegmentsSize+ItemsList.Count) <> (SizeX*SizeY))
   then begin
    Ofs:=Length(ExceptSegments);
    SetLength(ExceptSegments,Length(ExceptSegments)+(ItemsList.Count*SizeOf(SegmentID)));
    for I:=0 to ItemsList.Count-1 do begin
      SegmentID:=TSegmentItemOfTTileServerVisualizationCash(ItemsList[I]^).Params.ID;
      Integer(Pointer(@ExceptSegments[Ofs+I*SizeOf(SegmentID)])^):=SegmentID;
      end;
    end
   else Result:=true;
  //. update OpenGL segments textures
  if (TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.flEnabled)
   then TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentItemsTextures(ItemsList);
  end;
finally
SegmentBMP.Canvas.Unlock;
SegmentBMP.Destroy;
end;
finally
ResultBMP.Canvas.Unlock;
ResultBMP.Destroy;
end;
finally
GdiplusShutdown(gdiplusToken);
end;
finally
Lock.EndRead;
end;
end;
end;
except
  if (ItemsList <> nil) then FreeAndNil(ItemsList);
  Raise; //. =>
  end;
end;

function TTTileServerVisualizationCash.Item_Level__DegenerateSegmentsLocal(const ptrItem: pointer; const pTileProviderID: integer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ptrCancelFlag: pointer; out ItemsList: TList): boolean;

  function Item_ProcessLevel(const ptrItem: pointer; const DistLevel: pointer; const UpLevels: TList; const UpLevel: integer; XIndexMin,XIndexMax: integer; YIndexMin,YIndexMax: integer; out ItemsList: TList): boolean;

    function DrawCanvasScaledUsingGDIPlus(const DistCanvas: TCanvas; const DistX,DistY,DistWidth,DistHeight: Single; const BMP: TBitmap; const SrcX,SrcY,SrcWidth,SrcHeight: Single): GDIPAPI.TStatus;
    var
      Rect: TGPRectF;
      GDIPlusGraphics: TGPGraphics;
      GDIPlusBitmap: TGPBitmap;
    begin
    with Rect do begin
    X:=DistX;
    Y:=DistY;
    Width:=DistWidth;
    Height:=DistHeight;
    end;
    GDIPlusGraphics:=TGPGraphics.Create(DistCanvas.Handle);
    try
    GDIPlusGraphics.SetInterpolationMode(InterpolationModeBilinear);
    GDIPlusBitmap:=TGPBitmap.Create(BMP.Handle,BMP.Palette);
    try
    Result:=GDIPlusGraphics.DrawImage(GDIPlusBitmap, Rect, SrcX,SrcY,SrcWidth,SrcHeight, UnitPixel);
    finally
    GDIPlusBitmap.Destroy;
    end;
    finally
    GDIPlusGraphics.Destroy;
    end;
    end;

  var
    DistLevelFolder: string;
    SrcLevel: pointer;
    SrcLevelFolder: string;
    EmptySegments: TList;
    Segment: pointer;
    SegmentFileName: string;
    flAllItemsExists: boolean;
    ItemsTable: pointer;
    ItemsTableSize: integer;
    IL,RSL: TList;
    ExceptSegments: TByteArray;
    BA: TByteArray;
    L: TList;
    I,J: integer;
    SX,SY: integer;
    mulX,mulY: integer;
    DegenerateSegmentBMP: TBitmap;
    DegeneratedSegmentBMP: TBitmap;
    DegeneratedSegmentJI: TJpegImage;
    flDegenerateSegmentProcessed: boolean;
    DS: TMemoryStream;
  begin
  Result:=false;
  //.
  if (UpLevel < 0) then Exit; //. ->
  //.
  SrcLevel:=UpLevels[UpLevel];
  if (NOT ((2*TLevelItemOfTTileServerVisualizationCash(SrcLevel^).Params.DivX = TLevelItemOfTTileServerVisualizationCash(DistLevel^).Params.DivX) AND (2*TLevelItemOfTTileServerVisualizationCash(SrcLevel^).Params.DivY = TLevelItemOfTTileServerVisualizationCash(DistLevel^).Params.DivY))) then Exit; //. ->
  SrcLevelFolder:=Item_Level__GetContextFolder(TItemTTileServerVisualizationCash(ptrItem^).idObj,pTileProviderID,TLevelItemOfTTileServerVisualizationCash(SrcLevel^).Params.ID);
  //.
  ItemsList:=nil;
  try
  DegenerateSegmentBMP:=TBitmap.Create;
  DegenerateSegmentBMP.Canvas.Lock;
  try
  DegenerateSegmentBMP.HandleType:=bmDIB;
  DegenerateSegmentBMP.PixelFormat:=pf24bit;
  with TLevelItemOfTTileServerVisualizationCash(DistLevel^) do begin
  DegeneratedSegmentBMP:=TBitmap.Create;
  DegeneratedSegmentBMP.Canvas.Lock;
  try
  DegeneratedSegmentBMP.HandleType:=bmDIB;
  DegeneratedSegmentBMP.PixelFormat:=pf24bit;
  DegeneratedSegmentBMP.Width:=Round(Params.SegmentWidth);
  DegeneratedSegmentBMP.Height:=Round(Params.SegmentHeight);
  //.
  Lock.BeginRead;
  try
  DistLevelFolder:=Item_Level__GetContextFolder(TItemTTileServerVisualizationCash(ptrItem^).idObj,pTileProviderID,Params.ID);
  //.
  EmptySegments:=TList.Create;
  try
  EmptySegments.Capacity:=(XIndexMax-XIndexMin+1)*(YIndexMax-YIndexMin+1);
  Segment:=Segments;
  while (Segment <> nil) AND (TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.YIndex < YIndexMin) do Segment:=TSegmentItemOfTTileServerVisualizationCash(Segment^).ptrNext;
  while (Segment <> nil) AND (TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.YIndex <= YIndexMax) do begin
    if ((XIndexMin <= TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.XIndex) AND (TSegmentItemOfTTileServerVisualizationCash(Segment^).Params.XIndex <= XIndexMax))
     then with TSegmentItemOfTTileServerVisualizationCash(Segment^).Params do begin
      Segment_Lock(Segment);
      try
      if (_DATA = nil)
       then begin
        SegmentFileName:=DistLevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
        _DATA:=TMemoryStream.Create();
        if (FileExists(SegmentFileName)) then _DATA.LoadFromFile(SegmentFileName);
        end;
      //.
      if (_DATA.Size = 0) then EmptySegments.Add(Segment);
      finally
      Segment_Unlock(Segment);
      end;
      //.
      if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
      end;
    Segment:=TSegmentItemOfTTileServerVisualizationCash(Segment^).ptrNext;
    end;
  //. processing empty segments
  if (EmptySegments.Count > 0)
   then begin
    XIndexMin:=(XIndexMin SHR 1); XIndexMax:=(XIndexMax SHR 1);
    YIndexMin:=(YIndexMin SHR 1); YIndexMax:=(YIndexMax SHR 1);
    //.
    IL:=TList.Create;
    try
    IL.Capacity:=(XIndexMax-XIndexMin+1)*(YIndexMax-YIndexMin+1);
    //.
    TLevelItemOfTTileServerVisualizationCash(SrcLevel^).Lock.BeginRead;
    try
    flAllItemsExists:=Item_Level__GetVisibleSegmentsLocal(ptrItem, pTileProviderID, SrcLevel, XIndexMin,XIndexMax,YIndexMin,YIndexMax, false,true, ptrCancelFlag,  ItemsTable,ItemsTableSize, ExceptSegments);
    try
    if (NOT flAllItemsExists)
     then begin
      //. try to restore segments from saved context
      flAllItemsExists:=TSystemTTileServerVisualization(TypeSystem).Cash.Item_Level__RestoreSegmentsLocal(ptrItem, pTileProviderID, SrcLevel, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ptrCancelFlag,  RSL, ExceptSegments);
      if (RSL <> nil)
       then
        try
        for I:=0 to RSL.Count-1 do IL.Add(RSL[I]);
        finally
        RSL.Destroy;
        end;
      //. get segments from server
      if (NOT flAllItemsExists AND NOT Space.flOffline)
       then begin
        with TTileServerVisualizationFunctionality(TComponentFunctionality_Create(idTTileServerVisualization,TItemTTileServerVisualizationCash(ptrItem^).idObj)) do
        try
        Level_GetSegments(pTileProviderID, TLevelItemOfTTileServerVisualizationCash(SrcLevel^).Params.id, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ExceptSegments, BA);
        //.
        TTileServerVisualizationCashItemLevel_PrepareSegmentsFromByteArray(TSystemTTileServerVisualization(TypeSystem), TItemTTileServerVisualizationCash(ptrItem^).idObj, pTileProviderID, SrcLevel,BA, IL, true);
        finally
        Release;
        end;
        end;
      end;
    //.
    if (ItemsTable <> nil) then for I:=0 to (ItemsTableSize DIV SizeOf(Pointer))-1 do IL.Add(Pointer(Pointer(Integer(ItemsTable)+I*SizeOf(Pointer))^));
    //.
    finally
    if (ItemsTable <> nil) then FreeMem(ItemsTable,ItemsTableSize);
    end;
    //.
    if (Item_ProcessLevel(ptrItem, SrcLevel, UpLevels,UpLevel-1, XIndexMin,XIndexMax,YIndexMin,YIndexMax, L)) then L.Destroy();
    //.
    ForceDirectories(DistLevelFolder);
    for I:=0 to EmptySegments.Count-1 do with TSegmentItemOfTTileServerVisualizationCash(EmptySegments[I]^).Params do begin
      SX:=(XIndex SHR 1); SY:=(YIndex SHR 1);
      flDegenerateSegmentProcessed:=false;
      for J:=0 to IL.Count-1 do with TSegmentItemOfTTileServerVisualizationCash(IL[J]^).Params do
        if ((XIndex = SX) AND (YIndex = SY))
         then begin
          Segment_Lock(IL[J]);
          try
          if (_DATA = nil)
           then begin
            SegmentFileName:=SrcLevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
            _DATA:=TMemoryStream.Create();
            if (FileExists(SegmentFileName)) then _DATA.LoadFromFile(SegmentFileName);
            end;
          //.
          if (_DATA.Size > 0) then flDegenerateSegmentProcessed:=GetBitmapFromJPEGStream(_DATA, DegenerateSegmentBMP);
          finally
          Segment_Unlock(IL[J]);
          end;
          //.
          Break; //. >
          end;
      if (flDegenerateSegmentProcessed)
       then begin
        //. degenerating
        mulX:=(XIndex MOD 2); mulY:=(YIndex MOD 2);
        //.
        DrawCanvasScaledUsingGDIPlus(DegeneratedSegmentBMP.Canvas, 0,0,DegeneratedSegmentBMP.Width+1,DegeneratedSegmentBMP.Height+1, DegenerateSegmentBMP, (mulX*(DegenerateSegmentBMP.Width/2)),(mulY*(DegenerateSegmentBMP.Height/2)),(DegenerateSegmentBMP.Width/2),(DegenerateSegmentBMP.Height/2));
        //.
        DegeneratedSegmentJI:=TJpegImage.Create;
        try
        DegeneratedSegmentJI.Assign(DegeneratedSegmentBMP);
        //. saving new DATA
        DS:=TMemoryStream.Create;
        DegeneratedSegmentJI.SaveToStream(DS);
        if (TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.flEnabled AND (Segment_idOGLTexture(EmptySegments[I]) <> 0)) then TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.DeleteSegmentTexture(EmptySegments[I]);
        Segment_SetDATA(EmptySegments[I],DS);
        finally
        DegeneratedSegmentJI.Destroy;
        end;
        //.
        Segment_Lock(EmptySegments[I]);
        try
        if ((_DATA <> nil) AND (_DATA.Size > 0))
         then begin
          SegmentFileName:=DistLevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
          if (NOT FileExists(SegmentFileName))
           then begin
            _DATA.Position:=0;
            _DATA.SaveToFile(SegmentFileName);
            end;
          end;
        finally
        Segment_Unlock(EmptySegments[I]);
        end;
        //.
        if (ItemsList = nil)
         then begin
          ItemsList:=TList.Create;
          ItemsList.Capacity:=EmptySegments.Count;
          end;
        ItemsList.Add(EmptySegments[I]);
        //.
        Result:=true;
        end
       else begin //. exceptional case - no segment to degenerate
        if (TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.flEnabled AND (Segment_idOGLTexture(EmptySegments[I]) <> 0)) then TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.DeleteSegmentTexture(EmptySegments[I]);
        //.
        TSystemTTileServerVisualization(TypeSystem).EmptySegmentImageDATA.Position:=0;
        DS:=TMemoryStream.Create;
        DS.LoadFromStream(TSystemTTileServerVisualization(TypeSystem).EmptySegmentImageDATA);
        Segment_SetDATA(EmptySegments[I],DS);
        //.
        if (ItemsList = nil)
         then begin
          ItemsList:=TList.Create;
          ItemsList.Capacity:=EmptySegments.Count;
          end;
        ItemsList.Add(EmptySegments[I]);
        //.
        Result:=true;
        end;
      //.
      if (ptrCancelFlag <> nil)
       then begin
        Sleep(0); //. exit from the current thread to alow the cancel flag to be set
        if (Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
        end;
      end;
    finally
    TLevelItemOfTTileServerVisualizationCash(SrcLevel^).Lock.EndRead;
    end;
    finally
    IL.Destroy;
    end;
    end;
  finally
  EmptySegments.Destroy;
  end;
  finally
  Lock.EndRead;
  end;
  finally
  DegeneratedSegmentBMP.Canvas.Unlock;
  DegeneratedSegmentBMP.Destroy;
  end;
  end;
  finally
  DegenerateSegmentBMP.Canvas.Unlock;
  DegenerateSegmentBMP.Destroy;
  end;
  except
    if (ItemsList <> nil) then FreeAndNil(ItemsList);
    Raise; //. =>
    end;
  end;

var
  StartupInput: TGDIPlusStartupInput;
  UpLevels: TList;
  LevelPtr: pointer;
begin 
Result:=false;
ItemsList:=nil;
try
//. Initialize GDI+
StartupInput.DebugEventCallback := nil;
StartupInput.SuppressBackgroundThread:=False;
StartupInput.SuppressExternalCodecs:=False;
StartupInput.GdiplusVersion:=1;
GdiplusStartup(gdiplusToken, @StartupInput, nil);
try
with TItemTTileServerVisualizationCash(ptrItem^) do begin
UpLevels:=TList.Create;
try
UpLevels.Capacity:=16;
//.
LevelPtr:=Levels;
while (LevelPtr <> nil) do begin
  if (LevelPtr = ptrLevel)
   then Break //. >
   else begin
    UpLevels.Add(LevelPtr);
    LevelPtr:=TLevelItemOfTTileServerVisualizationCash(LevelPtr^).ptrNext;
    end;
  end;
//. process target level
TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.BeginRead;
try
Result:=Item_ProcessLevel(ptrItem, ptrLevel,UpLevels,UpLevels.Count-1, XIndexMin,XIndexMax,YIndexMin,YIndexMax,  ItemsList);
//. update OpenGL segments textures
if ((ItemsList <> nil) AND (ItemsList.Count > 0))
 then 
  if (TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.flEnabled)
   then TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentItemsTextures(ItemsList);
finally
TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.EndRead;
end;
finally
UpLevels.Destroy;
end;
end;
finally
GdiplusShutdown(gdiplusToken);
end;
except
  if (ItemsList <> nil) then FreeAndNil(ItemsList);
  Raise; //. =>
  end;
end;

function TTTileServerVisualizationCash.Item_Level__UpdateSegmentsLocal(const ptrItem: pointer; const pTileProviderID: integer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ExceptSegments: TByteArray; const ptrCancelFlag: pointer): boolean;
const
  NullSegmentHashCode     = -1;
  ExceptedSegmentHashCode = 0;

  function Item_RectangleIsInContext(const ptrItem: pointer; const ptrLevel: pointer; const UpLevels: TList; const UpLevelIndex: integer; XIndexMin,XIndexMax: integer; YIndexMin,YIndexMax: integer): boolean;

    function LevelRectangleIsInContext(const ptrLevel: pointer): boolean;
    var
      ptrSegment: pointer;
      X,Y: integer;
      LevelFolder,SegmentFileName: string;
    begin
    Result:=true;
    with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
    Lock.BeginRead;
    try
    //. check in-range segments in memory
    ptrSegment:=Segments;
    while (ptrSegment <> nil) do with TSegmentItemOfTTileServerVisualizationCash(ptrSegment^).Params do begin
      if (((XIndexMin <= XIndex) AND (XIndex <= XIndexMax)) AND ((YIndexMin <= YIndex) AND (YIndex <= YIndexMax)))
       then Exit; //. ->
      //. next segment
      ptrSegment:=ptrNext;
      end;
    //. check in-range segments in file context
    LevelFolder:=Item_Level__GetContextFolder(TItemTTileServerVisualizationCash(ptrItem^).idObj,pTileProviderID,Params.ID);
    for Y:=YIndexMin to YIndexMax do
      for X:=XIndexMin to XIndexMax do begin
        SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(X)+'Y'+IntToStr(Y)+'.jpg';
        if (FileExists(SegmentFileName)) then Exit; //. ->
        end;
    finally
    Lock.EndRead;
    end;
    end;
    Result:=false;
    end;

  var
    L: integer;
  begin
  Result:=true;
  if (LevelRectangleIsInContext(ptrLevel)) then Exit; //. ->
  for L:=UpLevelIndex downto 0 do begin
    XIndexMin:=(XIndexMin SHR 1); XIndexMax:=(XIndexMax SHR 1);
    YIndexMin:=(YIndexMin SHR 1); YIndexMax:=(YIndexMax SHR 1);
    if (LevelRectangleIsInContext(UpLevels[L])) then Exit; //. ->
    end;
  Result:=false;
  end;

  function Item_ProcessLevel(const ptrItem: pointer; const ptrLevel: pointer; const UpLevels: TList; const UpLevelIndex: integer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ExceptSegments: TByteArray): boolean;

    procedure UpdateSegmentsFromByteArray(const ptrLevel: pointer; const BA: TByteArray);

      function GetSegment(var Segments: pointer; const XI,YI: integer; out ptrSegment: pointer): boolean;
      var
        ptrptrSegment: pointer;
      begin
      ptrSegment:=nil;
      //.
      ptrptrSegment:=@Segments;
      while (Pointer(ptrptrSegment^) <> nil) AND (YI > TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).Params.YIndex) do begin
        ptrptrSegment:=@TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).ptrNext;
        end;
      while (Pointer(ptrptrSegment^) <> nil) AND ((YI = TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).Params.YIndex) AND (XI > TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).Params.XIndex)) do begin
        ptrptrSegment:=@TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).ptrNext;
        end;
      if ((Pointer(ptrptrSegment^) <> nil) AND ((YI = TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).Params.YIndex) AND (XI = TSegmentItemOfTTileServerVisualizationCash(Pointer(ptrptrSegment^)^).Params.XIndex)))
       then begin
        ptrSegment:=Pointer(ptrptrSegment^);
        Result:=true;
        end
       else Result:=false;
      end;

      procedure UpdateSegmentsOnUpLevels(const XIndex,YIndex: integer; const SegmentData: TMemoryStream);
      var
        SrcBMP,DestBMP,B: TBitmap;
        DestLevelFolder: string;
        X,Y: integer;
        OfsX,OfsY: integer;
        UpLevel: integer;
        ptrUpLevel: pointer;
        ptrDestSegment: pointer;
        ExceptSegments: TByteArray;
        RSL: TList;
        SegmentFileName: string;
        SegmentJI: TJpegImage;
        SegmentNewDATA: TMemoryStream;
      begin
      SrcBMP:=TBitmap.Create;
      SrcBMP.Canvas.Lock;
      DestBMP:=TBitmap.Create;
      DestBMP.Canvas.Lock;
      try
      SrcBMP.HandleType:=bmDIB;
      SrcBMP.PixelFormat:=pf24bit;
      DestBMP.HandleType:=bmDIB;
      DestBMP.PixelFormat:=pf24bit;
      //.
      SegmentData.Position:=0;
      if (NOT GetBitmapFromJPEGStream(SegmentData,SrcBMP)) then Raise Exception.Create('TTTileServerVisualizationCash.Item_Level__UpdateSegmentsLocal: GetBitmapFromJPEGStream fails'); //. =>
      //.
      X:=XIndex;
      Y:=YIndex;
      OfsX:=0;
      OfsY:=0;
      for UpLevel:=UplevelIndex downto 0 do begin
        ptrUpLevel:=UpLevels[UpLevel];
        with TLevelItemOfTTileServerVisualizationCash(ptrUpLevel^) do begin
        DestLevelFolder:=Item_Level__GetContextFolder(TItemTTileServerVisualizationCash(ptrItem^).idObj,pTileProviderID,Params.ID);
        Lock.BeginRead;
        try
        if ((X AND 1) = 1) then Inc(OfsX,Trunc(Params.SegmentWidth));
        if ((Y AND 1) = 1) then Inc(OfsY,Trunc(Params.SegmentHeight));
        OfsX:=(OfsX SHR 1);
        OfsY:=(OfsY SHR 1);
        X:=(X SHR 1);
        Y:=(Y SHR 1);
        DestBMP.Width:=(SrcBMP.Width SHR 1);
        DestBMP.Height:=(SrcBMP.Height SHR 1);
        //.
        if (NOT Bitmap_DrawToQuarterBitmap(SrcBMP,DestBMP)) then Raise Exception.Create('TTTileServerVisualizationCash.Item_Level__UpdateSegmentsLocal: Bitmap_DrawToQuarterBitmap fails'); //. =>
        //.
        ptrDestSegment:=nil;
        if (NOT GetSegment(TLevelItemOfTTileServerVisualizationCash(ptrUpLevel^).Segments, X,Y, {out} ptrDestSegment))
         then begin
          SetLength(ExceptSegments,0);
          if (TSystemTTileServerVisualization(TypeSystem).Cash.Item_Level__RestoreSegmentsLocal(ptrItem, pTileProviderID, ptrUpLevel, X,X,Y,Y, nil,  RSL, ExceptSegments))
           then ptrDestSegment:=RSL[0];
          RSL.Free;
          end;
        if (ptrDestSegment <> nil)
         then begin
          //. delete segment texture for updating segment (it will be generated later on reflecting)
          if (TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.flEnabled) then TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.DeleteSegmentTexture(ptrDestSegment);
          //.
          Segment_Lock(ptrDestSegment);
          with TSegmentItemOfTTileServerVisualizationCash(ptrDestSegment^) do
          try
          SegmentFileName:=DestLevelFolder+'\'+'X'+IntToStr(Params.XIndex)+'Y'+IntToStr(Params.YIndex)+'.jpg';
          if (Params._DATA = nil)
           then begin
            Params._DATA:=TMemoryStream.Create();
            if (FileExists(SegmentFileName)) then Params._DATA.LoadFromFile(SegmentFileName);
            end;
          //.
          if (Params._DATA.Size > 0)
           then begin
            if (NOT GetBitmapFromJPEGStream(Params._DATA,SrcBMP)) then Raise Exception.Create('TTTileServerVisualizationCash.Item_Level__UpdateSegmentsLocal: GetBitmapFromJPEGStream fails'); //. =>
            SrcBMP.Canvas.Draw(OfsX,OfsY,DestBMP);
            //.
            SegmentNewDATA:=TMemoryStream.Create;
            try
            SegmentJI:=TJpegImage.Create;
            try
            SegmentJI.Assign(SrcBMP);
            //. save segment to stream
            SegmentJI.SaveToStream(SegmentNewDATA);
            finally
            SegmentJI.Destroy;
            end;
            except
              FreeAndNil(SegmentNewDATA);
              Raise; //. =>
              end;
            //. assign new data to segment
            Segment_SetDATA(ptrDestSegment,SegmentNewDATA);
            //. save new data to context file
            SegmentNewDATA.SaveToFile(SegmentFileName);
            end;
          finally
          Segment_Unlock(ptrDestSegment);
          end;
          end;
        //.
        B:=SrcBMP; SrcBMP:=DestBMP; DestBMP:=B;
        finally
        Lock.EndRead;
        end;
        end;
        end;
      finally
      DestBMP.Destroy;
      SrcBMP.Destroy;
      end;
      end;

    var
      ItemsList: TList;
      P,Pend,SDP: pointer;
      LevelFolder: string;
      _id: integer;
      _XIndex,_YIndex: integer;
      ptrSegment: pointer;
      DATASize: integer;
      ptrExistedSegment: pointer;
      SegmentFileName: string;
      DS: TMemoryStream;
    begin
    with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
    Lock.BeginRead;
    try
    P:=@BA[0];
    Pend:=Pointer(Integer(P)+Length(BA));
    if (P <> Pend)
     then begin
      ItemsList:=TList.Create;
      try
      LevelFolder:=Item_Level__GetContextFolder(TItemTTileServerVisualizationCash(ptrItem^).idObj,pTileProviderID,Params.ID);
      ForceDirectories(LevelFolder);
      repeat
        //. get segment params
        _id:=Integer(P^); Inc(DWord(P),SizeOf(_id));
        _XIndex:=Integer(P^); Inc(DWord(P),SizeOf(_XIndex));
        _YIndex:=Integer(P^); Inc(DWord(P),SizeOf(_YIndex));
        //.
        SDP:=P;
        if (GetSegment(TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Segments, _XIndex,_YIndex, ptrSegment))
         then begin
          //. assign new data
          DATASize:=Integer(P^); Inc(DWord(P),SizeOf(DATASize));
          DS:=TMemoryStream.Create;
          if (DATASize > 0)
           then begin
            DS.Size:=DATASize;
            DS.Write(P^,DATASize);
            Inc(DWord(P),DATASize);
            end;
          //.
          if (TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.flEnabled AND (Segment_idOGLTexture(ptrSegment) <> 0)) then TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.DeleteSegmentTexture(ptrSegment);
          Segment_SetDATA(ptrSegment,DS);
          end
         else begin
          GetMem(ptrSegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
          with TSegmentItemOfTTileServerVisualizationCash(ptrSegment^) do begin
          ptrNext:=nil;
          Lock:=TLevelItemOfTTileServerVisualizationCash(ptrLevel^).SegmentLock;
          with Params do begin
          id:=_id;
          XIndex:=_XIndex;
          YIndex:=_YIndex;
          DATASize:=Integer(P^); Inc(DWord(P),SizeOf(DATASize));
          _DATA:=TMemoryStream.Create;
          if (DATASize > 0)
           then begin
            _DATA.Size:=DATASize;
            _DATA.Write(P^,DATASize);
            Inc(DWord(P),DATASize);
            end;
          end;
          _idOGLTexture:=0;
          end;
          TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.BeginWrite;
          try
          if (TTileServerVisualizationCashItemLevelSegments_Insert(TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Segments,ptrSegment,@ptrExistedSegment))
           then AccessedSegmentsRevising.Add(ptrSegment,ptrLevel,TItemTTileServerVisualizationCash(ptrItem^).idObj) //. process segment as accessed
           else begin
            Segment_SetDATA(ptrExistedSegment,TSegmentItemOfTTileServerVisualizationCash(ptrSegment^).Params._DATA);
            FreeMem(ptrSegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
            ptrSegment:=ptrExistedSegment;
            end;
          finally
          TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.EndWrite;
          end;
          end;
        //.
        if (ptrSegment <> nil)
         then begin
          //. save new segment into the local file
          Segment_Lock(ptrSegment);
          try
          with TSegmentItemOfTTileServerVisualizationCash(ptrSegment^).Params do
          if ((_DATA <> nil) AND (_DATA.Size > 0))
           then begin
            SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
            _DATA.Position:=0;
            _DATA.SaveToFile(SegmentFileName);
            end;
          finally
          Segment_Unlock(ptrSegment);
          end;
          //.
          ItemsList.Add(ptrSegment);
          //. update segments on up levels
          DATASize:=Integer(SDP^); Inc(DWord(SDP),SizeOf(DATASize));
          DS:=TMemoryStream.Create;
          try
          if (DATASize > 0)
           then begin
            DS.Size:=DATASize;
            DS.Write(SDP^,DATASize);
            end;
          UpdateSegmentsOnUpLevels(_XIndex,_YIndex,DS);
          finally
          DS.Destroy;
          end;
          end;
      until (P = Pend);
      //. generate textures for the updated segments
      if (TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.flEnabled) then TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentItemsTextures(ItemsList);
      finally
      ItemsList.Destroy;
      end;
      end;
    finally
    Lock.EndRead;
    end;
    end;
    end;

    function ExceptSegments_SegmentFound(ExceptSegmentsPtr: pointer; ExceptSegmentsSize: integer; SegmentID: integer): boolean;
    begin
    asm
          PUSH EAX
          PUSH ECX
          PUSH EDI
          MOV EAX,SegmentID
          MOV EDI,ExceptSegmentsPtr
          MOV ECX,ExceptSegmentsSize
          JECXZ @M1
          CLD
          REPNE SCASD
          JNE @M1
            MOV Result,true
            JMP @M2
    @M1:  MOV Result,false
    @M2:  POP EDI
          POP ECX
          POP EAX
    end;
    end;

    function IsSegmentRequiresUpdate(const LevelFolder: string; const X,Y: integer; const NewSegmentHashCode: integer): boolean;
    var
      SegmentFileName: string;
      FA: integer;
    begin
    Result:=false;
    //.
    SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(X)+'Y'+IntToStr(Y)+'.jpg';
    FA:=FileAge(SegmentFileName);
    if (FA = -1) then Exit; //. ->
    Result:=(FA < NewSegmentHashCode);
    end;

  var
    LevelFolder: string;
    SizeX,SizeY: integer;
    SegmentsSize: integer;
    SegmentsTable: pointer;
    SegmentsHashes: TByteArray;
    SegmentHashItemPtr: pointer;
    ExceptSegmentsCount: integer;
    ExceptSegmentsPtr: pointer;
    SegmentID: integer;
    SegmentHashCode: integer;
    X,Y: integer;
    SegmentsToUpdateCount: integer;
    NullSegmentsCount: integer;
    I: integer;
    NewExceptSegments: TByteArray;
    UpLevel_SizeX,UpLevel_SizeY: integer;
    UpLevel_SegmentsSize: integer;
    UpLevel_SegmentsTable: pointer;
    UpLevel_NullSegmentsCount: integer;
    UpLevel_X,UpLevel_Y: integer;
    NewSegments: TByteArray;
    UpLevel_XIndexMin,UpLevel_YIndexMin,UpLevel_XIndexMax,UpLevel_YIndexMax: integer;
  begin
  Result:=false;
  with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
  Lock.BeginRead;
  try
  //. get segments hash codes
  with TTileServerVisualizationFunctionality(TComponentFunctionality_Create(idTTileServerVisualization,TItemTTileServerVisualizationCash(ptrItem^).idObj)) do
  try
  Level_GetSegmentsHashes(Params.ID, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ExceptSegments, SegmentsHashes);
  //.
  if (ptrCancelFlag <> nil)
   then begin
    Sleep(0); //. exit from the current thread to alow the cancel flag to be set
    if (Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
    end;
  //.
  LevelFolder:=Item_Level__GetContextFolder(TItemTTileServerVisualizationCash(ptrItem^).idObj,pTileProviderID,Params.ID);
  SizeX:=(XIndexMax-XIndexMin+1); SizeY:=(YIndexMax-YIndexMin+1);
  //.
  SegmentsSize:=(SizeX*SizeY)*SizeOf(SegmentHashCode);
  GetMem(SegmentsTable,SegmentsSize);
  try
  SegmentsToUpdateCount:=0;
  NullSegmentsCount:=0;
  SegmentHashItemPtr:=@SegmentsHashes[0];
  ExceptSegmentsPtr:=@ExceptSegments[0];
  ExceptSegmentsCount:=(Length(ExceptSegments) DIV SizeOf(SegmentID));
  for Y:=YIndexMin to YIndexMax do
    for X:=XIndexMin to XIndexMax do begin
      SegmentID:=SegmentPositionHashCode(X,Y);
      if (NOT ExceptSegments_SegmentFound(ExceptSegmentsPtr,ExceptSegmentsCount,SegmentID))
       then begin
        SegmentHashCode:=Integer(SegmentHashItemPtr^);
        Inc(DWord(SegmentHashItemPtr),SizeOf(SegmentHashCode));
        //.
        if (SegmentHashCode <> NullSegmentHashCode)
         then begin //. check segment for update
          if (IsSegmentRequiresUpdate(LevelFolder, X,Y, SegmentHashCode))
           then Inc(SegmentsToUpdateCount)
           else SegmentHashCode:=ExceptedSegmentHashCode;
          end
         else Inc(NullSegmentsCount);
        end
       else SegmentHashCode:=ExceptedSegmentHashCode;
      //.
      Integer(Pointer(Integer(SegmentsTable)+((Y-YIndexMin)*SizeX+(X-XIndexMin))*SizeOf(SegmentHashCode))^):=SegmentHashCode;
      end;
  //.
  if (SegmentsToUpdateCount > 0)
   then begin
    SetLength(NewExceptSegments,((SizeX*SizeY)-SegmentsToUpdateCount)*SizeOf(SegmentID));
    ExceptSegmentsPtr:=@NewExceptSegments[0];
    for Y:=YIndexMin to YIndexMax do
      for X:=XIndexMin to XIndexMax do begin
        SegmentHashCode:=Integer(Pointer(Integer(SegmentsTable)+((Y-YIndexMin)*SizeX+(X-XIndexMin))*SizeOf(SegmentHashCode))^);
        if ((SegmentHashCode = ExceptedSegmentHashCode) OR (SegmentHashCode = NullSegmentHashCode))
         then begin
          Integer(ExceptSegmentsPtr^):=SegmentPositionHashCode(X,Y);
          Inc(DWord(ExceptSegmentsPtr),SizeOf(SegmentID));
          end;
        end;
    //. get the update segments from the server
    Level_GetSegments(pTileProviderID, Params.ID, XIndexMin,XIndexMax,YIndexMin,YIndexMax, NewExceptSegments, NewSegments);
    //. update segments from byte array
    UpdateSegmentsFromByteArray(ptrLevel,NewSegments);
    //.
    Result:=true;
    end;
  if ((NullSegmentsCount > 0) AND (UpLevelIndex >= 0))
   then begin
    UpLevel_XIndexMin:=XIndexMin SHR 1; UpLevel_YIndexMin:=YIndexMin SHR 1;
    UpLevel_XIndexMax:=XIndexMax SHR 1; UpLevel_YIndexMax:=YIndexMax SHR 1;
    UpLevel_SizeX:=(UpLevel_XIndexMax-UpLevel_XIndexMin+1);
    UpLevel_SizeY:=(UpLevel_YIndexMax-UpLevel_YIndexMin+1);
    UpLevel_SegmentsSize:=(UpLevel_SizeX*UpLevel_SizeY)*SizeOf(SegmentHashCode);
    GetMem(UpLevel_SegmentsTable,UpLevel_SegmentsSize);
    try
    //.
    for I:=0 to (UpLevel_SizeX*UpLevel_SizeY)-1 do Integer(Pointer(Integer(UpLevel_SegmentsTable)+I*SizeOf(SegmentHashCode))^):=ExceptedSegmentHashCode;
    //.
    UpLevel_NullSegmentsCount:=0;
    for Y:=YIndexMin to YIndexMax do
      for X:=XIndexMin to XIndexMax do begin
        SegmentHashCode:=Integer(Pointer(Integer(SegmentsTable)+((Y-YIndexMin)*SizeX+(X-XIndexMin))*SizeOf(SegmentHashCode))^);
        if (SegmentHashCode = NullSegmentHashCode)
         then begin //. prepare for up level
          UpLevel_X:=X SHR 1; UpLevel_Y:=Y SHR 1;
          if (Integer(Pointer(Integer(UpLevel_SegmentsTable)+((UpLevel_Y-UpLevel_YIndexMin)*UpLevel_SizeX+(UpLevel_X-UpLevel_XIndexMin))*SizeOf(SegmentHashCode))^) <> NullSegmentHashCode)
           then begin
            Integer(Pointer(Integer(UpLevel_SegmentsTable)+((UpLevel_Y-UpLevel_YIndexMin)*UpLevel_SizeX+(UpLevel_X-UpLevel_XIndexMin))*SizeOf(SegmentHashCode))^):=NullSegmentHashCode;
            Inc(UpLevel_NullSegmentsCount);
            end;
          end;
        end;
    //. correspond processing to the up level if the level null segments exist
    SetLength(NewExceptSegments,((UpLevel_SizeX*UpLevel_SizeY)-UpLevel_NullSegmentsCount)*SizeOf(SegmentID));
    ExceptSegmentsPtr:=@NewExceptSegments[0];
    for UpLevel_Y:=UpLevel_YIndexMin to UpLevel_YIndexMax do
      for UpLevel_X:=UpLevel_XIndexMin to UpLevel_XIndexMax do begin
        SegmentHashCode:=Integer(Pointer(Integer(UpLevel_SegmentsTable)+((UpLevel_Y-UpLevel_YIndexMin)*UpLevel_SizeX+(UpLevel_X-UpLevel_XIndexMin))*SizeOf(SegmentHashCode))^);
        if (SegmentHashCode = ExceptedSegmentHashCode)
         then begin
          Integer(ExceptSegmentsPtr^):=SegmentPositionHashCode(UpLevel_X,UpLevel_Y);
          Inc(DWord(ExceptSegmentsPtr),SizeOf(SegmentID));
          end;
        end;
    //. process up level for empty segments
    Result:=(Result OR Item_ProcessLevel(ptrItem, UpLevels[UpLevelIndex], UpLevels,UpLevelIndex-1, UpLevel_XIndexMin,UpLevel_XIndexMax,UpLevel_YIndexMin,UpLevel_YIndexMax, NewExceptSegments));
    finally
    FreeMem(UpLevel_SegmentsTable,UpLevel_SegmentsSize);
    end;
    end;
  finally
  FreeMem(SegmentsTable,SegmentsSize);
  end;
  finally
  Release;
  end;
  finally
  Lock.EndRead;
  end;
  end;
  end;

var
  UpLevels: TList;
  LevelPtr: pointer;
begin
with TItemTTileServerVisualizationCash(ptrItem^) do begin
UpLevels:=TList.Create;
try
UpLevels.Capacity:=16;
//.
LevelPtr:=Levels;
while (LevelPtr <> nil) do begin
  if (LevelPtr = ptrLevel)
   then Break //. >
   else begin
    UpLevels.Add(LevelPtr);
    LevelPtr:=TLevelItemOfTTileServerVisualizationCash(LevelPtr^).ptrNext;
    end;
  end;
//. process target level if segments context exists
if (Item_RectangleIsInContext(ptrItem, ptrLevel, UpLevels,UpLevels.Count-1, XIndexMin,XIndexMax,YIndexMin,YIndexMax))
 then Result:=Item_ProcessLevel(ptrItem, ptrLevel, UpLevels,UpLevels.Count-1, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ExceptSegments)
 else Result:=false;
finally
UpLevels.Destroy;
end;
end;
end;

function TTTileServerVisualizationCash.Item_SetTileProviderID(const ptrItem: pointer; const pTileProviderID: integer): boolean;
begin
Result:=false;
with TItemTTileServerVisualizationCash(ptrItem^) do begin
if ((ServerParsedData = nil) OR (ServerParsedData.TileProviders_ItemIndex(pTileProviderID) < 0)) then Exit; //. ->
TTileServerVisualizationCashItem_FreeAndNilLevelsSegments(TSystemTTileServerVisualization(TypeSystem),{ref} Levels);
TileProviderID:=pTileProviderID;
end;
Result:=true;
end;

procedure TTTileServerVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetServerData(const DATA: TByteArray): OLEVariant;
  var
    DATAPtr: pointer;
  begin
  if (Length(DATA) > 0)
   then begin
    Result:=VarArrayCreate([0,Length(DATA)-1],varByte);
    DATAPtr:=VarArrayLock(Result);
    try
    Move(Pointer(@DATA[0])^,DATAPtr^,Length(DATA));
    finally
    VarArrayUnLock(Result);
    end;
    end
   else Result:=Null;
  end;

  function GetSegmentDATA(const ImageStream: TMemoryStream): OLEVariant;
  var
    MS: TMemoryStream;
    DATAPtr: pointer;
  begin
  MS:=TMemoryStream.Create;
  with MS do
  try
  if (ImageStream <> nil)
   then begin
    ImageStream.SaveToStream(MS);
    Position:=0;
    end;
  Result:=VarArrayCreate([0,Size-1],varByte);
  DATAPtr:=VarArrayLock(Result);
  try
  Read(DATAPtr^,Size);
  finally
  VarArrayUnLock(Result);
  end;
  finally
  Destroy;
  end;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
  //.
  LevelsNode: IXMLDOMElement;
  ptrLevel: pointer;
  LevelNode: IXMLDOMElement;
  LevelFolder: string;
  SegmentsNode: IXMLDOMElement;
  ptrSegment: pointer;
  SegmentFileName: string;
  SegmentNode: IXMLDOMElement;
begin
Lock.BeginRead;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTTileServerVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('ServerType');   PropNode.nodeTypedValue:=ServerType;        ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('ServerURL');    PropNode.nodeTypedValue:=ServerURL;         ItemNode.appendChild(PropNode);
  //.
  PropNode:=Document.CreateElement('ServerData');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetServerData(ServerData);
  ItemNode.appendChild(PropNode);
  //.
  PropNode:=Document.CreateElement('TileProviderID');   PropNode.nodeTypedValue:=TileProviderID;    ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Width');            PropNode.nodeTypedValue:=Width;             ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Height');           PropNode.nodeTypedValue:=Height;            ItemNode.appendChild(PropNode);
  //. process levels
  LevelsNode:=Document.CreateElement('Levels');
  ptrLevel:=Levels;
  while (ptrLevel <> nil) do with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
    Lock.BeginRead;
    try
    LevelNode:=Document.CreateElement('Level'+IntToStr(LevelIndex));
    PropNode:=Document.CreateElement('id');                 PropNode.nodeTypedValue:=Params.id;              LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('Disabled');           PropNode.nodeTypedValue:=Disabled;               LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('Persist');            PropNode.nodeTypedValue:=flPersist;              LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('DivX');               PropNode.nodeTypedValue:=Params.DivX;            LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('DivY');               PropNode.nodeTypedValue:=Params.DivY;            LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('SegmentWidth');       PropNode.nodeTypedValue:=Params.SegmentWidth;    LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('SegmentHeight');      PropNode.nodeTypedValue:=Params.SegmentHeight;   LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('VisibleMinScale');    PropNode.nodeTypedValue:=Params.VisibleMinScale; LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('VisibleMaxScale');    PropNode.nodeTypedValue:=Params.VisibleMaxScale; LevelNode.appendChild(PropNode);
    //. process segments
    SegmentsNode:=Document.CreateElement('Segments');
    if (Segments <> nil)
     then begin
      LevelFolder:=Item_Level__GetContextFolder(idObj,TileProviderID,Params.ID);
      ForceDirectories(LevelFolder);
      end;
    //.
    ptrSegment:=Segments;
    while (ptrSegment <> nil) do with TSegmentItemOfTTileServerVisualizationCash(ptrSegment^) do begin
      Segment_Lock(ptrSegment);
      try
      if ((Params._DATA <> nil) AND (Params._DATA.Size > 0))
       then begin
        SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(Params.XIndex)+'Y'+IntToStr(Params.YIndex)+'.jpg';
        if (NOT FileExists(SegmentFileName))
         then begin
          Params._DATA.Position:=0;
          Params._DATA.SaveToFile(SegmentFileName);
          end;
        end;
      finally
      Segment_Unlock(ptrSegment);
      end;
      //. next segment
      ptrSegment:=ptrNext;
      end;
    //.
    ptrSegment:=Segments;
    while (ptrSegment <> nil) do with TSegmentItemOfTTileServerVisualizationCash(ptrSegment^) do begin
      SegmentNode:=Document.CreateElement('Segment'+IntToStr(Params.id));
      PropNode:=Document.CreateElement('id');     PropNode.nodeTypedValue:=Params.id;     SegmentNode.appendChild(PropNode);
      PropNode:=Document.CreateElement('XIndex'); PropNode.nodeTypedValue:=Params.XIndex; SegmentNode.appendChild(PropNode);
      PropNode:=Document.CreateElement('YIndex'); PropNode.nodeTypedValue:=Params.YIndex; SegmentNode.appendChild(PropNode);
      //. full save
      {PropNode:=Document.CreateElement('DATA');
      PropNode.Set_dataType('bin.base64');
      PropNode.nodeTypedValue:=GetSegmentDATA(Params.DATA);
      SegmentNode.appendChild(PropNode);}
      //.
      SegmentsNode.appendChild(SegmentNode);
      //. next segment
      ptrSegment:=ptrNext;
      end;
    LevelNode.appendChild(SegmentsNode);
    //.
    LevelsNode.appendChild(LevelNode);
    finally
    Lock.EndRead;
    end;
    //. next level
    ptrLevel:=ptrNext;
    end;
  ItemNode.appendChild(LevelsNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
Lock.EndRead;
end;
end;

procedure TTTileServerVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetServerData(const DATA: Variant; out oDATA: TByteArray);
  var
    DATASize: integer;
    DATAPtr: pointer;
  begin
  oDATA:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    SetLength(oDATA,DATASize);
    Move(DATAPtr^,Pointer(@oDATA[0])^,DATASize);
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    SetLength(oData,0);
    Raise; //. =>
    end;
  end;

  procedure SetSegmentDATA(DATA: Variant; out ImageStream: TMemoryStream);
  var
    DATASize: integer;
    DATAPtr: pointer;
    MS: TMemoryStream;
  begin
  ImageStream:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    MS:=TMemoryStream.Create;
    with MS do
    try
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    ImageStream:=TMemoryStream.Create;
    ImageStream.LoadFromStream(MS);
    finally
    Destroy;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(ImageStream);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _ServerType: integer;
  _ServerURL: string;
  _ServerData: Variant;
  _TileProviderID: integer;
  UPTPID: integer;
  _Width: integer;
  _Height: integer;
  LevelsNode: IXMLDOMNode;
  J: integer;
  LevelNode: IXMLDOMNode;
  ptrLastLevel: pointer;
  ptrNewLevel: pointer;
  LevelFolder: string;
  SegmentsNode: IXMLDOMNode;
  K: integer;
  SegmentNode: IXMLDOMNode;
  ptrLastSegment: pointer;
  ptrNewSegment: pointer;
  SegmentFileName: string;
begin
Lock.BeginWrite;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _ServerType:=ItemNode.selectSingleNode('ServerType').nodeTypedValue;
  _ServerURL:=ItemNode.selectSingleNode('ServerURL').nodeTypedValue;
  _ServerData:=ItemNode.selectSingleNode('ServerData').nodeTypedValue;
  _TileProviderID:=ItemNode.selectSingleNode('TileProviderID').nodeTypedValue;
  with TTileServerVisualizationFunctionality(TComponentFunctionality_Create(idTTileServerVisualization,id)) do
  try
  if (UserData_GetTileProviderID({out} UPTPID)) then _TileProviderID:=UPTPID;
  finally
  Release();
  end;
  _Width:=ItemNode.selectSingleNode('Width').nodeTypedValue;
  _Height:=ItemNode.selectSingleNode('Height').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTTileServerVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTTileServerVisualizationCash), 0);
  with TItemTTileServerVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  ptrObj:=nilPtr;
  //.
  ServerType:=_ServerType;
  ServerURL:=_ServerURL;
  SetServerData(_ServerData,{out} ServerData);
  ServerParsedData:=ParseServerData(TTileServerType(ServerType),ServerData);
  TileProviderID:=_TileProviderID;
  Width:=_Width;
  Height:=_Height;
  Levels:=nil;
  //. process levels
  ptrLastLevel:=@Levels;
  LevelsNode:=ItemNode.selectSingleNode('Levels');
  for J:=0 to LevelsNode.childNodes.length-1 do begin
    LevelNode:=LevelsNode.childNodes[J];
    //. process level
    GetMem(ptrNewLevel,SizeOf(TLevelItemOfTTileServerVisualizationCash));
    with TLevelItemOfTTileServerVisualizationCash(ptrNewLevel^) do begin
    ptrNext:=nil;
    ptrItem:=ptrNewItem;
    LevelIndex:=J;
    //.
    Lock:=TMultiReadExclusiveWriteSynchronizer.Create;
    SegmentLock:=TCriticalSection.Create;
    Disabled:=LevelNode.selectSingleNode('Disabled').nodeTypedValue;
    {///? if (LevelNode.selectSingleNode('Persist') <> nil)
     then flPersist:=LevelNode.selectSingleNode('Persist').nodeTypedValue
     else flPersist:=false;}
    flPersist:=false;
    Params.ID:=LevelNode.selectSingleNode('id').nodeTypedValue;
    Params.DivX:=LevelNode.selectSingleNode('DivX').nodeTypedValue;
    Params.DivY:=LevelNode.selectSingleNode('DivY').nodeTypedValue;
    Params.SegmentWidth:=LevelNode.selectSingleNode('SegmentWidth').nodeTypedValue;
    Params.SegmentHeight:=LevelNode.selectSingleNode('SegmentHeight').nodeTypedValue;
    Params.VisibleMinScale:=LevelNode.selectSingleNode('VisibleMinScale').nodeTypedValue;
    Params.VisibleMaxScale:=LevelNode.selectSingleNode('VisibleMaxScale').nodeTypedValue;
    LevelFolder:=Item_Level__GetContextFolder(idObj,TileProviderID,Params.ID);
    //. process segments
    Segments:=nil;
    ptrLastSegment:=@Segments;
    SegmentsNode:=LevelNode.selectSingleNode('Segments');
    for K:=0 to SegmentsNode.childNodes.length-1 do begin
      SegmentNode:=SegmentsNode.childNodes[K];
      GetMem(ptrNewSegment,SizeOf(TSegmentItemOfTTileServerVisualizationCash));
      with TSegmentItemOfTTileServerVisualizationCash(ptrNewSegment^) do begin
      ptrNext:=nil;
      Lock:=TLevelItemOfTTileServerVisualizationCash(ptrNewLevel^).SegmentLock;
      Params.id:=SegmentNode.selectSingleNode('id').nodeTypedValue;
      Params.XIndex:=SegmentNode.selectSingleNode('XIndex').nodeTypedValue;
      Params.YIndex:=SegmentNode.selectSingleNode('YIndex').nodeTypedValue;
      Params._DATA:=nil;
      _idOGLTexture:=0;
      //. load segment data if Level.flPersist = true 
      {if (flPersist)
       then begin
        SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(Params.XIndex)+'Y'+IntToStr(Params.YIndex)+'.jpg';
        Params._DATA:=TMemoryStream.Create();
        if (FileExists(SegmentFileName)) then Params._DATA.LoadFromFile(SegmentFileName);
        end;}
      //. full loading
      {SetSegmentDATA(SegmentNode.selectSingleNode('DATA').nodeTypedValue, Params.DATA);
      if (SegmentsOGLTextures.flEnabled) then TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentTexture(ptrNewSegment);}
      end;
      Pointer(ptrLastSegment^):=ptrNewSegment;
      ptrLastSegment:=ptrNewSegment;
      end;
    end;
    Pointer(ptrLastLevel^):=ptrNewLevel;
    ptrLastLevel:=ptrNewLevel;
    end;
  end;
  FItems:=ptrNewItem;
  end;
finally
Lock.EndWrite;
end;
end;

procedure TTTileServerVisualizationCash.Context_DestroyItemSegments(const pidObj: integer);
var
  ptrItem: pointer;
begin
Lock.BeginWrite;
try
ptrItem:=GetPtrItem(pidObj);
if (ptrItem <> nil) then AccessedSegmentsRevising.RemoveVisualizationSegments(ptrItem);
if (ptrItem <> nil) then TTileServerVisualizationCashItem_FreeAndNilLevels(TSystemTTileServerVisualization(TypeSystem),TItemTTileServerVisualizationCash(ptrItem^).Levels);
Context_DestroyItemSegmentFiles(pidObj);
finally
Lock.EndWrite;
end;
end;

procedure TTTileServerVisualizationCash.Context_DestroyItemSegmentFiles(const pidObj: integer);

  procedure DeleteFolder(const Folder: string);
  var
    sr: TSearchRec;
    FN: string;
  begin
  if (FindFirst(Folder+'\*.*', faAnyFile-faDirectory, sr) = 0)
   then
    try
    repeat
      if (NOT ((sr.Name = '.') OR (sr.Name = '..')))
       then begin
        FN:=Folder+'\'+sr.name;
        DeleteFile(FN);
        end;
    until FindNext(sr) <> 0;
    finally
    FindClose(sr);
    end;
  if (FindFirst(Folder+'\*.*', faDirectory, sr) = 0)
   then
    try
    repeat
      if (NOT ((sr.Name = '.') OR (sr.Name = '..')) AND ((sr.Attr and faDirectory) = faDirectory)) then DeleteFolder(Folder+'\'+sr.name);
    until FindNext(sr) <> 0;
    finally
    FindClose(sr);
    end;
  RemoveDir(Folder);
  end;

var
  ptrItem: pointer;
  ObjFolder: string;
begin
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTTileServerVisualizationCash(ptrItem^) do begin
  if (idObj = pidObj)
   then begin
    ObjFolder:=Item_GetContextFolder(TItemTTileServerVisualizationCash(ptrItem^).idObj);
    DeleteFolder(ObjFolder);
    Exit; //. ->
    end;
  //.
  ptrItem:=ptrNext;
  end;
end;

function TTTileServerVisualizationCash.ParseServerData(const pServerType: TTileServerType; const pServerData: TByteArray): TTileServerParsedData;
begin
case (pServerType) of
tstNative:              Result:=TNativeTileServerParsedData.Create(pServerData);
tstYandexMaps:          Result:=TYandexMapsTileServerParsedData.Create(pServerData);
tstGoogleMaps:          Result:=TGoogleMapsTileServerParsedData.Create(pServerData);
tstOpenStreetMaps:      Result:=TOpenStreetMapsTileServerParsedData.Create(pServerData);
tstNavitelMaps:         Result:=TNavitelMapsTileServerParsedData.Create(pServerData);
else
  Result:=nil;
end;
end;

function TTTileServerVisualizationCash.SegmentPositionHashCode(X,Y: integer): integer;
begin
asm
      PUSH EAX
      PUSH EDX
      MOV EAX,Y
      SHL EAX,16
      MOV EDX,X
      OR AX,DX
      MOV Result,EAX
      POP EDX
      POP EAX
end;
end;

procedure TTTileServerVisualizationCash.Segment_Lock(const ptrSegment: pointer);
begin
TSegmentItemOfTTileServerVisualizationCash(ptrSegment^).Lock.Enter;
end;

procedure TTTileServerVisualizationCash.Segment_UnLock(const ptrSegment: pointer);
begin
TSegmentItemOfTTileServerVisualizationCash(ptrSegment^).Lock.Leave;
end;

function TTTileServerVisualizationCash.Segment_SetidOGLTexture(const ptrSegment: pointer; const Value: cardinal): cardinal;
begin
with TSegmentItemOfTTileServerVisualizationCash(ptrSegment^) do begin
Lock.Enter;
try
Result:=_idOGLTexture;
_idOGLTexture:=Value;
finally
Lock.Leave;
end;
end;
end;

function TTTileServerVisualizationCash.Segment_idOGLTexture(const ptrSegment: pointer): cardinal;
begin
with TSegmentItemOfTTileServerVisualizationCash(ptrSegment^) do begin
Lock.Enter;
try
Result:=_idOGLTexture;
finally
Lock.Leave;
end;
end;
end;

procedure TTTileServerVisualizationCash.Segment_SetDATA(const ptrSegment: pointer; const pDATA: TMemoryStream);
begin
with TSegmentItemOfTTileServerVisualizationCash(ptrSegment^) do begin
Lock.Enter;
try
Params._DATA.Free();
Params._DATA:=pDATA;
finally
Lock.Leave;
end;
end;
end;

function TTTileServerVisualizationCash.Segment_DATAIsNull(const ptrSegment: pointer): boolean;
begin
with TSegmentItemOfTTileServerVisualizationCash(ptrSegment^) do begin
Lock.Enter;
try
Result:=(Params._DATA = nil);
finally
Lock.Leave;
end;
end;
end;

function TTTileServerVisualizationCash.Segment_DATAIsEmpty(const ptrSegment: pointer): boolean;
{
  ! to use in TTTileServerVisualizationCash.Item_Level__GetVisibleSegmentsLocal() especially for TTileServerVisualizationFunctionality.Reflect()
}
begin
with TSegmentItemOfTTileServerVisualizationCash(ptrSegment^) do begin
Lock.Enter;
try
Result:=((Params._DATA <> nil) AND (Params._DATA.Size = 0));
finally
Lock.Leave;
end;
end;
end;

function TTTileServerVisualizationCash.Segment_DATAIsNotEmpty(const ptrSegment: pointer): boolean;
{
  ! to use in TTileServerVisualizationFunctionality.Reflect().Composition_ProcessSegment()
}
begin
with TSegmentItemOfTTileServerVisualizationCash(ptrSegment^) do begin
Lock.Enter;
try
Result:=((Params._DATA <> nil) AND (Params._DATA.Size > 0));
finally
Lock.Leave;
end;
end;
end;


{TTileServerDeferredReflecting}
Constructor TTileServerDeferredReflecting.Create(const pTypeSystem: TSystemTTileServerVisualization; const pflLiveUpdateOnly: boolean; const pReflector: TReflector; const pidObj: integer; const pptrObj: TPtr; const pidLevel: integer; const pXIndexMin,pXIndexMax,pYIndexMin,pYIndexMax: integer; const pExceptSegments: TByteArray; const pptrCancelFlag: pointer);
begin
TypeSystem:=pTypeSystem;
flFinished:=false;
flLiveUpdateOnly:=pflLiveUpdateOnly;
ReflectorsList:=TThreadList.Create;
if (pReflector <> nil) then ReflectorsList.Add(pReflector);
idObj:=pidObj;
ptrObj:=pptrObj;
idLevel:=pidLevel;
XIndexMin:=pXIndexMin; XIndexMax:=pXIndexMax;
YIndexMin:=pYIndexMin; YIndexMax:=pYIndexMax;
ExceptSegments:=pExceptSegments;
ptrCancelFlag:=pptrCancelFlag;
FreeOnTerminate:=true;
flUpdateIsNeeded:=false;
TypeSystem.TileServerDeferredReflectingList.Add(Self);
Inherited Create(true);
Priority:=tpLowest;
end;

procedure TTileServerDeferredReflecting.Execute;
{
  if you change this update TTileServerVisualizationFunctionality.ReflectOnCanvas.SupplyLevelWithSegments() as well
}

  function ChangeSegmentsGettingForBestReflecting(const XIndexMin,XIndexMax,YIndexMin,YIndexMax: integer; var ExceptSegments: TByteArray): boolean;
  label
    SearchEnd;
  const
    SegmentsPortionForHighSpeed = 2;
    SegmentsPortionForLowSpeed = 2;
  var
    SegmentsPortion: integer;
    Count: integer;
    ExceptCount: integer;
    _CountToExcept: integer;
    ExceptSegmentsPtr: pointer;
    ExceptSegmentsSize: integer;
    _XIndexMin,_XIndexMax,_YIndexMin,_YIndexMax: integer;
    X,Y: integer;

    function ProcessSegmentPosition(const X,Y: integer): boolean;

      function ExceptSegments_SegmentFound(ExceptSegmentsPtr: pointer; ExceptSegmentsSize: integer; SegmentID: integer): boolean;
      begin
      asm
            PUSH EAX
            PUSH ECX
            PUSH EDI
            MOV EAX,SegmentID
            MOV EDI,ExceptSegmentsPtr
            MOV ECX,ExceptSegmentsSize
            JECXZ @M1
            CLD
            REPNE SCASD
            JNE @M1
              MOV Result,true
              JMP @M2
      @M1:  MOV Result,false
      @M2:  POP EDI
            POP ECX
            POP EAX
      end;
      end;

    var
      ID: integer;
    begin
    Result:=false;  
    ID:=TypeSystem.Cash.SegmentPositionHashCode(X,Y);
    if (NOT ExceptSegments_SegmentFound(ExceptSegmentsPtr,ExceptSegmentsSize,ID))
     then begin
      Integer(Pointer(DWord(ExceptSegmentsPtr)+ExceptCount*SizeOf(Integer))^):=ID;
      Inc(ExceptCount);
      //.
      Dec(_CountToExcept);
      Result:=(_CountToExcept = 0);
      end;
    end;

  begin
  Result:=false;
  //. change ExceptSegments for segments portion
  if (TypeSystem.Cash.PersistLevelsProviding.flServerConnectionIsFast)
   then SegmentsPortion:=SegmentsPortionForHighSpeed
   else SegmentsPortion:=SegmentsPortionForLowSpeed;
  Count:=(XIndexMax-XIndexMin+1)*(YIndexMax-YIndexMin+1);
  if (Count > SegmentsPortion)
   then begin
    ExceptCount:=Length(ExceptSegments) DIV SizeOf(Integer);
    _CountToExcept:=Count-ExceptCount-SegmentsPortion;
    if (_CountToExcept > 0)
     then begin
      SetLength(ExceptSegments,(ExceptCount+_CountToExcept)*SizeOf(Integer));
      ExceptSegmentsSize:=ExceptCount;
      ExceptSegmentsPtr:=Pointer(@ExceptSegments[0]);
      _XIndexMin:=XIndexMin; _XIndexMax:=XIndexMax;
      _YIndexMin:=YIndexMin; _YIndexMax:=YIndexMax;
      X:=_XIndexMax;
      Y:=_YIndexMax;
      repeat
        if (_YIndexMin = _YIndexMax)
         then begin
          for X:=_XIndexMax downto _XIndexMin do if (ProcessSegmentPosition(X,_YIndexMin)) then GoTo SearchEnd; //. >>
          Break; //. ->
          end;
        if (_XIndexMin = _XIndexMax)
         then begin
          for Y:=_YIndexMax downto _YIndexMin do if (ProcessSegmentPosition(_XIndexMin,Y)) then GoTo SearchEnd; //. >>
          Break; //. ->
          end;
        while (X > _XIndexMin) do begin
          if (ProcessSegmentPosition(X,Y)) then GoTo SearchEnd; //. >>
          Dec(X);
          end;
        while (Y > _YIndexMin) do begin
          if (ProcessSegmentPosition(X,Y)) then GoTo SearchEnd; //. >>
          Dec(Y);
          end;
        while (X < _XIndexMax) do begin
          if (ProcessSegmentPosition(X,Y)) then GoTo SearchEnd; //. >>
          Inc(X);
          end;
        while (Y < _YIndexMax) do begin
          if (ProcessSegmentPosition(X,Y)) then GoTo SearchEnd; //. >>
          Inc(Y);
          end;
        Dec(X);
        Dec(Y);
        Inc(_XIndexMin); Dec(_XIndexMax);
        Inc(_YIndexMin); Dec(_YIndexMax);
      until ((_CountToExcept = 0) OR (_XIndexMin > _XIndexMax) OR (_YIndexMin > _YIndexMax));
      SearchEnd: 
      if (_CountToExcept <> 0) then Raise Exception.Create('duplicate hash code has been found'); //. =>
      Result:=true;
      end;
    end;
  end;

const
  SegmentsGeneration_MaxDepth = 2;
var
  ptrItem: pointer;
  TPI: integer;
  flLaysAreIndependent: boolean;
  ptrLevel: pointer;
  SegmentID: integer;
  flAllItemsExists: boolean;
  flDegenerate: boolean;
  BA: TByteArray;
  IL,ReceivedSegmentsList: TList;
  _ReflectorsList: TList;
  I: integer;
begin
try
if (Terminated) then Exit; //. ->
try
TSystemTTileServerVisualization(TypeSystem).Cash.Lock.BeginRead();
try
try
try
try
if (NOT TSystemTTileServerVisualization(TypeSystem).Cash.GetItem(Self.idObj, ptrItem)) then Exit; //. ->
//.
if (TItemTTileServerVisualizationCash(ptrItem^).ServerParsedData <> nil)
 then begin
  TPI:=TItemTTileServerVisualizationCash(ptrItem^).ServerParsedData.TileProviders_ItemIndex(TItemTTileServerVisualizationCash(ptrItem^).TileProviderID);
  flLaysAreIndependent:=((TPI >= 0) AND TItemTTileServerVisualizationCash(ptrItem^).ServerParsedData.TileProviders[TPI].flIndependentLevels);
  end
 else flLaysAreIndependent:=false;
//. processing ...
ptrLevel:=TItemTTileServerVisualizationCash(ptrItem^).Levels;
while (ptrLevel <> nil) do with TLevelItemOfTTileServerVisualizationCash(ptrLevel^) do begin
  Lock.BeginRead;
  try
  if (Params.id = idLevel) then Break; //. >
  finally
  Lock.EndRead;
  end;
  //. next level
  ptrLevel:=ptrNext;
  end;
if (ptrLevel = nil) then Exit; //. ->
//. to avoid often calls
for I:=1 to 2 do begin
  Sleep(100);
  if ((ptrCancelFlag <> nil) AND Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
  end;
//. try to restore segments from saved context
try
flAllItemsExists:=TSystemTTileServerVisualization(TypeSystem).Cash.Item_Level__RestoreSegmentsLocal(ptrItem, TItemTTileServerVisualizationCash(ptrItem^).TileProviderID, ptrLevel, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ptrCancelFlag,  IL, ExceptSegments);
except
  On E: EUnnecessaryExecuting do Raise; //. =>
  On E: Exception do begin
    EventLog.WriteMinorEvent('TileServerDeferredReflecting.Execute','Error of RestoreSegmentsLocal() of TileServer visualization (ID: '+IntToStr(idObj)+')',E.Message);
    Raise; //. =>
    end;
  end;
if (IL <> nil)
 then
  try
  flUpdateIsNeeded:=flUpdateIsNeeded OR (IL.Count > 0);
  finally
  IL.Destroy;
  end;
//.
if (NOT flAllItemsExists)
 then begin
  if (NOT flLaysAreIndependent)
   then begin
    try
    //. try to generate segments from down levels
    flAllItemsExists:=TSystemTTileServerVisualization(TypeSystem).Cash.Item_Level__GenerateSegmentsLocal(ptrItem, TItemTTileServerVisualizationCash(ptrItem^).TileProviderID, ptrLevel, XIndexMin,XIndexMax,YIndexMin,YIndexMax, SegmentsGeneration_MaxDepth, ptrCancelFlag,  IL, ExceptSegments);
    except
      On E: EUnnecessaryExecuting do Raise; //. =>
      On E: Exception do begin
        EventLog.WriteMinorEvent('TileServerDeferredReflecting.Execute','Error of GenerateSegmentsLocal() of TileServer visualization (ID: '+IntToStr(idObj)+')',E.Message);
        Raise; //. =>
        end;
      end;
    if (IL <> nil)
     then
      try
      flUpdateIsNeeded:=flUpdateIsNeeded OR (IL.Count > 0);
      finally
      IL.Destroy;
      end;
    end;
  //. segments getting from remote server
  if (NOT flAllItemsExists AND NOT TypeSystem.Space.flOffline)
   then begin
    //.
    if (ptrCancelFlag <> nil)
     then begin
      Sleep(0); //. exit from the current thread to alow the cancel flag to be set
      if (Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
      end;
    //.
    flDegenerate:=true;
    //.
    try
    flDegenerate:=(NOT ChangeSegmentsGettingForBestReflecting(XIndexMin,XIndexMax,YIndexMin,YIndexMax,{ref} ExceptSegments));
    except
      On E: Exception do begin
        EventLog.WriteMajorEvent('TileServerDeferredReflecting.Execute','Error of ChangeSegmentsGettingForBestReflecting()',E.Message);
        Raise; //. =>
        end;
      end;
    //.
    with TTileServerVisualizationFunctionality(TComponentFunctionality_Create(idTTileServerVisualization,TItemTTileServerVisualizationCash(ptrItem^).idObj)) do
    try
    try
    Level_GetSegments(TItemTTileServerVisualizationCash(ptrItem^).TileProviderID, idLevel, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ExceptSegments, BA);
    except
      On E: EUnnecessaryExecuting do Raise; //. =>
      On E: Exception do begin
        EventLog.WriteMinorEvent('TileServerDeferredReflecting.Execute','Error of Level_GetSegments(idLevel = '+IntToStr(idLevel)+') of TileServer visualization (ID: '+IntToStr(idObj)+')',E.Message);
        Raise; //. =>
        end;
      end;
    finally
    Release;
    end; 
    //.
    ReceivedSegmentsList:=TList.Create;
    try
    TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.BeginRead();
    try
    try
    TTileServerVisualizationCashItemLevel_PrepareSegmentsFromByteArray(TypeSystem, Self.idObj, TItemTTileServerVisualizationCash(ptrItem^).TileProviderID, ptrLevel,BA, ReceivedSegmentsList);
    except
      On E: EUnnecessaryExecuting do Raise; //. =>
      On E: Exception do begin
        EventLog.WriteMinorEvent('TileServerDeferredReflecting.Execute','Error of PrepareSegmentsFromByteArray(idLevel = '+IntToStr(idLevel)+') of TileServer visualization (ID: '+IntToStr(idObj)+')',E.Message);
        Raise; //. =>
        end;
      end;
    if (ReceivedSegmentsList.Count > 0)
     then begin
      //. update OpenGL segments textures
      try
      if (TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.flEnabled)
       then TSystemTTileServerVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentItemsTextures(ReceivedSegmentsList);
      except
        On E: EUnnecessaryExecuting do Raise; //. =>
        On E: Exception do begin
          EventLog.WriteMinorEvent('TileServerDeferredReflecting.Execute','Error of GenerateSegmentItemsTextures() of TileServer visualization (ID: '+IntToStr(idObj)+')',E.Message);
          Raise; //. =>
          end;
        end;
      flUpdateIsNeeded:=true;
      end;
    finally
    TLevelItemOfTTileServerVisualizationCash(ptrLevel^).Lock.EndRead();
    end;
    finally
    ReceivedSegmentsList.Destroy;
    end;
    if ({///? (NOT flLaysAreIndependent) AND }flDegenerate)
     then begin
      //. empty segments degeneration
      try
      if (TSystemTTileServerVisualization(TypeSystem).Cash.Item_Level__DegenerateSegmentsLocal(ptrItem, TItemTTileServerVisualizationCash(ptrItem^).TileProviderID, ptrLevel, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ptrCancelFlag,  IL))
       then
        try
        flUpdateIsNeeded:=flUpdateIsNeeded OR (IL.Count > 0);
        finally
        IL.Destroy;
        end;
      except
        On E: EUnnecessaryExecuting do Raise; //. =>
        On E: Exception do begin
          EventLog.WriteMinorEvent('TileServerDeferredReflecting.Execute','Error of DegenerateSegmentsLocal(idLevel = '+IntToStr(idLevel)+') of TileServer visualization (ID: '+IntToStr(idObj)+')',E.Message);
          Raise; //. =>
          end;
        end;
      end;
    end;
  end;
finally
TypeSystem.TileServerDeferredReflectingList.Remove(Self);
end;
except
  On E: EUnnecessaryExecuting do
    flUpdateIsNeeded:=true;
  else
    Raise; //. =>
  end;
//. update reflectors
try
if (flUpdateIsNeeded)
 then begin
  _ReflectorsList:=ReflectorsList.LockList;
  try
  for I:=0 to _ReflectorsList.Count-1 do TReflector(_ReflectorsList[I]).Reflecting.RevisionReflect(ptrObj,actRefresh);
  finally
  ReflectorsList.UnlockList;
  end;
  end;
except
  On E: EUnnecessaryExecuting do Raise; //. =>
  On E: Exception do begin
    EventLog.WriteMinorEvent('TileServerDeferredReflecting.Execute','Error of RevisionReflect() of TileServer visualization (ID: '+IntToStr(idObj)+')',E.Message);
    Raise; //. =>
    end;
  end;
finally
FreeAndNil(ReflectorsList);
end;
finally
TSystemTTileServerVisualization(TypeSystem).Cash.Lock.EndRead();
end;
except
  On E: EUnnecessaryExecuting do Raise; //. =>
  On E: Exception do EventLog.WriteMinorEvent('TileServerDeferredReflecting.Execute','Error of processing TileServer visualization (ID: '+IntToStr(idObj)+')',E.Message);
  end;
finally
flFinished:=true;
//. provide visualization with persist level for smart reflecting 
TSystemTTileServerVisualization(TypeSystem).Cash.PersistLevelsProviding.Provide();
end;
end;

function TTileServerDeferredReflecting.ReflectorsList_Add(const Reflector: TReflector): boolean;
var
  _ReflectorsList: TList;
begin
if (Reflector = nil) then Exit; //. -> 
_ReflectorsList:=ReflectorsList.LockList;
try
if (_ReflectorsList.IndexOf(Reflector) = -1) then _ReflectorsList.Add(Reflector);
Result:=true;
finally
ReflectorsList.UnlockList;
end;
end;










//. Measurement Object
Constructor TSystemTMeasurementObject.Create;
begin
CreateNew(idTMeasurementObject,tnTMeasurementObject,TTMeasurementObjectFunctionality);
end;







//. Area-Notification Server
Constructor TSystemTAreaNotificationServer.Create;
begin
CreateNew(idTAreaNotificationServer,tnTAreaNotificationServer,TTAreaNotificationServerFunctionality);
end;







//.  MODELServer-Visualization

{TMODELServerVisualizationDeferredReflecting}
Constructor TMODELServerVisualizationDeferredReflecting.Create(const pTypeSystem: TSystemTMODELServerVisualization; const pidObj: integer; const pptrObj: TPtr; const pParams: TWindowViewDataParams; const pptrCancelFlag: pointer);
begin
TypeSystem:=pTypeSystem;
idObj:=pidObj;
ptrObj:=pptrObj;
Params:=pParams;
ptrCancelFlag:=pptrCancelFlag;
//.
flFinished:=false;
FreeOnTerminate:=true;
flUpdateIsNeeded:=false;
TypeSystem.DeferredReflectingList.Add(Self);
Inherited Create(true);
Priority:=tpLowest;
end;

procedure TMODELServerVisualizationDeferredReflecting.Execute;
{
  if you change this update TMODELServerVisualizationFunctionality.ReflectOnCanvas.SupplyWithWindowViewData() as well
}
const
  Server_UserName = 'Anonymous';
  Server_UserPassword = 'ra3tkq';
var
  I: integer;
  ptrItem: pointer;
  _ServerURL: string;
  SpaceProvider: ISpaceProvider;
  _Data: TByteArray;
  _WindowViewData: TWindowViewData;
begin    
try
try
if (Terminated) then Exit; //. ->
try
try
//. to avoid often calls
for I:=1 to 5 do begin
  Sleep(100);
  if ((ptrCancelFlag <> nil) AND Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
  end;
//.
_ServerURL:='http://'+Params.ServerURL+'/SpaceSOAPServer.dll';
SpaceProvider:=GetISpaceProvider(_ServerURL);
with Params.Window do SpaceProvider.GetSpaceWindowBitmap(Server_UserName,Server_UserPassword, X0,Y0,X1,Y1,X2,Y2,X3,Y3, Params.InvisibleLayNumbersArray, Params.VisibleFactor, Params.DynamicHints_VisibleFactor, Xmx-Xmn,Ymx-Ymn,{out} _Data);
//.
_WindowViewData:=TWindowViewData.Create(Params,_Data);
try
//.
TypeSystem.Lock.Enter;
try
ptrItem:=TSystemTMODELServerVisualization(TypeSystem).Cash.GetPtrItem(idObj);
if (ptrItem = nil)
 then begin
  _WindowViewData.Destroy;
  Exit; //. ->
  end;
with TItemTMODELServerVisualizationCash(ptrItem^) do begin
FreeAndNil(WindowViewData);
WindowViewData:=_WindowViewData;
end;
finally
TypeSystem.Lock.Leave;
end;
flUpdateIsNeeded:=true;
except
  _WindowViewData.Destroy;
  Raise; //. =>
  end;
finally
TypeSystem.DeferredReflectingList.Remove(Self);
end;
except
  On E: EUnnecessaryExecuting do
    flUpdateIsNeeded:=true;
  else
    Raise; //. =>
  end;
//. update reflector
try
if (flUpdateIsNeeded AND (Params.Reflector <> nil)) then Params.Reflector.Reflecting.RevisionReflect(ptrObj,actRefresh);
except
  On E: EUnnecessaryExecuting do Raise; //. =>
  On E: Exception do begin
    EventLog.WriteMinorEvent('MODELServerVisualizationDeferredReflecting.Execute','Error of RevisionReflect() of MODELServer-visualization (ID: '+IntToStr(idObj)+')',E.Message);
    Raise; //. =>
    end;
  end;
except
  On E: EUnnecessaryExecuting do Raise; //. =>
  On E: Exception do EventLog.WriteMinorEvent('MODELServerVisualizationDeferredReflecting.Execute','Error of processing MODELServer visualization (ID: '+IntToStr(idObj)+')',E.Message);
  end;
finally
flFinished:=true;
end;
end;


{TSystemTMODELServerVisualization}
Constructor TSystemTMODELServerVisualization.Create;
var
  FN: string;
  MS: TMemoryStream;
begin
CreateNew(idTMODELServerVisualization,tnTMODELServerVisualization,TTMODELServerVisualizationFunctionality);
DeferredReflectingList:=TThreadList.Create();
//.
VisualizationIsNotLoadedBMP:=TBitmap.Create;
VisualizationIsNotLoadedBMP.HandleType:=bmDIB;
VisualizationIsNotLoadedBMP.PixelFormat:=pf24bit;
FN:='TypesDef\MODELServerVisualization\VisualizationIsNotLoaded.jpg';
if (FileExists(FN))
 then begin
  MS:=TMemoryStream.Create();
  try
  MS.LoadFromFile(FN);
  GetBitmapFromJPEGStream(MS,VisualizationIsNotLoadedBMP);
  finally
  MS.Destroy;
  end;
  end;
//.
if (Enabled) then Cash:=TTMODELServerVisualizationCash.Create(Self);
end;

Destructor TSystemTMODELServerVisualization.Destroy;
begin
Cash.Free;
VisualizationIsNotLoadedBMP.Free;
DeferredReflectingList.Free;
Inherited;
end;

procedure TSystemTMODELServerVisualization.Initialize;
begin
if (Cash <> nil) then Cash.Update;
end;

procedure TSystemTMODELServerVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTMODELServerVisualization.DoOnReflectorRemoval(const pReflector: TAbstractReflector);
var
  DeferredReflectings: TList;
  I: integer;
begin
DeferredReflectings:=DeferredReflectingList.LockList();
try
for I:=0 to DeferredReflectings.Count-1 do with TMODELServerVisualizationDeferredReflecting(DeferredReflectings[I]) do begin
  if (Params.Reflector = pReflector)
   then begin
    Params.Reflector:=nil;
    Exit; //. ->
    end;
  end;
finally
DeferredReflectingList.UnlockList();
end;
end;

procedure TSystemTMODELServerVisualization.Caching_Start;
begin
end;

procedure TSystemTMODELServerVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTMODELServerVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTMODELServerVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTMODELServerVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TWindowViewData
Constructor TWindowViewData.Create(const pParams: TWindowViewDataParams; const pData: TByteArray);
begin
Inherited Create();
Params:=pParams;
Data:=TMemoryStream.Create;
if (Length(pData) > 0) then Data.Write(Pointer(@pData[0])^,Length(pData));
end;

Destructor TWindowViewData.Destroy;
begin
Data.Free;
Inherited;
end;

class function TWindowViewData.IsWindowTheSameTo(const Params,pWindowParams: TWindowViewDataParams): boolean;

  function ArraysAreTheSame(const A,A1: TByteArray): boolean;
  var
    I: integer;
  begin
  if (Length(A) <> Length(A1))
   then begin
    Result:=false;
    Exit; //. ->
    end;
  for I:=0 to Length(A)-1 do
    if (A[I] <> A1[I])
     then begin
      Result:=false;
      Exit; //. ->
      end;
  Result:=true;
  end;

begin
Result:=(
          ((Params.Window.Xmx-Params.Window.Xmn) = (pWindowParams.Window.Xmx-pWindowParams.Window.Xmn)) AND ((Params.Window.Ymx-Params.Window.Ymn) = (pWindowParams.Window.Ymx-pWindowParams.Window.Ymn)) AND
          (
            ((Params.Window.X0 = pWindowParams.Window.X0) AND (Params.Window.Y0 = pWindowParams.Window.Y0)) AND
            ((Params.Window.X1 = pWindowParams.Window.X1) AND (Params.Window.Y1 = pWindowParams.Window.Y1)) AND
            ((Params.Window.X2 = pWindowParams.Window.X2) AND (Params.Window.Y2 = pWindowParams.Window.Y2)) AND
            ((Params.Window.X3 = pWindowParams.Window.X3) AND (Params.Window.Y3 = pWindowParams.Window.Y3))
          ) AND
          (Params.VisibleFactor = pWindowParams.VisibleFactor) AND
          (Params.DynamicHints_VisibleFactor = pWindowParams.DynamicHints_VisibleFactor) AND
          (ArraysAreTheSame(Params.InvisibleLayNumbersArray,pWindowParams.InvisibleLayNumbersArray)) AND
          (Params.ServerURL = pWindowParams.ServerURL)
        );
end;

function TWindowViewData.IsWindowTheSameTo(const pWindowParams: TWindowViewDataParams): boolean;
begin
Result:=IsWindowTheSameTo(Params,pWindowParams);
end;


//. TTMODELServerVisualizationCash
Constructor TTMODELServerVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTMODELServerVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTMODELServerVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while (FItems <> nil) do begin
  ptrDelItem:=FItems;
  FItems:=TItemTMODELServerVisualizationCash(ptrDelItem^).ptrNext;
  with TItemTMODELServerVisualizationCash(ptrDelItem^) do begin
  ServerURL:='';
  FreeAndNil(WindowViewData);
  end;
  FreeMem(ptrDelItem,SizeOf(TItemTMODELServerVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTMODELServerVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TMODELServerVisualizationFunctionality;
  DS: TMemoryStream;
  CDT: TComponentFileType;
  WS,WS1,WS2: WideString;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if (List.Count = 0) then Exit; //. ->
if (NOT Space.flActionsGroupCall OR (List.Count = 1))
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTMODELServerVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTMODELServerVisualizationCash), 0);
    try
    with TItemTMODELServerVisualizationCash(ptrNewItem^) do begin
    CF:=TMODELServerVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    ServerURL:=CF.ServerURL;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTMODELServerVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTMODELServerVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTMODELServerVisualizationCash), 0);
    with TItemTMODELServerVisualizationCash(ptrNewItem^) do begin
    CF:=TMODELServerVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try
    ServerURL:=CF.ServerURL;
    except
      on E: EActionsGroup do ;
      else Raise; //. =>
      end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TMODELServerVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,TItemTMODELServerVisualizationCash(ItemsList[I]^).idObj)) do
    try
    try
    TItemTMODELServerVisualizationCash(ItemsList[I]^).ServerURL:=ServerURL;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if (ItemsList[I] <> nil) then begin
   TItemTMODELServerVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;

procedure TTMODELServerVisualizationCash.Update;
begin
Empty;
end;

function TTMODELServerVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if (ptrItem = nil)
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTMODELServerVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while (Pointer(ptrptrItem^) <> nil) do with TItemTMODELServerVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if (idObj = pidObj)
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTMODELServerVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit; //. ->
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTMODELServerVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTMODELServerVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTMODELServerVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTMODELServerVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TMODELServerVisualizationFunctionality;
  begin
  try
  with TItemTMODELServerVisualizationCash(ptrItem^) do begin
  CF:=TMODELServerVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  ServerURL:=CF.ServerURL;
  FreeAndNil(WindowViewData);
  finally
  CF.Release;
  end;
  end;
  except
    end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTMODELServerVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTMODELServerVisualizationCash), 0);
  with TItemTMODELServerVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTMODELServerVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTMODELServerVisualizationCash), 0);
    with TItemTMODELServerVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTMODELServerVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TMODELServerVisualizationFunctionality;
  begin
  with TItemTMODELServerVisualizationCash(ptrItem^) do begin
  CF:=TMODELServerVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  ServerURL:=CF.ServerURL;
  FreeAndNil(WindowViewData);
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTMODELServerVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTMODELServerVisualizationCash(ptrItem^) do begin
  ServerURL:=Item.ServerURL;
  FreeAndNil(WindowViewData);
  end;
  end;

var
  Item: TItemTMODELServerVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTMODELServerVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTMODELServerVisualizationCash), 0);
  with TItemTMODELServerVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTMODELServerVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTMODELServerVisualizationCash), 0);
    with TItemTMODELServerVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTMODELServerVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTMODELServerVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if (idObj = pidObj)
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTMODELServerVisualizationCash(ptrDelItem^).ptrNext;
    with TItemTMODELServerVisualizationCash(ptrDelItem^) do begin
    ServerURL:='';
    FreeAndNil(WindowViewData);
    end;
    FreeMem(ptrDelItem,SizeOf(TItemTMODELServerVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTMODELServerVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTMODELServerVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);
var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTMODELServerVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('ServerURL');      PropNode.nodeTypedValue:=ServerURL;       ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTMODELServerVisualizationCash.LoadItems(Node: IXMLDOMNode);
var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _ServerURL: string;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _ServerURL:=ItemNode.selectSingleNode('ServerURL').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTMODELServerVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTMODELServerVisualizationCash), 0);
  with TItemTMODELServerVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  ServerURL:=_ServerURL;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;




//. Double variable
Constructor TSystemTDoubleVar.Create;
begin
CreateNew(idTDoubleVar,tnTDoubleVar,TTDoubleVarFunctionality);
end;








//. Int32 variable
Constructor TSystemTInt32Var.Create;
begin
CreateNew(idTInt32Var,tnTInt32Var,TTInt32VarFunctionality);
end;








//. URL component
Constructor TSystemTURL.Create;
begin
CreateNew(idTURL,tnTURL,TTURLFunctionality);
end;








//. Pattern-визуализация
{TSystemTPatternVisualization}
Constructor TSystemTPatternVisualization.Create;
begin
CreateNew(idTPatternVisualization,tnTPatternVisualization,TTPatternVisualizationFunctionality);
if Enabled then Cash:=TTPatternVisualizationCash.Create(Self);
end;

Destructor TSystemTPatternVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTPatternVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTPatternVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTPatternVisualization.Caching_Start;
begin
end;

procedure TSystemTPatternVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTPatternVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTPatternVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTPatternVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;

function TSystemTPatternVisualization.CreateContext(const Owner: TComponentContext): TComponentTypeContext;
begin
Result:=Inherited CreateContext(Owner);
Result.DataFlags:=Result.DataFlags+COMPONENT_DATA_FLAG_NAME;
end;

function TSystemTPatternVisualization.InplaceHintEnabled(): boolean;
begin
Result:=true;
end;


//. TPatternVisualizationDATAFileRepository
Constructor TPatternVisualizationDATAFileRepository.Create;
begin
Inherited Create;
Lock:=TCriticalSection.Create;
DATAFiles:=nil;
end;

Destructor TPatternVisualizationDATAFileRepository.Destroy;
begin
Clear();
Lock.Free;
Inherited;
end;

procedure TPatternVisualizationDATAFileRepository.Clear;
var
  ptrRemoveItem: pointer;
begin
Lock.Enter;
try
while (DATAFiles <> nil) do begin
  ptrRemoveItem:=DATAFiles;
  DATAFiles:=TPatternVisualizationDATAFile(ptrRemoveItem^).ptrNext;
  //.
  TPatternVisualizationDATAFile(ptrRemoveItem^).DATA.Free;
  FreeMem(ptrRemoveItem,SizeOf(TPatternVisualizationDATAFile));
  end;
finally
Lock.Leave;
end;
end;

function TPatternVisualizationDATAFileRepository.DATAFile_Exists(const pidDATAFile: integer): boolean;
var
  ptrItem: pointer;
begin
Result:=false;
Lock.Enter;
try
ptrItem:=DATAFiles;
while (ptrItem <> nil) do with TPatternVisualizationDATAFile(ptrItem^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    Result:=true;
    Exit; //. ->
    end;
  ptrItem:=ptrNext;
  end;
finally
Lock.Leave;
end;
end;

function TPatternVisualizationDATAFileRepository.DATAFile_AddRef(const pidDATAFile: integer): boolean;
var
  ptrItem: pointer;
begin
Result:=false;
Lock.Enter;
try
ptrItem:=DATAFiles;
while (ptrItem <> nil) do with TPatternVisualizationDATAFile(ptrItem^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    Inc(RefCounter);
    Result:=true;
    Exit; //. ->
    end;
  ptrItem:=ptrNext;
  end;
finally
Lock.Leave;
end;
end;

function TPatternVisualizationDATAFileRepository.DATAFile_Release(const pidDATAFile: integer): integer;
var
  ptrptrItem: pointer;
  ptrRemoveItem: pointer;
begin
Result:=0;
Lock.Enter;
try
ptrptrItem:=@DATAFiles;
while (Pointer(ptrptrItem^) <> nil) do with TPatternVisualizationDATAFile(Pointer(ptrptrItem^)^) do  
  if (idDATAFile = pidDATAFile)
   then begin
    Dec(RefCounter);
    if (RefCounter = 0)
     then begin
      ptrRemoveItem:=Pointer(ptrptrItem^);
      Pointer(ptrptrItem^):=TPatternVisualizationDATAFile(ptrRemoveItem^).ptrNext;
      //. free item
      TPatternVisualizationDATAFile(ptrRemoveItem^).DATA.Free;
      FreeMem(ptrRemoveItem,SizeOf(TPatternVisualizationDATAFile));
      end;
    Result:=RefCounter;
    Exit; //. ->
    end
   else ptrptrItem:=@ptrNext;
finally
Lock.Leave;
end;
end;

function TPatternVisualizationDATAFileRepository.AddDATAFile(const pidDATAFile: integer; const DATAFileDATA: TBitmap): boolean;
var
  ptrItem: pointer;
  ptrNewItem: pointer;
begin
Result:=false;
Lock.Enter;
try
ptrItem:=DATAFiles;
while (ptrItem <> nil) do with TPatternVisualizationDATAFile(ptrItem^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    Inc(RefCounter);
    //.
    FreeAndNil(DATA);
    DATA:=DATAFileDATA;
    //.
    Result:=true;
    Exit; //. ->
    end;
  ptrItem:=ptrNext;
  end;
GetMem(ptrNewItem,SizeOf(TPatternVisualizationDATAFile));
with TPatternVisualizationDATAFile(ptrNewItem^) do begin
ptrNext:=DATAFiles;
RefCounter:=1;
idDATAFile:=pidDATAFile;
DATA:=DATAFileDATA;
flSaved:=false;
end;
DATAFiles:=ptrNewItem;
Result:=true;
finally
Lock.Leave;
end;
end;

function TPatternVisualizationDATAFileRepository.DATAFile_Lock(const pidDATAFile: integer; out DATAFilePtr: pointer): boolean;
var
  ptrptrItem: pointer;
begin
Result:=false;
Lock.Enter;
try
ptrptrItem:=@DATAFiles;
while (Pointer(ptrptrItem^) <> nil) do with TPatternVisualizationDATAFile(Pointer(ptrptrItem^)^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    DATAFilePtr:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TPatternVisualizationDATAFile(DATAFilePtr^).ptrNext:=DATAFiles;
    DATAFiles:=DATAFilePtr;
    Result:=true;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
finally
if (NOT Result) then Lock.Leave;
end;
end;

procedure TPatternVisualizationDATAFileRepository.DATAFile_Unlock(const DATAFilePtr: pointer);
begin
Lock.Leave;
end;


//. TTPatternVisualizationCash
Constructor TTPatternVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
DATAFileRepository:=TPatternVisualizationDATAFileRepository.Create;
FItems:=nil;
end;

destructor TTPatternVisualizationCash.Destroy;
begin
Empty();
DATAFileRepository.Free;
Inherited;
end;

procedure TTPatternVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTPatternVisualizationCash(ptrDelItem^).ptrNext;
  //.
  DATAFileRepository.DATAFile_Release(TItemTPatternVisualizationCash(ptrDelItem^).idDATAFile);
  FreeMem(ptrDelItem,SizeOf(TItemTPatternVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPatternVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TPatternVisualizationFunctionality;
  DS: TMemoryStream;
  CDT: TComponentFileType;
  BMPDATA: TBitmap;
  ptrActionsGroup: pointer;
  ItemsList: TList;
  GetDATAMask: array of boolean;
begin
if (List.Count = 0) then Exit; //. ->
if (NOT Space.flActionsGroupCall OR (List.Count = 1))
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTPatternVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTPatternVisualizationCash), 0);
    with TItemTPatternVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    CF:=TPatternVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    idDATAFile:=CF.DATAFileID;
    if (idDATAFile <> 0)
     then begin
      if (NOT DATAFileRepository.DATAFile_AddRef(idDATAFile))
       then begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        BMPDATA:=TBitmap.Create;
        try
        BMPDATA.LoadFromStream(DS);
        except
          BMPDATA.Destroy;
          Raise; //. =>
          end;
        if (NOT DATAFileRepository.AddDATAFile(idDATAFile,BMPDATA)) then BMPDATA.Destroy;
        finally
        DS.Destroy;
        end;
        end;
      end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTPatternVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTPatternVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTPatternVisualizationCash), 0);
    with TItemTPatternVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    CF:=TPatternVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try idDATAFile:=CF.DATAFileID; except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTPatternVisualizationCash(ItemsList[I]^) do with TPatternVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    idDATAFile:=DATAFileID;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  ActionsGroups.ActionsGroup_Start(ptrActionsGroup);
  try
  SetLength(GetDATAMask,ItemsList.Count);
  for I:=0 to ItemsList.Count-1 do if (ItemsList[I] <> nil) then with TItemTPatternVisualizationCash(ItemsList[I]^) do with TPatternVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if (idDATAFile <> 0)
     then
      if (DATAFileRepository.DATAFile_AddRef(idDATAFile))
       then GetDATAMask[I]:=false
       else begin
        try GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize); except on E: EActionsGroup do ; else Raise; end;
        GetDATAMask[I]:=true;
        end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item DATAFile of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(ItemsList[I]))+') could not be prepared for caching',E.Message);
      end;
    finally
    Release;
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do if (ItemsList[I] <> nil) then with TItemTPatternVisualizationCash(ItemsList[I]^) do with TPatternVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if ((idDATAFile <> 0) AND GetDATAMask[I])
     then begin
      GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
      try
      BMPDATA:=TBitmap.Create;
      try
      BMPDATA.LoadFromStream(DS);
      except
        BMPDATA.Destroy;
        Raise; //. =>
        end;
      if (NOT DATAFileRepository.AddDATAFile(idDATAFile,BMPDATA)) then BMPDATA.Destroy;
      finally
      DS.Destroy;
      end;
      end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item DATAFile of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(ItemsList[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if (ItemsList[I] <> nil) then begin
   TItemTPatternVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;


procedure TTPatternVisualizationCash.Update;
begin
Empty;
end;

function TTPatternVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTPatternVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTPatternVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTPatternVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTPatternVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPatternVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTPatternVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTPatternVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TPatternVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
  begin
  with TItemTPatternVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TPatternVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  _idDATAFile:=CF.DATAFileID;
  if (idDATAFile <> _idDATAFile)
   then begin
    //. free last
    FreeAndNil(ImageDATA);
    //.
    ???if (_idDATAFile <> 0) then if (NOT GetComponentFile(_idDATAFile, DS)) then CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
    idDATAFile:=_idDATAFile;
    try
    ImageDATA:=TBitmap.Create;
    ImageDATA.LoadFromStream(DS);
    finally
    DS.Destroy;
    end;
    end;
  //.
  FreeAndNil(DATA);
  CF.GetPrivateDATA(DATA,Space.Configuration.VisualizationMaxSize);
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTPatternVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTPatternVisualizationCash), 0);
  with TItemTPatternVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  idDATAFile:=0;
  ImageDATA:=nil;
  DATA:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTPatternVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTPatternVisualizationCash), 0);
    with TItemTPatternVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    idDATAFile:=0;
    ImageDATA:=nil;
    DATA:=nil;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTPatternVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TPatternVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
    ImageDATA: TBitmap;
  begin
  with TItemTPatternVisualizationCash(ptrItem^) do begin
  //. updating item
  try
  CF:=TPatternVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  _idDATAFile:=CF.DATAFileID;
  if (idDATAFile <> _idDATAFile)
   then begin
    //. free last
    if (idDATAFile <> 0) then DATAFileRepository.DATAFile_Release(idDATAFile);
    //.
    idDATAFile:=_idDATAFile;
    if (idDATAFile <> 0)
     then
      if (NOT DATAFileRepository.DATAFile_AddRef(idDATAFile))
       then begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        ImageDATA:=TBitmap.Create;
        try
        ImageDATA.LoadFromStream(DS);
        except
          ImageDATA.Destroy;
          Raise; //. =>
          end;
        if (NOT DATAFileRepository.AddDATAFile(idDATAFile,ImageDATA)) then ImageDATA.Destroy;
        finally
        DS.Destroy;
        end;
        end;
    end;
  finally
  CF.Release;
  end;
  except
    if (idDATAFile <> 0) then DATAFileRepository.DATAFile_Release(idDATAFile);
    Raise; //. =>
    end;
  end;
  end;

  procedure CopyToItem(const ptrItem: pointer; var Item: TItemTPatternVisualizationCash);
  begin
  Item:=TItemTPatternVisualizationCash(ptrItem^);
  //. copy item reference fields
  if (Item.idDATAFile <> 0) then DATAFileRepository.DATAFile_AddRef(Item.idDATAFile);
  end;

  procedure MoveItem(const Item: TItemTPatternVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTPatternVisualizationCash(ptrItem^) do begin
  if (idDATAFile <> Item.idDATAFile)
   then begin
    if (idDATAFile <> 0) then DATAFileRepository.DATAFile_Release(idDATAFile);
    //.
    idDATAFile:=Item.idDATAFile;
    if (idDATAFile <> 0) then DATAFileRepository.DATAFile_AddRef(idDATAFile);
    end
   else if (Item.idDATAFile <> 0) then DATAFileRepository.DATAFile_Release(Item.idDATAFile);
  end;
  end;

  procedure FreeItem(var Item: TItemTPatternVisualizationCash);
  begin
  if (Item.idDATAFile <> 0) then DATAFileRepository.DATAFile_Release(Item.idDATAFile);
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
  Item: TItemTPatternVisualizationCash;
begin
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTPatternVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTPatternVisualizationCash), 0);
  with TItemTPatternVisualizationCash(ptrNewItem^) do begin
  idObj:=pidObj;
  idDATAFile:=0;
  end;
  UpdateItem(ptrNewItem);
  //.
  TypeSystem.Lock.Enter;
  try
  TItemTPatternVisualizationCash(ptrNewItem^).ptrNext:=FItems;
  FItems:=ptrNewItem;
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
opUpdate: begin
  TypeSystem.Lock.Enter;
  try
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil) then CopyToItem(ptrUpdateItem, Item);
  finally
  TypeSystem.Lock.Leave;
  end;
  if (ptrUpdateItem <> nil)
   then begin    
    UpdateItem(@Item);
    //.
    TypeSystem.Lock.Enter;
    try
    ptrUpdateItem:=GetPtrItem(pidObj);
    if (ptrUpdateItem <> nil)
     then MoveItem(Item,ptrUpdateItem)
     else FreeItem(Item);
    finally
    TypeSystem.Lock.Leave;
    end;
    end
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTPatternVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTPatternVisualizationCash), 0);
    with TItemTPatternVisualizationCash(ptrNewItem^) do begin
    idObj:=pidObj;
    idDATAFile:=0;
    end;
    UpdateItem(ptrNewItem);
    //.
    TypeSystem.Lock.Enter;
    try
    TItemTPatternVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end;
  end;
opDestroy: begin
  TypeSystem.Lock.Enter;
  try
  RemoveItem(pidObj);
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
end;
end;

procedure TTPatternVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTPatternVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTPatternVisualizationCash(ptrDelItem^).ptrNext;
    //.
    DATAFileRepository.DATAFile_Release(TItemTPatternVisualizationCash(ptrDelItem^).idDATAFile);
    FreeMem(ptrDelItem,SizeOf(TItemTPatternVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTPatternVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPatternVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetDATA(const ImageDATA: TBitmap): OLEVariant;
  var
    MS: TMemoryStream;
    DATAPtr: pointer;
  begin
  MS:=TMemoryStream.Create;
  with MS do
  try
  if (ImageDATA <> nil)
   then begin
    ImageDATA.SaveToStream(MS);
    Position:=0;
    end;
  Result:=VarArrayCreate([0,Size-1],varByte);
  DATAPtr:=VarArrayLock(Result);
  try
  Read(DATAPtr^,Size);
  finally
  VarArrayUnLock(Result);
  end;
  finally
  Destroy;
  end;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
  //.
  DATAFilePtr: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTPatternVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('idDATAFile');       PropNode.nodeTypedValue:=idDATAFile;    ItemNode.appendChild(PropNode);
  //.
  if (DATAFIleRepository.DATAFile_Lock(idDATAFile,{out} DATAFilePtr))
   then with TPatternVisualizationDATAFile(DATAFilePtr^) do
    try
    if (NOT flSaved)
     then begin
      PropNode:=Document.CreateElement('ImageDATA');
      PropNode.Set_dataType('bin.base64');
      PropNode.nodeTypedValue:=GetDATA(DATA);
      ItemNode.appendChild(PropNode);
      //.
      flSaved:=true;
      end;
    finally
    DATAFIleRepository.DATAFile_Unlock(DATAFilePtr);
    end;
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPatternVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetDATA(DATA: Variant; out ImageDATA: TBitmap);
  var
    DATASize: integer;
    DATAPtr: pointer;
    MS: TMemoryStream;
  begin
  ImageDATA:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    MS:=TMemoryStream.Create;
    with MS do
    try
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    ImageDATA:=TBitmap.Create;
    ImageDATA.LoadFromStream(MS);
    finally
    Destroy;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(ImageDATA);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  ImageDATANode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _idDATAFile: integer;
  _ImageDATA: Variant;
  //.
  ImageDATA: TBitmap;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _idDATAFile:=ItemNode.selectSingleNode('idDATAFile').nodeTypedValue;
  ImageDATANode:=ItemNode.selectSingleNode('ImageDATA');
  if (ImageDATANode <> nil)
   then _ImageDATA:=ImageDATANode.nodeTypedValue
   else _ImageDATA:=null;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTPatternVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTPatternVisualizationCash), 0);
  with TItemTPatternVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  idDATAFile:=_idDATAFile;
  if (idDATAFile <> 0) 
   then begin
    if (NOT DATAFileRepository.DATAFile_AddRef(idDATAFile))
     then begin
      if (_ImageDATA <> null)
       then begin
        SetDATA(_ImageDATA, ImageDATA);
        if (NOT DATAFileRepository.AddDATAFile(idDATAFile,ImageDATA)) then ImageDATA.Destroy;
        end
       else EventLog.WriteMinorEvent('TTPatternVisualizationCache.LoadItems()','Could not restore PatternVisualization item ('+IntToStr(id)+') from stored context','DATAFile (ID: '+IntToStr(idDATAFile)+') was not found in repository');
      end;
    end;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;



//. Spline-visualization
{TSystemTSPLVisualization}
Constructor TSystemTSPLVisualization.Create;
begin
CreateNew(idTSPLVisualization,tnTSPLVisualization,TTSPLVisualizationFunctionality);
if Enabled then Cash:=TTSPLVisualizationCash.Create(Self);
end;

Destructor TSystemTSPLVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTSPLVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTSPLVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTSPLVisualization.Caching_Start;
begin
end;

procedure TSystemTSPLVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTSPLVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTSPLVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTSPLVisualization.Context_GetItems(out IDs: TIDArray); 
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTSPLVisualizationCash
Constructor TTSPLVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTSPLVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTSPLVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTSPLVisualizationCash(ptrDelItem^).ptrNext;
  TItemTSPLVisualizationCash(ptrDelItem^).SPLDATA.Free;
  FreeMem(ptrDelItem,SizeOf(TItemTSPLVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTSPLVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TSPLVisualizationFunctionality;
  FT: integer;
  BA: TByteArray;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTSPLVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTSPLVisualizationCash), 0);
    with TItemTSPLVisualizationCash(ptrNewItem^) do begin
    SPLType:=stSimple;
    SPLDATA:=nil;
    CF:=TSPLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetParams(FT,BA);
    SPLType:=TSPLVisualizationType(FT);
    ByteArray_CreateStream(BA, SPLDATA);
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTSPLVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTSPLVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTSPLVisualizationCash), 0);
    with TItemTSPLVisualizationCash(ptrNewItem^) do begin
    SPLType:=stSimple;
    SPLDATA:=nil;
    CF:=TSPLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try CF.GetParams(FT,BA); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTSPLVisualizationCash(ItemsList[I]^) do with TSPLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    GetParams(FT,BA);
    SPLType:=TSPLVisualizationType(FT);
    ByteArray_CreateStream(BA, SPLDATA);
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTSPLVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;


procedure TTSPLVisualizationCash.Update;
begin
Empty;
end;

function TTSPLVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTSPLVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTSPLVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTSPLVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTSPLVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTSPLVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTSPLVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTSPLVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(ptrItem: pointer);
  var
    CF: TSPLVisualizationFunctionality;
    BA: TByteArray;
    FT: integer;
  begin
  with TItemTSPLVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TSPLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  FreeAndNil(SPLDATA);
  //.
  CF.GetParams(FT,BA);
  SPLType:=TSPLVisualizationType(FT);
  ByteArray_CreateStream(BA, SPLDATA);
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTSPLVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTSPLVisualizationCash), 0);
  with TItemTSPLVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  SPLType:=ftContrasting;
  SPLDATA:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if ptrUpdateItem <> nil then UpdateItem(ptrUpdateItem) else UpdateLocal(pidObj,opCreate);
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTSPLVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TSPLVisualizationFunctionality;
    BA: TByteArray;
    FT: integer;
  begin
  with TItemTSPLVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TSPLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  SPLType:=stSimple;
  FreeAndNil(SPLDATA);
  //.
  CF.GetParams(FT,BA);
  SPLType:=TSPLVisualizationType(FT);
  ByteArray_CreateStream(BA, SPLDATA);
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTSPLVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTSPLVisualizationCash(ptrItem^) do begin
  FreeAndNil(SPLDATA);
  //.
  SPLType:=Item.SPLType;
  SPLDATA:=Item.SPLDATA;
  end;
  end;

var
  Item: TItemTSPLVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTSPLVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTSPLVisualizationCash), 0);
  with TItemTSPLVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  SPLType:=stSimple;
  SPLDATA:=nil;
  end;
  //.
  MoveItem(Item,ptrNewItem);
  //.
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTSPLVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTSPLVisualizationCash), 0);
    with TItemTSPLVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    SPLType:=stSimple;
    SPLDATA:=nil;
    end;
    //.
    MoveItem(Item,ptrNewItem);
    //.
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTSPLVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTSPLVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTSPLVisualizationCash(ptrDelItem^).ptrNext;
    TItemTSPLVisualizationCash(ptrDelItem^).SPLDATA.Free;
    FreeMem(ptrDelItem,SizeOf(TItemTSPLVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTSPLVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTSPLVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetSPLDATA(const DATA: TMemoryStream): OLEVariant;
  var
    DATAPtr: pointer;
  begin
  if (DATA <> nil)
   then with DATA do begin
    Position:=0;
    Result:=VarArrayCreate([0,Size-1],varByte);
    DATAPtr:=VarArrayLock(Result);
    try
    Read(DATAPtr^,Size);
    finally
    VarArrayUnLock(Result);
    end;
    end
   else Result:=Null;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTSPLVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('SPLType');       PropNode.nodeTypedValue:=Integer(SPLType);    ItemNode.appendChild(PropNode);
  //.
  PropNode:=Document.CreateElement('SPLDATA');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetSPLDATA(SPLDATA);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTSPLVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetSPLDATA(DATA: Variant; out SPLDATA: TMemoryStream);
  var
    DATASize: integer;
    DATAPtr: pointer;
  begin
  SPLDATA:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    SPLDATA:=TMemoryStream.Create;
    with SPLDATA do begin
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(SPLDATA);
    Raise; //. =>
    end;
  end;


var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _SPLType: integer;
  _SPLDATA: Variant;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _SPLType:=ItemNode.selectSingleNode('SPLType').nodeTypedValue;
  _SPLDATA:=ItemNode.selectSingleNode('SPLDATA').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTSPLVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTSPLVisualizationCash), 0);
  with TItemTSPLVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  SPLType:=TSPLVisualizationType(_SPLType);
  SetSPLDATA(_SPLDATA, SPLDATA);
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;









//. Map-format object
Constructor TSystemTMapFormatObject.Create;
begin
CreateNew(idTMapFormatObject,tnTMapFormatObject,TTMapFormatObjectFunctionality);
end;


{TMapFormatObjectDATAPanel}
Constructor TMapFormatObjectDATAPanel.Create(const pMapFormatObjectFunctionality: TMapFormatObjectFunctionality);
begin
Inherited Create(nil);
MapFormatObjectFunctionality:=pMapFormatObjectFunctionality;
MapFormatObjectFunctionality.AddRef();
end;

Destructor TMapFormatObjectDATAPanel.Destroy;
begin
if (MapFormatObjectFunctionality <> nil)
 then begin
  MapFormatObjectFunctionality.Release();
  MapFormatObjectFunctionality:=nil;
  end;
Inherited;
end;


{TMapFormatObjectDATAParser}
Constructor TMapFormatObjectDATAParser.Create();
begin
end;

Destructor TMapFormatObjectDATAParser.Destroy;
begin
Inherited;
end;

procedure TMapFormatObjectDATAParser.LoadFromStream(const Stream: TStream);

  function GetFileSectionString(DATA: Variant): ANSIString;
  var
    DATASize: integer;
    DATAPtr: pointer;
    MS: TMemoryStream;
  begin
  Result:='';
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    MS:=TMemoryStream.Create;
    try
    with MS do begin
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    end;
    SetLength(Result,MS.Size);
    MS.Read(Pointer(@Result[1])^,Length(Result));
    finally
    MS.Destroy;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    Raise; //. =>
    end;
  end;

var
  OLEStream: IStream;
  RootNode: IXMLDOMNode;
  VersionNode: IXMLDOMNode;
  Version: integer;
  SectionNode: IXMLDOMNode;
begin
if (Stream.Size = 0)
 then begin
  FileSection:='';
  Exit; //. ->
  end;
Stream.Position:=0;
OLEStream:=TStreamAdapter.Create(Stream);
Doc:=CoDomDocument.Create;
Doc.Set_Async(false);
Doc.Load(OLEStream);
//.
RootNode:=Doc.documentElement.selectSingleNode('/ROOT');
VersionNode:=RootNode.selectSingleNode('Version');
if (VersionNode <> nil)
 then Version:=VersionNode.nodeTypedValue
 else Version:=0;
if (Version <> 0) then Raise Exception.Create('unknown version'); //. =>
SectionNode:=RootNode.selectSingleNode('PMFSection');
FileSection:=GetFileSectionString(SectionNode.nodeTypedValue);
end;

procedure TMapFormatObjectDATAParser.SaveToStream(const Stream: TStream);

  function GetPMFileSectionData(const Section: ANSIString): OLEVariant;
  var
    _DATA: TMemoryStream;
    DATAPtr: pointer;
  begin
  if (Section <> '')
   then begin
    _DATA:=TMemoryStream.Create;
    try
    _DATA.Write(Pointer(@Section[1])^,Length(Section));
    _DATA.Position:=0;
    with _DATA do begin
    Result:=VarArrayCreate([0,Size-1],varByte);
    DATAPtr:=VarArrayLock(Result);
    try
    Read(DATAPtr^,Size);
    finally
    VarArrayUnLock(Result);
    end;
    end;
    finally
    _DATA.Destroy;
    end;
    end
   else Result:=Null;
  end;

var
  Doc: IXMLDOMDocument;
  PI: IXMLDOMProcessingInstruction;
  Root: IXMLDOMElement;
  VersionNode: IXMLDOMElement;
  SectionNode: IXMLDOMElement;
  OLEStream: IStream;
begin
Stream.Size:=0;
//.
Doc:=CoDomDocument.Create;
Doc.Set_Async(false);
PI:=Doc.createProcessingInstruction('xml', 'version=''1.0''');
Doc.insertBefore(PI, Doc.childNodes.Item[0]);
Root:=Doc.createElement('ROOT');
Root.setAttribute('xmlns:dt', 'urn:schemas-microsoft-com:datatypes');
Doc.documentElement:=Root;
VersionNode:=Doc.createElement('Version');
VersionNode.nodeTypedValue:=0;
Root.appendChild(VersionNode);
SectionNode:=Doc.createElement('PMFSection');
SectionNode.Set_dataType('bin.base64');
SectionNode.nodeTypedValue:=GetPMFileSectionData(FileSection);
Root.appendChild(SectionNode);
//.
OLEStream:=TStreamAdapter.Create(Stream);
Doc.save(OLEStream);
//.
Stream.Position:=0;
end;






//. Map-format map
Constructor TSystemTMapFormatMap.Create;
begin
CreateNew(idTMapFormatMap,tnTMapFormatMap,TTMapFormatMapFunctionality);
end;


{TMapFormatObjectDATAParser}
Constructor TMapFormatMapDATAParser.Create(const Stream: TStream);
var
  OLEStream: IStream;
begin
Stream.Position:=0;
OLEStream:=TStreamAdapter.Create(Stream);
Doc:=CoDomDocument.Create;
Doc.Set_Async(false);
Doc.Load(OLEStream);
end;

Destructor TMapFormatMapDATAParser.Destroy;
begin
Inherited;
end;

function TMapFormatMapDATAParser.FileSection(): ANSIString;

  function GetFileSectionString(DATA: Variant): ANSIString;
  var
    DATASize: integer;
    DATAPtr: pointer;
    MS: TMemoryStream;
  begin
  Result:='';
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    MS:=TMemoryStream.Create;
    try
    with MS do begin
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    end;
    SetLength(Result,MS.Size);
    MS.Read(Pointer(@Result[1])^,Length(Result));
    finally
    MS.Destroy;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    Raise; //. =>
    end;
  end;

var
  RootNode: IXMLDOMNode;
  VersionNode: IXMLDOMNode;
  Version: integer;
  SectionNode: IXMLDOMNode;
begin
RootNode:=Doc.documentElement.selectSingleNode('/ROOT');
VersionNode:=RootNode.selectSingleNode('Version');
if (VersionNode <> nil)
 then Version:=VersionNode.nodeTypedValue
 else Version:=0;
if (Version <> 0) then Raise Exception.Create('unknown version'); //. =>
SectionNode:=RootNode.selectSingleNode('PMFSection');
Result:=GetFileSectionString(SectionNode.nodeTypedValue);
end;







//. geo-space
Constructor TSystemTGeoSpace.Create;
begin
CreateNew(idTGeoSpace,tnTGeoSpace,TTGeoSpaceFunctionality);
end;








//. Boolean variable
Constructor TSystemTBoolVar.Create;
begin
CreateNew(idTBoolVar,tnTBoolVar,TTBoolVarFunctionality);
end;








//. user alert
Constructor TSystemTUserAlert.Create;
begin
CreateNew(idTUserAlert,tnTUserAlert,TTUserAlertFunctionality);
end;








//. geo graph server object
Constructor TSystemTGeoGraphServerObject.Create;
begin
CreateNew(idTGeoGraphServerObject,tnTGeoGraphServerObject,TTGeoGraphServerObjectFunctionality);
end;







//. geo graph server
Constructor TSystemTGeoGraphServer.Create;
begin
CreateNew(idTGeoGraphServer,tnTGeoGraphServer,TTGeoGraphServerFunctionality);
end;







//. geo coordinate system
Constructor TSystemTGeoCrdSystem.Create;
begin
CreateNew(idTGeoCrdSystem,tnTGeoCrdSystem,TTGeoCrdSystemFunctionality);
if Enabled then Cash:=TTGeoCrdSystemCash.Create(Self);
end;

Destructor TSystemTGeoCrdSystem.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTGeoCrdSystem.Initialize;
begin
if (Cash <> nil) then Cash.Update;
end;

procedure TSystemTGeoCrdSystem.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTGeoCrdSystem.Caching_Start;
begin
end;

procedure TSystemTGeoCrdSystem.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTGeoCrdSystem.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTGeoCrdSystem.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTGeoCrdSystem.Context_GetItems(out IDs: TIDArray);
begin
//. return one element equal to 0 that means cache contains all instances of type
SetLength(IDs,1);
IDs[0]:=0;
end;

procedure TSystemTGeoCrdSystem.Context_RemoveItem(const idComponent: integer);
begin
//. do not remove items context because we are using it as geo crd to local crd transformator
end;

procedure TSystemTGeoCrdSystem.Context_ClearItems();
begin
//. do not remove items context because we are using it as geo crd to local crd transformator
end;

procedure TSystemTGeoCrdSystem.Component_CheckCachedState(const idComponent: integer);
begin
if (NOT Context_IsItemExist(idComponent))
 then begin
  Caching_Start;
  try
  Caching_AddObject(idComponent);
  finally
  Caching_Finish;
  end;
  end;
end;

procedure TSystemTGeoCrdSystem.DoOnContextIsInitialized;
const
  CachingPortion = 33;
var
  IL: TList;
  Cnt,I: integer;
begin 
if (Space.flOffline OR (Cash = nil)) then Exit; //. ->
//. cache all instances that are not in loaded context
with TTGeoCrdSystemFunctionality.Create() do
try
GetInstanceList(IL);
try
Lock.Enter;
try
Caching_Start();
try
Cnt:=0;
for I:=0 to IL.Count-1 do
  if (NOT Context_IsItemExist(Integer(IL[I])))
   then begin
    Caching_AddObject(Integer(IL[I]));
    Inc(Cnt);
    if (Cnt >= CachingPortion)
     then begin
      Caching_Finish();
      Caching_Start();
      //.
      Cnt:=0;
      end;
    end;
finally
Caching_Finish();
end;
finally
Lock.Leave;
end;
finally
IL.Destroy;
end;
finally
Release;
end;
//. update items bounds
TTGeoCrdSystemCash(Cash).UpdateItemsBounds();
end;


procedure TGeoCrdSystemBounds_Clear(var Bounds: pointer);
var
  ptrdestroyItem: pointer;
begin
while (Bounds <> nil) do begin
  ptrDestroyItem:=Bounds;
  Bounds:=TGeoCrdSystemBoundsPoint(ptrDestroyItem^).ptrNext;
  FreeMem(ptrDestroyItem,SizeOf(TGeoCrdSystemBoundsPoint));
  end;
end;


//. TTGeoCrdSystemCash
Constructor TTGeoCrdSystemCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTGeoCrdSystemCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTGeoCrdSystemCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTGeoCrdSystemCash(ptrDelItem^).ptrNext;
  with TItemTGeoCrdSystemCash(ptrDelItem^) do begin
  idTOwner:=0;
  idOwner:=0;
  GeoSpaceID:=0;
  Name:='';
  Datum:='';
  Projection:='';
  ProjectionDATA.Free;
  SetLength(CalibrationPoints,0);
  Bounds_idVisualization:=0;
  TGeoCrdSystemBounds_Clear(Bounds);
  end;
  FreeMem(ptrDelItem,SizeOf(TItemTGeoCrdSystemCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTGeoCrdSystemCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TGeoCrdSystemFunctionality;
  FT: integer;
  BA: TByteArray;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if (List.Count = 0) then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTGeoCrdSystemCash));
    FillChar(ptrNewItem^,SizeOf(TItemTGeoCrdSystemCash), 0);
    try
    with TItemTGeoCrdSystemCash(ptrNewItem^) do begin
    idTOwner:=0;
    idOwner:=0;
    GeoSpaceID:=0;
    Name:='';
    Datum:='';
    Projection:='';
    ProjectionDATA:=nil;
    SetLength(CalibrationPoints,0);
    Bounds_idVisualization:=0;
    Bounds:=nil;
    CF:=TGeoCrdSystemFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    if (NOT CF.GetOwner(idTOwner,idOwner))
     then begin
      idTOwner:=0;
      idOwner:=0;
      end;
    GeoSpaceID:=CF.GeoSpaceID;
    Name:=CF.Name;
    Datum:=CF.Datum;
    Projection:=CF.Projection;
    CF.GetProjectionDATA(ProjectionDATA);
    if (NOT CF.QueryComponent(idTVisualization, Bounds_idTVisualization,Bounds_idVisualization))
     then begin
      Bounds_idTVisualization:=idTOwner;
      Bounds_idVisualization:=idOwner;
      end;
    if (Projection <> '') then CF.GetGeodesyPoints(CalibrationPoints); //. load callibration points if projection is defined
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTGeoCrdSystemCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTGeoCrdSystemCash));
    FillChar(ptrNewItem^,SizeOf(TItemTGeoCrdSystemCash), 0);
    try
    with TItemTGeoCrdSystemCash(ptrNewItem^) do begin
    idTOwner:=0;
    idOwner:=0;
    GeoSpaceID:=0;
    Name:='';
    Datum:='';
    Projection:='';
    ProjectionDATA:=nil;
    SetLength(CalibrationPoints,0);
    Bounds_idVisualization:=0;
    Bounds:=nil;
    CF:=TGeoCrdSystemFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try CF.GetOwner(idTOwner,idOwner); except on E: EActionsGroup do ; else Raise; end;
    try GeoSpaceID:=CF.GeoSpaceID; except on E: EActionsGroup do ; else Raise; end;
    try Name:=CF.Name; except on E: EActionsGroup do ; else Raise; end;
    try Datum:=CF.Datum; except on E: EActionsGroup do ; else Raise; end;
    try Projection:=CF.Projection; except on E: EActionsGroup do ; else Raise; end;
    try CF.GetProjectionDATA(ProjectionDATA); except on E: EActionsGroup do ; else Raise; end;
    try if (NOT CF.QueryComponent(idTVisualization, Bounds_idTVisualization,Bounds_idVisualization)) then Bounds_idVisualization:=0; except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TGeoCrdSystemFunctionality(TComponentFunctionality_Create(TypeSystem.idType,TItemTGeoCrdSystemCash(ItemsList[I]^).idObj)) do
    try
    try
    if (NOT GetOwner(TItemTGeoCrdSystemCash(ItemsList[I]^).idTOwner,TItemTGeoCrdSystemCash(ItemsList[I]^).idOwner))
     then begin
      TItemTGeoCrdSystemCash(ItemsList[I]^).idTOwner:=0;
      TItemTGeoCrdSystemCash(ItemsList[I]^).idOwner:=0;
      end;
    TItemTGeoCrdSystemCash(ItemsList[I]^).GeoSpaceID:=GeoSpaceID;
    TItemTGeoCrdSystemCash(ItemsList[I]^).Name:=Name;
    TItemTGeoCrdSystemCash(ItemsList[I]^).Datum:=Datum;
    TItemTGeoCrdSystemCash(ItemsList[I]^).Projection:=Projection;
    GetProjectionDATA(TItemTGeoCrdSystemCash(ItemsList[I]^).ProjectionDATA);
    if (NOT QueryComponent(idTVisualization, TItemTGeoCrdSystemCash(ItemsList[I]^).Bounds_idTVisualization,TItemTGeoCrdSystemCash(ItemsList[I]^).Bounds_idVisualization))
     then begin
      TItemTGeoCrdSystemCash(ItemsList[I]^).Bounds_idTVisualization:=TItemTGeoCrdSystemCash(ItemsList[I]^).idTOwner;
      TItemTGeoCrdSystemCash(ItemsList[I]^).Bounds_idVisualization:=TItemTGeoCrdSystemCash(ItemsList[I]^).idOwner;
      end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  except
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  //. load items callibration points
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to ItemsList.Count-1 do with TGeoCrdSystemFunctionality(TComponentFunctionality_Create(TypeSystem.idType,TItemTGeoCrdSystemCash(ItemsList[I]^).idObj)) do
    try
    try
    if (TItemTGeoCrdSystemCash(ItemsList[I]^).Projection <> '')
     then try GetGeodesyPoints(TItemTGeoCrdSystemCash(ItemsList[I]^).CalibrationPoints); except on E: EActionsGroup do ; else Raise; end;
    except
      end;
    finally
    Release;
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TGeoCrdSystemFunctionality(TComponentFunctionality_Create(TypeSystem.idType,TItemTGeoCrdSystemCash(ItemsList[I]^).idObj)) do
    try
    try
    if (TItemTGeoCrdSystemCash(ItemsList[I]^).Projection <> '')
     then GetGeodesyPoints(TItemTGeoCrdSystemCash(ItemsList[I]^).CalibrationPoints);
    except
      end;
    finally
    Release;
    end;
  except
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  //.
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if (ItemsList[I] <> nil) then begin
   TItemTGeoCrdSystemCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
//. update items bounds
UpdateItemsBounds();
end;


procedure TTGeoCrdSystemCash.Update;
begin
Empty;
end;

function TTGeoCrdSystemCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTGeoCrdSystemCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTGeoCrdSystemCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTGeoCrdSystemCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTGeoCrdSystemCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTGeoCrdSystemCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTGeoCrdSystemCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTGeoCrdSystemCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(ptrItem: pointer);
  var
    CF: TGeoCrdSystemFunctionality;
    BA: TByteArray;
    FT: integer;
  begin
  with TItemTGeoCrdSystemCash(ptrItem^) do begin
  //. updating item
  CF:=TGeoCrdSystemFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  idTOwner:=0;
  idOwner:=0;
  GeoSpaceID:=0;
  Name:='';
  Datum:='';
  Projection:='';
  ProjectionDATA.Free;
  SetLength(CalibrationPoints,0);
  Bounds_idVisualization:=0;
  TGeoCrdSystemBounds_Clear(Bounds);
  //.
  if (NOT CF.GetOwner(idTOwner,idOwner))
   then begin
    idTOwner:=0;
    idOwner:=0;
    end;
  GeoSpaceID:=CF.GeoSpaceID;
  Name:=CF.Name;
  Datum:=CF.Datum;
  Projection:=CF.Projection;
  CF.GetProjectionDATA(ProjectionDATA);
  if (NOT CF.QueryComponent(idTVisualization, Bounds_idTVisualization,Bounds_idVisualization))
   then begin
    Bounds_idTVisualization:=idTOwner;
    Bounds_idVisualization:=idOwner;
    end;
  if (Projection <> '') then CF.GetGeodesyPoints(CalibrationPoints); //. load callibration points if projection is defined
  finally
  CF.Release;
  end;
  //. update item bounds
  UpdateItemsBounds();
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTGeoCrdSystemCash));
  FillChar(ptrNewItem^,SizeOf(TItemTGeoCrdSystemCash), 0);
  with TItemTGeoCrdSystemCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if ptrUpdateItem <> nil then UpdateItem(ptrUpdateItem) else UpdateLocal(pidObj,opCreate);
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTGeoCrdSystemCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TGeoCrdSystemFunctionality;
    BA: TByteArray;
    FT: integer;
  begin
  with TItemTGeoCrdSystemCash(ptrItem^) do begin
  //. updating item
  CF:=TGeoCrdSystemFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  idTOwner:=0;
  idOwner:=0;
  GeoSpaceID:=0;
  Name:='';
  Datum:='';
  Projection:='';
  ProjectionDATA.Free;
  SetLength(CalibrationPoints,0);
  Bounds_idVisualization:=0;
  TGeoCrdSystemBounds_Clear(Bounds);
  //.
  if (NOT CF.GetOwner(idTOwner,idOwner))
   then begin
    idTOwner:=0;
    idOwner:=0;
    end;
  GeoSpaceID:=CF.GeoSpaceID;
  Name:=CF.Name;
  Datum:=CF.Datum;
  Projection:=CF.Projection;
  CF.GetProjectionDATA(ProjectionDATA);
  if (NOT CF.QueryComponent(idTVisualization, Bounds_idTVisualization,Bounds_idVisualization))
   then begin
    Bounds_idTVisualization:=idTOwner;
    Bounds_idVisualization:=idOwner;
    end;
  if (Projection <> '') then CF.GetGeodesyPoints(CalibrationPoints); //. load callibration points if projection is defined
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTGeoCrdSystemCash; const ptrItem: pointer);
  begin
  with TItemTGeoCrdSystemCash(ptrItem^) do begin
  ProjectionDATA.Free;
  Bounds_idVisualization:=0;
  TGeoCrdSystemBounds_Clear(Bounds);
  //.
  idTOwner:=Item.idTOwner;
  idOwner:=Item.idOwner;
  GeoSpaceID:=Item.GeoSpaceID;
  Name:=Item.Name;
  Datum:=Item.Datum;
  Projection:=Item.Projection;
  ProjectionDATA:=Item.ProjectionDATA;
  CalibrationPoints:=Item.CalibrationPoints;
  Bounds_idTVisualization:=Item.Bounds_idTVisualization;
  Bounds_idVisualization:=Item.Bounds_idVisualization;
  Bounds:=Item.Bounds;
  end;
  //. update item bounds
  UpdateItemsBounds();
  end;

var
  Item: TItemTGeoCrdSystemCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTGeoCrdSystemCash));
  FillChar(ptrNewItem^,SizeOf(TItemTGeoCrdSystemCash), 0);
  with TItemTGeoCrdSystemCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  end;
  //.
  MoveItem(Item,ptrNewItem);
  //.
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin //. create new item
    GetMem(ptrNewItem,SizeOf(TItemTGeoCrdSystemCash));
    FillChar(ptrNewItem^,SizeOf(TItemTGeoCrdSystemCash), 0);
    with TItemTGeoCrdSystemCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    end;
    //.
    MoveItem(Item,ptrNewItem);
    //.
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTGeoCrdSystemCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTGeoCrdSystemCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTGeoCrdSystemCash(ptrDelItem^).ptrNext;
    with TItemTGeoCrdSystemCash(ptrDelItem^) do begin
    idTOwner:=0;
    idOwner:=0;
    GeoSpaceID:=0;
    Name:='';
    Datum:='';
    Projection:='';
    ProjectionDATA.Free;
    SetLength(CalibrationPoints,0);
    Bounds_idVisualization:=0;
    TGeoCrdSystemBounds_Clear(Bounds);
    end;
    FreeMem(ptrDelItem,SizeOf(TItemTGeoCrdSystemCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTGeoCrdSystemCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTGeoCrdSystemCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetProjectionDATA(const DATA: TMemoryStream): OLEVariant;
  var
    DATAPtr: pointer;
  begin
  if (DATA <> nil)
   then with DATA do begin
    Position:=0;
    Result:=VarArrayCreate([0,Size-1],varByte);
    DATAPtr:=VarArrayLock(Result);
    try
    Read(DATAPtr^,Size);
    finally
    VarArrayUnLock(Result);
    end;
    end
   else Result:=Null;
  end;

  function GetCalibrationPoints(const DATA: TByteArray): OLEVariant;
  var
    DATAPtr: pointer;
  begin
  if (Length(DATA) > 0)
   then begin
    Result:=VarArrayCreate([0,Length(DATA)-1],varByte);
    DATAPtr:=VarArrayLock(Result);
    try
    Move(Pointer(@DATA[0])^,DATAPtr^,Length(DATA));
    finally
    VarArrayUnLock(Result);
    end;
    end
   else Result:=Null;
  end;

  function GetBoundsData(const Bounds: pointer): OLEVariant;
  var
    DATA: TMemoryStream;
    ptrItem: pointer;
    DATAPtr: pointer;
  begin
  DATA:=TMemoryStream.Create;
  try
  ptrItem:=Bounds;
  while (ptrItem <> nil) do with TGeoCrdSystemBoundsPoint(ptrItem^) do begin
    DATA.Write(X,SizeOf(X));
    DATA.Write(Y,SizeOf(Y));
    DATA.Write(Lat,SizeOf(Lat));
    DATA.Write(Long,SizeOf(Long));
    ptrItem:=ptrNext;
    end;
  with DATA do begin
  Position:=0;
  Result:=VarArrayCreate([0,Size-1],varByte);
  DATAPtr:=VarArrayLock(Result);
  try
  Read(DATAPtr^,Size);
  finally
  VarArrayUnLock(Result);
  end;
  end;
  finally
  DATA.Destroy;
  end;
  end;


var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode,SubPropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTGeoCrdSystemCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('idTOwner');   PropNode.nodeTypedValue:=idTOwner;   ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('idOwner');    PropNode.nodeTypedValue:=idOwner;    ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('GeoSpaceID'); PropNode.nodeTypedValue:=GeoSpaceID; ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Name');       PropNode.nodeTypedValue:=Name;       ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Datum');      PropNode.nodeTypedValue:=Datum;      ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Projection'); PropNode.nodeTypedValue:=Projection; ItemNode.appendChild(PropNode);
  //.
  PropNode:=Document.CreateElement('ProjectionDATA');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetProjectionDATA(ProjectionDATA);
  ItemNode.appendChild(PropNode);
  //.
  if (Projection <> '')
   then begin //. save callibration points if projection is defined
    PropNode:=Document.CreateElement('CalibrationPoints');
    PropNode.Set_dataType('bin.base64');
    PropNode.nodeTypedValue:=GetCalibrationPoints(CalibrationPoints);
    ItemNode.appendChild(PropNode);
    end;
  //.
  if (Bounds_idVisualization <> 0)
   then begin
    PropNode:=Document.CreateElement('Bounds');
    SubPropNode:=Document.CreateElement('idTVisualization');       SubPropNode.nodeTypedValue:=Bounds_idTVisualization;       PropNode.appendChild(SubPropNode);
    SubPropNode:=Document.CreateElement('idVisualization');        SubPropNode.nodeTypedValue:=Bounds_idVisualization;        PropNode.appendChild(SubPropNode);
    SubPropNode:=Document.CreateElement('DATA');
    SubPropNode.Set_dataType('bin.base64');
    if (Bounds <> nil) then SubPropNode.nodeTypedValue:=GetBoundsData(Bounds);
    PropNode.appendChild(SubPropNode);
    if (Bounds <> nil)
     then begin
      SubPropNode:=Document.CreateElement('Xmin');        SubPropNode.nodeTypedValue:=Bounds_minX;        PropNode.appendChild(SubPropNode);
      SubPropNode:=Document.CreateElement('Ymin');        SubPropNode.nodeTypedValue:=Bounds_minY;        PropNode.appendChild(SubPropNode);
      SubPropNode:=Document.CreateElement('Xmax');        SubPropNode.nodeTypedValue:=Bounds_maxX;        PropNode.appendChild(SubPropNode);
      SubPropNode:=Document.CreateElement('Ymax');        SubPropNode.nodeTypedValue:=Bounds_maxY;        PropNode.appendChild(SubPropNode);
      SubPropNode:=Document.CreateElement('LatMin');         SubPropNode.nodeTypedValue:=Bounds_minLat;        PropNode.appendChild(SubPropNode);
      SubPropNode:=Document.CreateElement('LongMin');        SubPropNode.nodeTypedValue:=Bounds_minLong;       PropNode.appendChild(SubPropNode);
      SubPropNode:=Document.CreateElement('LatMax');         SubPropNode.nodeTypedValue:=Bounds_maxLat;        PropNode.appendChild(SubPropNode);
      SubPropNode:=Document.CreateElement('LongMax');        SubPropNode.nodeTypedValue:=Bounds_maxLong;       PropNode.appendChild(SubPropNode);
      end;
    ItemNode.appendChild(PropNode);
    end;
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTGeoCrdSystemCash.LoadItems(Node: IXMLDOMNode);

  procedure SetProjectionDATA(const DATA: Variant; out ProjectionDATA: TMemoryStream);
  var
    DATASize: integer;
    DATAPtr: pointer;
  begin
  ProjectionDATA:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    ProjectionDATA:=TMemoryStream.Create;
    with ProjectionDATA do begin
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(ProjectionDATA);
    Raise; //. =>
    end;
  end;

  procedure SetCalibrationPoints(const DATA: Variant; out CalibrationPoints: TByteArray);
  var
    DATASize: integer;
    DATAPtr: pointer;
  begin
  SetLength(CalibrationPoints,0);
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    SetLength(CalibrationPoints,DATASize);
    Move(DATAPtr^,Pointer(@CalibrationPoints[0])^,DATASize);
    finally
    VarArrayUnLock(DATA);
    end;
    end
   else SetLength(CalibrationPoints,0);
  end;

  procedure SetBoundsData(const BoundsData: Variant; var Bounds: pointer);
  var
    ptrptrItem: pointer;
    DATASize: integer;
    DATAPtr: pointer;
    MS: TMemoryStream;
    I: integer;
    ptrNewItem: pointer;
  begin
  Bounds:=nil;
  try
  ptrptrItem:=@Bounds;
  DATASize:=VarArrayHighBound(BoundsData,1)+1;
  DATAPtr:=VarArrayLock(BoundsData);
  try
  MS:=TMemoryStream.Create;
  try
  with MS do begin
  Size:=DATASize;
  Write(DATAPtr^,DATASize);
  Position:=0;
  for I:=0 to (MS.Size DIV (SizeOf(TGeoCrdSystemBoundsPoint)-SizeOf(Pointer){SizeOf(ptrNext)}))-1 do begin
    GetMem(ptrNewItem,SizeOf(TGeoCrdSystemBoundsPoint));
    FillChar(ptrNewItem^,SizeOf(TGeoCrdSystemBoundsPoint), 0);
    with TGeoCrdSystemBoundsPoint(ptrNewItem^) do begin
    ptrNext:=nil;
    Read(X,SizeOf(X));
    Read(Y,SizeOf(Y));
    Read(Lat,SizeOf(Lat));
    Read(Long,SizeOf(Long));
    end;
    //. insert new item
    Pointer(ptrptrItem^):=ptrNewItem;
    ptrptrItem:=@TGeoCrdSystemBoundsPoint(ptrNewItem^).ptrNext;
    end;
  end;
  finally
  MS.Destroy;
  end;
  finally
  VarArrayUnLock(BoundsData);
  end;
  except
    TGeoCrdSystemBounds_Clear(Bounds);
    Raise; //. =>
    end;
  end;


var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _idTOwner: integer;
  _idOwner: integer;
  _GeoSpaceID: integer;
  _Name: string;
  _Datum: string;
  _Projection: string;
  _ProjectionDATA: Variant;
  _CalibrationPoints: Variant;
  _Bounds_idTVisualization: integer;
  _Bounds_idVisualization: integer;
  _Bounds: Variant;
  _Bounds_minX: double;
  _Bounds_minY: double;
  _Bounds_maxX: double;
  _Bounds_maxY: double;
  _Bounds_minLat: double;
  _Bounds_minLong: double;
  _Bounds_maxLat: double;
  _Bounds_maxLong: double;
begin 
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  if (ItemNode.selectSingleNode('idTOwner') <> nil)
   then _idTOwner:=ItemNode.selectSingleNode('idTOwner').nodeTypedValue
   else _idTOwner:=0;
  if (ItemNode.selectSingleNode('idOwner') <> nil)
   then _idOwner:=ItemNode.selectSingleNode('idOwner').nodeTypedValue
   else _idOwner:=0;
  if (ItemNode.selectSingleNode('GeoSpaceID') <> nil)
   then _GeoSpaceID:=ItemNode.selectSingleNode('GeoSpaceID').nodeTypedValue
   else _GeoSpaceID:=0;
  _Name:=ItemNode.selectSingleNode('Name').nodeTypedValue;
  _Datum:=ItemNode.selectSingleNode('Datum').nodeTypedValue;
  _Projection:=ItemNode.selectSingleNode('Projection').nodeTypedValue;
  _ProjectionDATA:=ItemNode.selectSingleNode('ProjectionDATA').nodeTypedValue;
  if (ItemNode.selectSingleNode('CalibrationPoints') <> nil)
   then _CalibrationPoints:=ItemNode.selectSingleNode('CalibrationPoints').nodeTypedValue
   else _CalibrationPoints:=null;
  if (ItemNode.selectSingleNode('Bounds') <> nil)
   then begin
    _Bounds_idTVisualization:=ItemNode.selectSingleNode('Bounds/idTVisualization').nodeTypedValue;
    _Bounds_idVisualization:=ItemNode.selectSingleNode('Bounds/idVisualization').nodeTypedValue;
    _Bounds:=ItemNode.selectSingleNode('Bounds/DATA').nodeTypedValue;
    if (_Bounds <> null)
     then begin
      _Bounds_minX:=ItemNode.selectSingleNode('Bounds/Xmin').nodeTypedValue;
      _Bounds_minY:=ItemNode.selectSingleNode('Bounds/Ymin').nodeTypedValue;
      _Bounds_maxX:=ItemNode.selectSingleNode('Bounds/Xmax').nodeTypedValue;
      _Bounds_maxY:=ItemNode.selectSingleNode('Bounds/Ymax').nodeTypedValue;
      _Bounds_minLat:=ItemNode.selectSingleNode('Bounds/LatMin').nodeTypedValue;
      _Bounds_minLong:=ItemNode.selectSingleNode('Bounds/LongMin').nodeTypedValue;
      _Bounds_maxLat:=ItemNode.selectSingleNode('Bounds/LatMax').nodeTypedValue;
      _Bounds_maxLong:=ItemNode.selectSingleNode('Bounds/LongMax').nodeTypedValue;
      end;
    end
   else begin
    _Bounds_idTVisualization:=0;
    _Bounds_idVisualization:=0;
    _Bounds:=null;
    end;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTGeoCrdSystemCash));
  FillChar(ptrNewItem^,SizeOf(TItemTGeoCrdSystemCash), 0);
  with TItemTGeoCrdSystemCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  idTOwner:=_idTOwner;
  idOwner:=_idOwner;
  GeoSpaceID:=_GeoSpaceID;
  Name:=_Name;
  Datum:=_Datum;
  Projection:=_Projection;
  SetProjectionDATA(_ProjectionDATA, ProjectionDATA);
  SetCalibrationPoints(_CalibrationPoints, CalibrationPoints);
  Bounds_idTVisualization:=_Bounds_idTVisualization;
  Bounds_idVisualization:=_Bounds_idVisualization;
  if (_Bounds <> null)
   then begin
    SetBoundsData(_Bounds, Bounds);
    if (Bounds <> nil)
     then begin
      Bounds_minX:=_Bounds_minX;
      Bounds_minY:=_Bounds_minY;
      Bounds_maxX:=_Bounds_maxX;
      Bounds_maxY:=_Bounds_maxY;
      Bounds_minLat:=_Bounds_minLat;
      Bounds_minLong:=_Bounds_minLong;
      Bounds_maxLat:=_Bounds_maxLat;
      Bounds_maxLong:=_Bounds_maxLong;
      end;
    end
   else Bounds:=nil;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTGeoCrdSystemCash.UpdateItemsBounds; 
const
  SizeOfTSpaceObj = SizeOf(TSpaceObj);
  SizeOfTPoint = SizeOf(TPoint);
var
  ptrItem: pointer;
  ItemsList: TList;
  I,J: integer;
  ID: TID;
  IDs: TByteArray;
  NewObjPointers: TByteArray;
  ptrObj: TPtr;
  CrdSysConvertor: TCrdSysConvertor;
  ptrSrs: pointer;
  Obj: TSpaceObj;
  ptrPoint: TPtr;
  Point: TPoint;
  _Lat,_Long: Extended;
  ptrNewBoundsItem: pointer;
  ptrptrItem: pointer;
  Node: TNodeSpaceObjPolyLinePolygon;
begin
ItemsList:=TList.Create;
try
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTGeoCrdSystemCash(ptrItem^) do begin
  if ((Bounds_idVisualization <> 0) AND (Bounds = nil)) then ItemsList.Add(ptrItem);
  //. next item
  ptrItem:=ptrNext;
  end;
//. process items to update items bounds
SetLength(IDs,ItemsList.Count*SizeOf(ID));
for I:=0 to ItemsList.Count-1 do with TItemTGeoCrdSystemCash(ItemsList[I]^) do begin
  ID.idType:=Bounds_idTVisualization;
  ID.idObj:=Bounds_idVisualization;
  TID(Pointer(Integer(@IDs[0])+I*SizeOf(ID))^):=ID;
  end;
//.
with TypeSystem.Space do
{$IFNDEF EmbeddedServer}
with GetISpaceManager(SOAPServerURL) do ReadObjectsByIDs(UserName,UserPassword, IDs,ItemsList.Count, NewObjPointers);
{$ELSE}
SpaceManager_ReadObjectsByIDs(UserName,UserPassword, IDs,ItemsList.Count, NewObjPointers);
{$ENDIF}
//. cache visualization bodies into the space to process visualizations
ptrSrs:=@NewObjPointers[0];
for I:=0 to ItemsList.Count-1 do begin
  //. get object pointer
  asm
     PUSH ESI
     MOV ESI,ptrSrs
     CLD
     LODSD
     MOV ptrObj,EAX
     MOV ptrSrs,ESI
     POP ESI
  end;
  //.
  if (ptrObj <> nilPtr)
   then with TItemTGeoCrdSystemCash(ItemsList[I]^) do begin
    try
    CrdSysConvertor:=TCrdSysConvertor.Create(TypeSystem.Space,idObj);
    except
      CrdSysConvertor:=nil;
      end;
    try
    if (CrdSysConvertor <> nil)
     then begin
      Bounds_minX:=MaxDouble;
      Bounds_minY:=MaxDouble;
      Bounds_maxX:=-MaxDouble;
      Bounds_maxY:=-MaxDouble;
      Bounds_minLat:=MaxDouble;
      Bounds_minLong:=MaxDouble;
      Bounds_maxLat:=-MaxDouble;
      Bounds_maxLong:=-MaxDouble;
      end;
    //. get object body
    asm
       PUSH ESI
       PUSH EDI
       MOV ESI,ptrSrs
       CLD
       LEA EDI,Obj
       MOV ECX,SizeOfTSpaceObj
       REP MOVSB
       MOV ptrSrs,ESI
       POP EDI
       POP ESI
    end;
    if (Obj.flagLoop)
     then begin //. write body
      ptrptrItem:=@Bounds;
      ptrPoint:=Obj.ptrFirstPoint;
      while (ptrPoint <> nilPtr) do begin
        //. get point
        asm
           PUSH ESI
           PUSH EDI
           MOV ESI,ptrSrs
           CLD
           LEA EDI,Point
           MOV ECX,SizeOfTPoint
           REP MOVSB
           MOV ptrSrs,ESI
           POP EDI
           POP ESI
        end;
        if (CrdSysConvertor <> nil)
         then
          if (CrdSysConvertor.ConvertXYToGeo(Point.X,Point.Y, _Lat,_Long))
           then begin
            //. add bounds new point
            GetMem(ptrNewBoundsItem,SizeOf(TGeoCrdSystemBoundsPoint));
            with TGeoCrdSystemBoundsPoint(ptrNewBoundsItem^) do begin
            ptrNext:=nil;
            X:=Point.X;
            Y:=Point.Y;
            Lat:=_Lat;
            Long:=_Long;
            end;
            Pointer(ptrptrItem^):=ptrNewBoundsItem;
            ptrptrItem:=@TGeoCrdSystemBoundsPoint(ptrNewBoundsItem^).ptrNext;
            //. processing for bounds container
            with TGeoCrdSystemBoundsPoint(ptrNewBoundsItem^) do begin
            if (X < Bounds_minX) then Bounds_minX:=X;
            if (Y < Bounds_minY) then Bounds_minY:=Y;
            if (X > Bounds_maxX) then Bounds_maxX:=X;
            if (Y > Bounds_maxY) then Bounds_maxY:=Y;
            if (Lat < Bounds_minLat) then Bounds_minLat:=Lat;
            if (Long < Bounds_minLong) then Bounds_minLong:=Long;
            if (Lat > Bounds_maxLat) then Bounds_maxLat:=Lat;
            if (Long > Bounds_maxLong) then Bounds_maxLong:=Long;
            end;
            end
           else begin //. clear item bounds
            FreeAndNil(CrdSysConvertor);
            TGeoCrdSystemBounds_Clear(Bounds);
            end;
        //. go to next point
        ptrPoint:=Point.ptrNextObj;
        end;
      end
     else
      if (Obj.Width > 0)
       then begin  //. write body
        ptrptrItem:=@Bounds;
        with TSpaceObjPolylinePolygon.Create(Space,Obj,Obj.Width) do
        try
        Count:=0;
        ptrPoint:=Obj.ptrFirstPoint;
        while (ptrPoint <> nilPtr) do begin
          //. get point
          asm
             PUSH ESI
             PUSH EDI
             MOV ESI,ptrSrs
             CLD
             LEA EDI,Point
             MOV ECX,SizeOfTPoint
             REP MOVSB
             MOV ptrSrs,ESI
             POP EDI
             POP ESI
          end;
          //. add node
          Node.X:=Point.X;
          Node.Y:=Point.Y;
          Nodes[Count]:=Node;
          inc(Count);
          //. go to next point
          ptrPoint:=Point.ptrNextObj;
          end;
        Update();
        for J:=0 to Count-1 do with Nodes[J] do
          if (CrdSysConvertor <> nil)
           then
            if (CrdSysConvertor.ConvertXYToGeo(Nodes[J].X,Nodes[J].Y, _Lat,_Long))
             then begin
              //. add bounds new point
              GetMem(ptrNewBoundsItem,SizeOf(TGeoCrdSystemBoundsPoint));
              with TGeoCrdSystemBoundsPoint(ptrNewBoundsItem^) do begin
              ptrNext:=nil;
              X:=Nodes[J].X;
              Y:=Nodes[J].Y;
              Lat:=_Lat;
              Long:=_Long;
              end;
              Pointer(ptrptrItem^):=ptrNewBoundsItem;
              ptrptrItem:=@TGeoCrdSystemBoundsPoint(ptrNewBoundsItem^).ptrNext;
              //. processing for bounds container
              with TGeoCrdSystemBoundsPoint(ptrNewBoundsItem^) do begin
              if (X < Bounds_minX) then Bounds_minX:=X;
              if (Y < Bounds_minY) then Bounds_minY:=Y;
              if (X > Bounds_maxX) then Bounds_maxX:=X;
              if (Y > Bounds_maxY) then Bounds_maxY:=Y;
              if (Lat < Bounds_minLat) then Bounds_minLat:=Lat;
              if (Long < Bounds_minLong) then Bounds_minLong:=Long;
              if (Lat > Bounds_maxLat) then Bounds_maxLat:=Lat;
              if (Long > Bounds_maxLong) then Bounds_maxLong:=Long;
              end;
              end
             else begin //. clear item bounds
              FreeAndNil(CrdSysConvertor);
              TGeoCrdSystemBounds_Clear(Bounds);
              end;
        finally
        Destroy;
        end;
        end;
    finally
    CrdSysConvertor.Free;
    end;
    end;
  end;
finally
TypeSystem.Lock.Leave;
end;
finally
ItemsList.Destroy;
end;
end;







//. Filter-visualization
{TSystemTFilterVisualization}
Constructor TSystemTFilterVisualization.Create;
begin
CreateNew(idTFilterVisualization,tnTFilterVisualization,TTFilterVisualizationFunctionality);
if Enabled then Cash:=TTFilterVisualizationCash.Create(Self);
//.
Reflecting__DIB:=0;
Reflecting__DIB_DC:=0;
Reflecting__DIB_DC:=CreateCompatibleDC(0);
ZeroMemory(@Reflecting__DIB_BitInfo,sizeof(BITMAPINFO));
with Reflecting__DIB_BitInfo.bmiHeader do begin
biSize:=sizeOf(Reflecting__DIB_BitInfo.bmiHeader);
biBitCount:=24; //. do not change
biCompression:=BI_RGB;
biPlanes:=1;
biWidth:=(Screen.Width+16);
biHeight:=-(Screen.Height+16);
biSizeImage:=(biWidth*(biBitCount div 8))*biHeight;
end;
Reflecting__DIB:=CreateDIBSection(Reflecting__DIB_DC, Reflecting__DIB_BitInfo, DIB_RGB_COLORS, Reflecting__DIB_PixelsPtr, 0, 0);
SelectObject(Reflecting__DIB_DC, Reflecting__DIB);
end;

Destructor TSystemTFilterVisualization.Destroy;
begin
if (Reflecting__DIB <> 0)
 then begin
  SelectObject(Reflecting__DIB_DC,0);
  DeleteObject(Reflecting__DIB);
  end;
if (Reflecting__DIB_DC <> 0) then DeleteDC(Reflecting__DIB_DC);
//.
Cash.Free;
Inherited;
end;

procedure TSystemTFilterVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTFilterVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTFilterVisualization.Caching_Start;
begin
end;

procedure TSystemTFilterVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTFilterVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTFilterVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTFilterVisualization.Context_GetItems(out IDs: TIDArray); 
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTFilterVisualizationCash
Constructor TTFilterVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTFilterVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTFilterVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTFilterVisualizationCash(ptrDelItem^).ptrNext;
  TItemTFilterVisualizationCash(ptrDelItem^).FilterDATA.Free;
  FreeMem(ptrDelItem,SizeOf(TItemTFilterVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTFilterVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TFilterVisualizationFunctionality;
  FT: integer;
  BA: TByteArray;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTFilterVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTFilterVisualizationCash), 0);
    with TItemTFilterVisualizationCash(ptrNewItem^) do begin
    FilterType:=ftContrasting;
    FilterDATA:=nil;
    CF:=TFilterVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetParams(FT,BA);
    FilterType:=TFilterVisualizationType(FT);
    ByteArray_CreateStream(BA, FilterDATA);
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTFilterVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTFilterVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTFilterVisualizationCash), 0);
    with TItemTFilterVisualizationCash(ptrNewItem^) do begin
    FilterType:=ftContrasting;
    FilterDATA:=nil;
    CF:=TFilterVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try CF.GetParams(FT,BA); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTFilterVisualizationCash(ItemsList[I]^) do with TFilterVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    GetParams(FT,BA);
    FilterType:=TFilterVisualizationType(FT);
    ByteArray_CreateStream(BA, FilterDATA);
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTFilterVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;


procedure TTFilterVisualizationCash.Update;
begin
Empty;
end;

function TTFilterVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTFilterVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTFilterVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTFilterVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTFilterVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTFilterVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTFilterVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTFilterVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(ptrItem: pointer);
  var
    CF: TFilterVisualizationFunctionality;
    BA: TByteArray;
    FT: integer;
  begin
  with TItemTFilterVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TFilterVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  FreeAndNil(FilterDATA);
  //.
  CF.GetParams(FT,BA);
  FilterType:=TFilterVisualizationType(FT);
  ByteArray_CreateStream(BA, FilterDATA);
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTFilterVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTFilterVisualizationCash), 0);
  with TItemTFilterVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  FilterType:=ftContrasting;
  FilterDATA:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if ptrUpdateItem <> nil then UpdateItem(ptrUpdateItem) else UpdateLocal(pidObj,opCreate);
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTFilterVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TFilterVisualizationFunctionality;
    BA: TByteArray;
    FT: integer;
  begin
  with TItemTFilterVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TFilterVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  FilterType:=ftContrasting;
  FreeAndNil(FilterDATA);
  //.
  CF.GetParams(FT,BA);
  FilterType:=TFilterVisualizationType(FT);
  ByteArray_CreateStream(BA, FilterDATA);
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTFilterVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTFilterVisualizationCash(ptrItem^) do begin
  FreeAndNil(FilterDATA);
  //.
  FilterType:=Item.FilterType;
  FilterDATA:=Item.FilterDATA;
  end;
  end;

var
  Item: TItemTFilterVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTFilterVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTFilterVisualizationCash), 0);
  with TItemTFilterVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  FilterType:=ftContrasting;
  FilterDATA:=nil;
  end;
  //.
  MoveItem(Item,ptrNewItem);
  //.
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTFilterVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTFilterVisualizationCash), 0);
    with TItemTFilterVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    FilterType:=ftContrasting;
    FilterDATA:=nil;
    end;
    //.
    MoveItem(Item,ptrNewItem);
    //.
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTFilterVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTFilterVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTFilterVisualizationCash(ptrDelItem^).ptrNext;
    TItemTFilterVisualizationCash(ptrDelItem^).FilterDATA.Free;
    FreeMem(ptrDelItem,SizeOf(TItemTFilterVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTFilterVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTFilterVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetFilterDATA(const DATA: TMemoryStream): OLEVariant;
  var
    DATAPtr: pointer;
  begin
  if (DATA <> nil)
   then with DATA do begin
    Position:=0;
    Result:=VarArrayCreate([0,Size-1],varByte);
    DATAPtr:=VarArrayLock(Result);
    try
    Read(DATAPtr^,Size);
    finally
    VarArrayUnLock(Result);
    end;
    end
   else Result:=Null;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTFilterVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('FilterType');       PropNode.nodeTypedValue:=Integer(FilterType);    ItemNode.appendChild(PropNode);
  //.
  PropNode:=Document.CreateElement('FilterDATA');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetFilterDATA(FilterDATA);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTFilterVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetFilterDATA(DATA: Variant; out FilterDATA: TMemoryStream);
  var
    DATASize: integer;
    DATAPtr: pointer;
  begin
  FilterDATA:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    FilterDATA:=TMemoryStream.Create;
    with FilterDATA do begin
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(FilterDATA);
    Raise; //. =>
    end;
  end;


var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _FilterType: integer;
  _FilterDATA: Variant;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _FilterType:=ItemNode.selectSingleNode('FilterType').nodeTypedValue;
  _FilterDATA:=ItemNode.selectSingleNode('FilterDATA').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTFilterVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTFilterVisualizationCash), 0);
  with TItemTFilterVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  FilterType:=TFilterVisualizationType(_FilterType);
  SetFilterDATA(_FilterDATA, FilterDATA);
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;



//. HINT-визуализация
{TSystemTHINTVisualization}
Constructor TSystemTHINTVisualization.Create;
begin
CreateNew(idTHINTVisualization,tnTHINTVisualization,TTHINTVisualizationFunctionality);
if Enabled then Cash:=TTHINTVisualizationCash.Create(Self);
end;

Destructor TSystemTHINTVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTHINTVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTHINTVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTHINTVisualization.Caching_Start;
begin
end;

procedure TSystemTHINTVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTHINTVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTHINTVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTHINTVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


{THintVisualizationDATA}
Constructor THintVisualizationDATA.Create(const AStream: TStream = nil);
begin
Inherited Create;
InfoStringFontDefaultName:='Tahoma';
InfoStringFontDefaultSize:=12;
InfoStringFontDefaultColor:=clWhite;
InfoTextFontDefaultName:='Arial';
InfoTextFontDefaultSize:=10;
InfoTextFontDefaultColor:=clGray;
//.
if (AStream <> nil)
 then begin
  AStream.Position:=0;
  Self.LoadFromStream(AStream);
  GetProperties;
  end
 else ClearProperties;
end;

destructor THintVisualizationDATA.Destroy;
begin
Inherited;
end;

procedure THintVisualizationDATA.ClearProperties;
begin
StatusInfoText:='';
InfoString:='';
InfoText:='';
InfoStringFontName:=InfoStringFontDefaultName;
InfoStringFontSize:=InfoStringFontDefaultSize;
InfoStringFontColor:=InfoStringFontDefaultColor;
InfoTextFontName:=InfoTextFontDefaultName;
InfoTextFontSize:=InfoTextFontDefaultSize;
InfoTextFontColor:=InfoTextFontDefaultColor;
with InfoComponent do begin
idType:=0;
idObj:=0;
end;
Transparency:=0;
end;

procedure THintVisualizationDATA.GetProperties;
var
  OLEStream: IStream;
  Doc: IXMLDOMDocument;
  RootNode: IXMLDOMNode;
  VersionNode: IXMLDOMNode;
  Version: integer;
  InfoNode: IXMLDOMNode;
  StatusInfoNode: IXMLDOMNode;
  FontNode: IXMLDOMNode;
  Node: IXMLDOMNode;
begin
ClearProperties;
if (Size > 0)
 then begin
  Self.Position:=0;
  OLEStream:=TStreamAdapter.Create(Self);
  Doc:=CoDomDocument.Create;
  Doc.Set_Async(false);
  Doc.Load(OLEStream);
  RootNode:=Doc.documentElement.selectSingleNode('/ROOT');
  VersionNode:=RootNode.selectSingleNode('Version');
  if VersionNode <> nil
   then Version:=VersionNode.nodeTypedValue
   else Version:=0;
  if (Version <> 0) then Raise Exception.Create('unknown version'); //. =>
  InfoNode:=RootNode.selectSingleNode('Info');
  Node:=InfoNode.selectSingleNode('String');
  if (Node <> nil)
   then begin
    InfoString:=Node.selectSingleNode('Chars').nodeTypedValue;
    FontNode:=Node.selectSingleNode('Font');
    if (FontNode <> nil)
     then begin
      Node:=FontNode.selectSingleNode('Name');
      if (Node <> nil) then InfoStringFontName:=Node.nodeTypedValue;
      Node:=FontNode.selectSingleNode('Size');
      if (Node <> nil) then InfoStringFontSize:=Node.nodeTypedValue;
      Node:=FontNode.selectSingleNode('Color');
      if (Node <> nil) then InfoStringFontColor:=Node.nodeTypedValue;
      end;
    end;
  Node:=InfoNode.selectSingleNode('Text');
  if (Node <> nil)
   then begin
    InfoText:=Node.selectSingleNode('Chars').nodeTypedValue;
    FontNode:=Node.selectSingleNode('Font');
    if (FontNode <> nil)
     then begin
      Node:=FontNode.selectSingleNode('Name');
      if (Node <> nil) then InfoTextFontName:=Node.nodeTypedValue;
      Node:=FontNode.selectSingleNode('Size');
      if (Node <> nil) then InfoTextFontSize:=Node.nodeTypedValue;
      Node:=FontNode.selectSingleNode('Color');
      if (Node <> nil) then InfoTextFontColor:=Node.nodeTypedValue;
      end;
    end;
  Node:=InfoNode.selectSingleNode('Component');
  if (Node <> nil)
   then begin
    InfoComponent.idType:=Node.selectSingleNode('idType').nodeTypedValue;
    InfoComponent.idObj:=Node.selectSingleNode('ID').nodeTypedValue;
    end;
  StatusInfoNode:=RootNode.selectSingleNode('StatusInfo');
  if (StatusInfoNode <> nil)
   then begin
    Node:=StatusInfoNode.selectSingleNode('Text');
    if (Node <> nil) then StatusInfoText:=Node.nodeTypedValue;
    end;
  Node:=RootNode.selectSingleNode('Transparency');
  if (Node <> nil) then Transparency:=Node.nodeTypedValue;
  end;
end;

procedure THintVisualizationDATA.SetProperties;
var
  Doc: IXMLDOMDocument;
  PI: IXMLDOMProcessingInstruction;
  Root: IXMLDOMElement;
  VersionNode: IXMLDOMElement;
  InfoNode: IXMLDOMElement;
  InfoStringNode: IXMLDOMElement;
  InfoStringCharsNode: IXMLDOMElement;
  InfoStringFontNode: IXMLDOMElement;
  InfoStringFontNameNode: IXMLDOMElement;
  InfoStringFontSizeNode: IXMLDOMElement;
  InfoStringFontColorNode: IXMLDOMElement;
  InfoTextNode: IXMLDOMElement;
  InfoTextCharsNode: IXMLDOMElement;
  InfoTextFontNode: IXMLDOMElement;
  InfoTextFontNameNode: IXMLDOMElement;
  InfoTextFontSizeNode: IXMLDOMElement;
  InfoTextFontColorNode: IXMLDOMElement;
  InfoComponentNode: IXMLDOMElement;
  InfoComponentIDTypeNode: IXMLDOMElement;
  InfoComponentIDNode: IXMLDOMElement;
  StatusInfoNode: IXMLDOMElement;
  StatusInfoTextNode: IXMLDOMElement;
  TransparencyNode: IXMLDOMElement;
  OLEStream: IStream;
begin
Doc:=CoDomDocument.Create;
Doc.Set_Async(false);
PI:=Doc.createProcessingInstruction('xml', 'version=''1.0''');
Doc.insertBefore(PI, Doc.childNodes.Item[0]);
Root:=Doc.createElement('ROOT');
Root.setAttribute('xmlns:dt', 'urn:schemas-microsoft-com:datatypes');
Doc.documentElement:=Root;
VersionNode:=Doc.createElement('Version');
VersionNode.nodeTypedValue:=0;
Root.appendChild(VersionNode);
InfoNode:=Doc.createElement('Info');
Root.appendChild(InfoNode);
if (InfoString <> '')
 then begin
  InfoStringNode:=Doc.createElement('String');
    InfoStringCharsNode:=Doc.createElement('Chars');
    InfoStringCharsNode.nodeTypedValue:=InfoString;
    InfoStringNode.appendChild(InfoStringCharsNode);
  if ((InfoStringFontName <> InfoStringFontDefaultName) OR (InfoStringFontSize <> InfoStringFontDefaultSize) OR (InfoStringFontColor <> InfoStringFontDefaultColor))
   then begin
    InfoStringFontNode:=Doc.createElement('Font');
    if (InfoStringFontName <> InfoStringFontDefaultName)
     then begin
      InfoStringFontNameNode:=Doc.createElement('Name');
      InfoStringFontNameNode.nodeTypedValue:=InfoStringFontName;
      InfoStringFontNode.appendChild(InfoStringFontNameNode);
      end;
    if (InfoStringFontSize <> InfoStringFontDefaultSize)
     then begin
      InfoStringFontSizeNode:=Doc.createElement('Size');
      InfoStringFontSizeNode.nodeTypedValue:=InfoStringFontSize;
      InfoStringFontNode.appendChild(InfoStringFontSizeNode);
      end;
    if (InfoStringFontColor <> InfoStringFontDefaultColor)
     then begin
      InfoStringFontColorNode:=Doc.createElement('Color');
      InfoStringFontColorNode.nodeTypedValue:=InfoStringFontColor;
      InfoStringFontNode.appendChild(InfoStringFontColorNode);
      end;
    InfoStringNode.appendChild(InfoStringFontNode);
    end;
  InfoNode.appendChild(InfoStringNode);
  end;
if (InfoText <> '')
 then begin
  InfoTextNode:=Doc.createElement('Text');
    InfoTextCharsNode:=Doc.createElement('Chars');
    InfoTextCharsNode.nodeTypedValue:=InfoText;
    InfoTextNode.appendChild(InfoTextCharsNode);
  if ((InfoTextFontName <> InfoTextFontDefaultName) OR (InfoTextFontSize <> InfoTextFontDefaultSize) OR (InfoTextFontColor <> InfoTextFontDefaultColor))
   then begin
    InfoTextFontNode:=Doc.createElement('Font');
    if (InfoTextFontName <> InfoTextFontDefaultName)
     then begin
      InfoTextFontNameNode:=Doc.createElement('Name');
      InfoTextFontNameNode.nodeTypedValue:=InfoTextFontName;
      InfoTextFontNode.appendChild(InfoTextFontNameNode);
      end;
    if (InfoTextFontSize <> InfoTextFontDefaultSize)
     then begin
      InfoTextFontSizeNode:=Doc.createElement('Size');
      InfoTextFontSizeNode.nodeTypedValue:=InfoTextFontSize;
      InfoTextFontNode.appendChild(InfoTextFontSizeNode);
      end;
    if (InfoTextFontColor <> InfoTextFontDefaultColor)
     then begin
      InfoTextFontColorNode:=Doc.createElement('Color');
      InfoTextFontColorNode.nodeTypedValue:=InfoTextFontColor;
      InfoTextFontNode.appendChild(InfoTextFontColorNode);
      end;
    InfoTextNode.appendChild(InfoTextFontNode);
    end;
  InfoNode.appendChild(InfoTextNode);
  end;
if (InfoComponent.idObj <> 0)
 then begin
  InfoComponentNode:=Doc.createElement('Component');
    InfoComponentIDTypeNode:=Doc.createElement('idType');
    InfoComponentIDTypeNode.nodeTypedValue:=InfoComponent.idType;
    InfoComponentNode.appendChild(InfoComponentIDTypeNode);
    InfoComponentIDNode:=Doc.createElement('ID');
    InfoComponentIDNode.nodeTypedValue:=InfoComponent.idObj;
    InfoComponentNode.appendChild(InfoComponentIDNode);
  InfoNode.appendChild(InfoComponentNode);
  end;
if (StatusInfoText <> '')
 then begin
  StatusInfoNode:=Doc.createElement('StatusInfo');
  StatusInfoTextNode:=Doc.createElement('Text');
  StatusInfoTextNode.nodeTypedValue:=StatusInfoText;
  StatusInfoNode.appendChild(StatusInfoTextNode);
  Root.appendChild(StatusInfoNode);
  end;
if (Transparency <> 0)
 then begin
  TransparencyNode:=Doc.createElement('Transparency');
  TransparencyNode.nodeTypedValue:=Transparency;
  Root.appendChild(TransparencyNode);
  end;
//.
Self.Size:=0;
OLEStream:=TStreamAdapter.Create(Self);
Doc.Save(OLEStream);
end;


//. THINTVisualizationDATAFileRepository
Constructor THINTVisualizationDATAFileRepository.Create;
begin
Inherited Create;
Lock:=TCriticalSection.Create;
DATAFiles:=nil;
end;

Destructor THINTVisualizationDATAFileRepository.Destroy;
begin
Clear();
Lock.Free;
Inherited;
end;

procedure THINTVisualizationDATAFileRepository.Clear;
var
  ptrRemoveItem: pointer;
begin
Lock.Enter;
try
while (DATAFiles <> nil) do begin
  ptrRemoveItem:=DATAFiles;
  DATAFiles:=THINTVisualizationDATAFile(ptrRemoveItem^).ptrNext;
  //.
  THINTVisualizationDATAFile(ptrRemoveItem^).DATA.Free;
  FreeMem(ptrRemoveItem,SizeOf(THINTVisualizationDATAFile));
  end;
finally
Lock.Leave;
end;
end;

function THINTVisualizationDATAFileRepository.DATAFile_Exists(const pidDATAFile: integer): boolean;
var
  ptrItem: pointer;
begin
Result:=false;
Lock.Enter;
try
ptrItem:=DATAFiles;
while (ptrItem <> nil) do with THINTVisualizationDATAFile(ptrItem^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    Result:=true;
    Exit; //. ->
    end;
  ptrItem:=ptrNext;
  end;
finally
Lock.Leave;
end;
end;

function THINTVisualizationDATAFileRepository.DATAFile_AddRef(const pidDATAFile: integer): boolean;
var
  ptrItem: pointer;
begin
Result:=false;
Lock.Enter;
try
ptrItem:=DATAFiles;
while (ptrItem <> nil) do with THINTVisualizationDATAFile(ptrItem^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    Inc(RefCounter);
    Result:=true;
    Exit; //. ->
    end;
  ptrItem:=ptrNext;
  end;
finally
Lock.Leave;
end;
end;

function THINTVisualizationDATAFileRepository.DATAFile_Release(const pidDATAFile: integer): integer;
var
  ptrptrItem: pointer;
  ptrRemoveItem: pointer;
begin
Result:=0;
Lock.Enter;
try
ptrptrItem:=@DATAFiles;
while (Pointer(ptrptrItem^) <> nil) do with THINTVisualizationDATAFile(Pointer(ptrptrItem^)^) do  
  if (idDATAFile = pidDATAFile)
   then begin
    Dec(RefCounter);
    if (RefCounter = 0)
     then begin
      ptrRemoveItem:=Pointer(ptrptrItem^);
      Pointer(ptrptrItem^):=THINTVisualizationDATAFile(ptrRemoveItem^).ptrNext;
      //. free item
      THINTVisualizationDATAFile(ptrRemoveItem^).DATA.Free;
      FreeMem(ptrRemoveItem,SizeOf(THINTVisualizationDATAFile));
      end;
    Result:=RefCounter;
    Exit; //. ->
    end
   else ptrptrItem:=@ptrNext;
finally
Lock.Leave;
end;
end;

function THINTVisualizationDATAFileRepository.AddDATAFile(const pidDATAFile: integer; const DATAFileDATA: TBitmap): boolean;
var
  ptrItem: pointer;
  ptrNewItem: pointer;
begin
Result:=false;
Lock.Enter;
try
ptrItem:=DATAFiles;
while (ptrItem <> nil) do with THINTVisualizationDATAFile(ptrItem^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    Inc(RefCounter);
    //.
    FreeAndNil(DATA);
    DATA:=DATAFileDATA;
    //.
    Result:=true;
    Exit; //. ->
    end;
  ptrItem:=ptrNext;
  end;
GetMem(ptrNewItem,SizeOf(THINTVisualizationDATAFile));
with THINTVisualizationDATAFile(ptrNewItem^) do begin
ptrNext:=DATAFiles;
RefCounter:=1;
idDATAFile:=pidDATAFile;
DATA:=DATAFileDATA;
flSaved:=false;
end;
DATAFiles:=ptrNewItem;
Result:=true;
finally
Lock.Leave;
end;
end;

function THINTVisualizationDATAFileRepository.DATAFile_Lock(const pidDATAFile: integer; out DATAFilePtr: pointer): boolean;
var
  ptrptrItem: pointer;
begin
Result:=false;
Lock.Enter;
try
ptrptrItem:=@DATAFiles;
while (Pointer(ptrptrItem^) <> nil) do with THINTVisualizationDATAFile(Pointer(ptrptrItem^)^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    DATAFilePtr:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    THINTVisualizationDATAFile(DATAFilePtr^).ptrNext:=DATAFiles;
    DATAFiles:=DATAFilePtr;
    Result:=true;
    Exit; //. ->
    end;
  ptrptrItem:=@ptrNext;
  end;
finally
if (NOT Result) then Lock.Leave;
end;
end;

procedure THINTVisualizationDATAFileRepository.DATAFile_Unlock(const DATAFilePtr: pointer);
begin
Lock.Leave;
end;


//. TTHINTVisualizationCash
Constructor TTHINTVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
DATAFileRepository:=THINTVisualizationDATAFileRepository.Create;
FItems:=nil;
Index:=TIDsCach.Create();
end;

destructor TTHINTVisualizationCash.Destroy;
begin
Empty();
Index.Free;
DATAFileRepository.Free;
Inherited;
end;

procedure TTHINTVisualizationCash.DestroyItem(var ptrDestroyItem: pointer);
begin
DATAFileRepository.DATAFile_Release(TItemTHINTVisualizationCash(ptrDestroyItem^).idDATAFile);
TItemTHINTVisualizationCash(ptrDestroyItem^).DATA.Free();
FreeMem(ptrDestroyItem,SizeOf(TItemTHINTVisualizationCash));
ptrDestroyItem:=nil;
end;

procedure TTHINTVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
repeat
  TypeSystem.Lock.Enter();
  try
  if (FItems = nil) then Exit; //. ->
  ptrDelItem:=FItems;
  FItems:=TItemTHINTVisualizationCash(ptrDelItem^).ptrNext;
  Index[TItemTHINTVisualizationCash(ptrDelItem^).idObj]:=nil;
  finally
  TypeSystem.Lock.Leave();
  end;
  if (ptrDelItem <> nil) then DestroyItem(ptrDelItem);
until (false);
end;

procedure TTHINTVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  ptrptr,ptrDestroyItem: pointer;
  CF: THINTVisualizationFunctionality;
  DS: TMemoryStream;
  CDT: TComponentFileType;
  BMPDATA: TBitmap;
  ptrActionsGroup: pointer;
  ItemsList: TList;
  IDs: TByteArray;
  IC: integer;
  p: pointer;
  ItemsData: TByteArray;
  ItemID: integer;
  DataSize: integer;
  GetDATAMask: array of boolean;
begin
if (List.Count = 0) then Exit; //. ->
if (NOT Space.flActionsGroupCall OR (List.Count = 1))
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTHINTVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTHINTVisualizationCash), 0);
    with TItemTHINTVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    DATA:=nil;
    CF:=THINTVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    idDATAFile:=CF.DATAFileID;
    if (idDATAFile <> 0)
     then begin
      if (NOT DATAFileRepository.DATAFile_AddRef(idDATAFile))
       then begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        BMPDATA:=TBitmap.Create;
        try
        BMPDATA.LoadFromStream(DS);
        except
          BMPDATA.Destroy;
          Raise; //. =>
          end;
        if (NOT DATAFileRepository.AddDATAFile(idDATAFile,BMPDATA)) then BMPDATA.Destroy;
        finally
        DS.Destroy;
        end;
        end;
      end;
    CF.GetPrivateDATA(DATA,Space.Configuration.VisualizationMaxSize);
    with THintVisualizationDATA.Create(DATA) do
    try
    ParsedDataV1.InfoString:=InfoString;
    ParsedDataV1.InfoStringFontName:=InfoStringFontName;
    ParsedDataV1.InfoStringFontSize:=InfoStringFontSize;
    ParsedDataV1.InfoStringFontColor:=InfoStringFontColor;
    ParsedDataV1.InfoText:=InfoText;
    ParsedDataV1.InfoTextFontName:=InfoTextFontName;
    ParsedDataV1.InfoTextFontSize:=InfoTextFontSize;
    ParsedDataV1.InfoTextFontColor:=InfoTextFontColor;
    ParsedDataV1.InfoComponent:=InfoComponent;
    ParsedDataV1.StatusInfoText:=StatusInfoText;
    ParsedDataV1.Transparency:=Transparency;
    finally
    Destroy;
    end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter();
    try
    TItemTHINTVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    if (FItems <> nil) then Index[TItemTHINTVisualizationCash(FItems^).idObj]:=ptrNewItem;
    FItems:=ptrNewItem;
    ptrptr:=Index[TItemTHINTVisualizationCash(ptrNewItem^).idObj];
    Index[TItemTHINTVisualizationCash(ptrNewItem^).idObj]:=Pointer(@FItems);
    ptrDestroyItem:=nil;
    if (ptrptr <> nil)
     then begin
      ptrDestroyItem:=Pointer(ptrptr^);
      Pointer(ptrptr^):=TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext;
      if (TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext <> nil) then Index[TItemTHINTVisualizationCash(TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext^).idObj]:=ptrptr;
      end;
    finally
    TypeSystem.Lock.Leave();
    end;
    if (ptrDestroyItem <> nil) then DestroyItem(ptrDestroyItem);
    end
 else begin
  ItemsList:=TList.Create();
  try
  IC:=List.Count;
  SetLength(IDs,SizeOf(IC)+IC*SizeOf(Integer));
  p:=@IDs[0];
  Integer(p^):=IC; Inc(DWord(p),SizeOf(IC));
  for I:=0 to List.Count-1 do begin
    Integer(p^):=Integer(List[I]);
    Inc(DWord(p),SizeOf(Integer));
    end;
  try
  with TTHINTVisualizationFunctionality.Create() do
  try
  GetInstanceParams(IDs,Space.Configuration.VisualizationMaxSize,{out} ItemsData);
  finally
  Release();
  end;
  if (Length(ItemsData) > 0)
   then begin
    p:=@ItemsData[0];
    IC:=Integer(p^); Inc(DWord(p),SizeOf(IC));
    ItemsList.Capacity:=IC;
    for I:=0 to IC-1 do begin
      ItemID:=Integer(p^); Inc(DWord(p),SizeOf(ItemID));
      //.
      GetMem(ptrNewItem,SizeOf(TItemTHINTVisualizationCash));
      try
      FillChar(ptrNewItem^,SizeOf(TItemTHINTVisualizationCash), 0);
      with TItemTHINTVisualizationCash(ptrNewItem^) do begin
      idObj:=ItemID;
      //.
      idDATAFile:=Integer(p^); Inc(DWord(p),SizeOf(idDATAFile));
      //.
      DATA:=nil;
      DataSize:=Integer(p^); Inc(DWord(p),SizeOf(DataSize));
      if (DataSize > 0)
       then begin
        DATA:=TMemoryStream.Create();
        DATA.Write(p^,DataSize); Inc(DWord(p),DataSize);
        with THintVisualizationDATA.Create(DATA) do
        try
        ParsedDataV1.InfoString:=InfoString;
        ParsedDataV1.InfoStringFontName:=InfoStringFontName;
        ParsedDataV1.InfoStringFontSize:=InfoStringFontSize;
        ParsedDataV1.InfoStringFontColor:=InfoStringFontColor;
        ParsedDataV1.InfoText:=InfoText;
        ParsedDataV1.InfoTextFontName:=InfoTextFontName;
        ParsedDataV1.InfoTextFontSize:=InfoTextFontSize;
        ParsedDataV1.InfoTextFontColor:=InfoTextFontColor;
        ParsedDataV1.InfoComponent:=InfoComponent;
        ParsedDataV1.StatusInfoText:=StatusInfoText;
        ParsedDataV1.Transparency:=Transparency;
        finally
        Destroy;
        end;
        end;
      end;
      except
        On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(ItemID)+') could not be cached',E.Message);
        end;
      ItemsList.Add(ptrNewItem);
      end;
    end;
  except
    On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Items of '+TypeSystem.TableName+' could not be cached','TTHINTVisualizationFunctionality.GetInstanceParams(): '+E.Message);
    end;
  //.
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  (* ///- last (slow) version
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTHINTVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTHINTVisualizationCash), 0);
    with TItemTHINTVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    DATA:=nil;
    CF:=THINTVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try idDATAFile:=CF.DATAFileID; except on E: EActionsGroup do ; else Raise; end;
    try CF.GetPrivateDATA(DATA,Space.Configuration.VisualizationMaxSize); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTHINTVisualizationCash(ItemsList[I]^) do with THINTVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    idDATAFile:=DATAFileID;
    GetPrivateDATA(DATA,Space.Configuration.VisualizationMaxSize);
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(ItemsList[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  ActionsGroups.ActionsGroup_Start(ptrActionsGroup);
  try
  *)
  SetLength(GetDATAMask,ItemsList.Count);
  for I:=0 to ItemsList.Count-1 do if (ItemsList[I] <> nil) then with TItemTHINTVisualizationCash(ItemsList[I]^) do with THINTVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if (idDATAFile <> 0)
     then
      if (DATAFileRepository.DATAFile_AddRef(idDATAFile))
       then GetDATAMask[I]:=false
       else begin
        try GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize); except on E: EActionsGroup do ; else Raise; end;
        GetDATAMask[I]:=true;
        end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item DATAFile of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(ItemsList[I]))+') could not be prepared for caching',E.Message);
      end;
    finally
    Release;
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do if (ItemsList[I] <> nil) then with TItemTHINTVisualizationCash(ItemsList[I]^) do with THINTVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if ((idDATAFile <> 0) AND GetDATAMask[I])
     then begin
      GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
      try
      BMPDATA:=TBitmap.Create;
      try
      BMPDATA.LoadFromStream(DS);
      except
        BMPDATA.Destroy;
        Raise; //. =>
        end;
      if (NOT DATAFileRepository.AddDATAFile(idDATAFile,BMPDATA)) then BMPDATA.Destroy;
      finally
      DS.Destroy;
      end;
      end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item DATAFile of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(ItemsList[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  (* ///- last (slow) version
  except
    end;
  *)
  for I:=0 to ItemsList.Count-1 do if (ItemsList[I] <> nil) then begin
    TypeSystem.Lock.Enter();
    try
    TItemTHINTVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
    if (FItems <> nil) then Index[TItemTHINTVisualizationCash(FItems^).idObj]:=ItemsList[I];
    FItems:=ItemsList[I];
    ptrptr:=Index[TItemTHINTVisualizationCash(ItemsList[I]^).idObj];
    Index[TItemTHINTVisualizationCash(ItemsList[I]^).idObj]:=Pointer(@FItems);
    ptrDestroyItem:=nil;
    if (ptrptr <> nil)
     then begin
      ptrDestroyItem:=Pointer(ptrptr^);
      Pointer(ptrptr^):=TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext;
      if (TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext <> nil) then Index[TItemTHINTVisualizationCash(TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext^).idObj]:=ptrptr;
      end;
    finally
    TypeSystem.Lock.Leave();
    end;
    if (ptrDestroyItem <> nil) then DestroyItem(ptrDestroyItem);
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;

procedure TTHINTVisualizationCash.Update;
begin
Empty;
end;

function TTHINTVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if (ptrItem = nil)
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTHINTVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=Index[pidObj];
if (ptrptrItem = nil) then Exit; //. ->
Result:=Pointer(ptrptrItem^);
{//. last version
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTHINTVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTHINTVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTHINTVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTHINTVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTHINTVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTHINTVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: THINTVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
  begin
  with TItemTHINTVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=THINTVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  _idDATAFile:=CF.DATAFileID;
  if (idDATAFile <> _idDATAFile)
   then begin
    //. free last
    FreeAndNil(ImageDATA);
    //.
    ???if (_idDATAFile <> 0) then if (NOT GetComponentFile(_idDATAFile, DS)) then CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
    idDATAFile:=_idDATAFile;
    try
    ImageDATA:=TBitmap.Create;
    ImageDATA.LoadFromStream(DS);
    finally
    DS.Destroy;
    end;
    end;
  //.
  FreeAndNil(DATA);
  CF.GetPrivateDATA(DATA,Space.Configuration.VisualizationMaxSize);
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrptr,ptrDestroyItem: pointer;
  ptrUpdateItem: pointer;
begin
ptrDestroyItem:=nil;
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTHINTVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTHINTVisualizationCash), 0);
  with TItemTHINTVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  idDATAFile:=0;
  ImageDATA:=nil;
  DATA:=nil;
  end;
  UpdateItem(ptrNewItem);
  if (FItems <> nil) then Index[TItemTHINTVisualizationCash(FItems^).idObj]:=ptrNewItem;
  FItems:=ptrNewItem;
  ptrptr:=Index[TItemTHINTVisualizationCash(ptrNewItem^).idObj];
  Index[TItemTHINTVisualizationCash(ptrNewItem^).idObj]:=Pointer(@FItems);
  if (ptrptr <> nil)
   then begin
    Pointer(ptrptr^);
    Pointer(ptrptr^):=TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext;
    if (TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext <> nil) then Index[TItemTHINTVisualizationCash(TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext^).idObj]:=ptrptr;
    end;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTHINTVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTHINTVisualizationCash), 0);
    with TItemTHINTVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    idDATAFile:=0;
    ImageDATA:=nil;
    DATA:=nil;
    end;
    UpdateItem(ptrNewItem);
    if (FItems <> nil) then Index[TItemTHINTVisualizationCash(FItems^).idObj]:=ptrNewItem;
    FItems:=ptrNewItem;
    ptrptr:=Index[TItemTHINTVisualizationCash(ptrNewItem^).idObj];
    Index[TItemTHINTVisualizationCash(ptrNewItem^).idObj]:=Pointer(@FItems);
    if (ptrptr <> nil)
     then begin
      ptrDestroyItem:=Pointer(ptrptr^);
      Pointer(ptrptr^):=TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext;
      if (TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext <> nil) then Index[TItemTHINTVisualizationCash(TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext^).idObj]:=ptrptr;
      end;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
if (ptrDestroyItem <> nil) then DestroyItem(ptrDestroyItem);
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTHINTVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: THINTVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
    ImageDATA: TBitmap;
  begin
  with TItemTHINTVisualizationCash(ptrItem^) do begin
  //. updating item
  try
  CF:=THINTVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  _idDATAFile:=CF.DATAFileID;
  if (idDATAFile <> _idDATAFile)
   then begin
    //. free last
    if (idDATAFile <> 0) then DATAFileRepository.DATAFile_Release(idDATAFile);
    //.
    idDATAFile:=_idDATAFile;
    if (idDATAFile <> 0)
     then
      if (NOT DATAFileRepository.DATAFile_AddRef(idDATAFile))
       then begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        ImageDATA:=TBitmap.Create;
        try
        ImageDATA.LoadFromStream(DS);
        except
          ImageDATA.Destroy;
          Raise; //. =>
          end;
        if (NOT DATAFileRepository.AddDATAFile(idDATAFile,ImageDATA)) then ImageDATA.Destroy;
        finally
        DS.Destroy;
        end;
        end;
    end;
  //.
  FreeAndNil(DATA);
  CF.GetPrivateDATA(DATA,Space.Configuration.VisualizationMaxSize);
  with THintVisualizationDATA.Create(DATA) do
  try
  ParsedDataV1.InfoString:=InfoString;
  ParsedDataV1.InfoStringFontName:=InfoStringFontName;
  ParsedDataV1.InfoStringFontSize:=InfoStringFontSize;
  ParsedDataV1.InfoStringFontColor:=InfoStringFontColor;
  ParsedDataV1.InfoText:=InfoText;
  ParsedDataV1.InfoTextFontName:=InfoTextFontName;
  ParsedDataV1.InfoTextFontSize:=InfoTextFontSize;
  ParsedDataV1.InfoTextFontColor:=InfoTextFontColor;
  ParsedDataV1.InfoComponent:=InfoComponent;
  ParsedDataV1.StatusInfoText:=StatusInfoText;
  ParsedDataV1.Transparency:=Transparency;
  finally
  Destroy;
  end;
  finally
  CF.Release;
  end;
  except
    if (idDATAFile <> 0) then DATAFileRepository.DATAFile_Release(idDATAFile);
    FreeAndNil(DATA);
    Raise; //. =>
    end;
  end;
  end;

  procedure CopyToItem(const ptrItem: pointer; var Item: TItemTHINTVisualizationCash);
  begin
  Item:=TItemTHINTVisualizationCash(ptrItem^);
  //. copy item reference fields
  if (Item.idDATAFile <> 0) then DATAFileRepository.DATAFile_AddRef(Item.idDATAFile);
  if (TItemTHINTVisualizationCash(ptrItem^).DATA <> nil)
   then begin
    Item.DATA:=TMemoryStream.Create;
    Item.DATA.LoadFromStream(TItemTHINTVisualizationCash(ptrItem^).DATA);
    with THintVisualizationDATA.Create(Item.DATA) do
    try
    Item.ParsedDataV1.InfoString:=InfoString;
    Item.ParsedDataV1.InfoStringFontName:=InfoStringFontName;
    Item.ParsedDataV1.InfoStringFontSize:=InfoStringFontSize;
    Item.ParsedDataV1.InfoStringFontColor:=InfoStringFontColor;
    Item.ParsedDataV1.InfoText:=InfoText;
    Item.ParsedDataV1.InfoTextFontName:=InfoTextFontName;
    Item.ParsedDataV1.InfoTextFontSize:=InfoTextFontSize;
    Item.ParsedDataV1.InfoTextFontColor:=InfoTextFontColor;
    Item.ParsedDataV1.InfoComponent:=InfoComponent;
    Item.ParsedDataV1.StatusInfoText:=StatusInfoText;
    Item.ParsedDataV1.Transparency:=Transparency;
    finally
    Destroy;
    end;
    end;
  end;

  procedure MoveItem(const Item: TItemTHINTVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTHINTVisualizationCash(ptrItem^) do begin
  if (idDATAFile <> Item.idDATAFile)
   then begin
    if (idDATAFile <> 0) then DATAFileRepository.DATAFile_Release(idDATAFile);
    //.
    idDATAFile:=Item.idDATAFile;
    if (idDATAFile <> 0) then DATAFileRepository.DATAFile_AddRef(idDATAFile);
    end
   else if (Item.idDATAFile <> 0) then DATAFileRepository.DATAFile_Release(Item.idDATAFile);
  //.
  FreeAndNil(DATA);
  DATA:=Item.DATA;
  with THintVisualizationDATA.Create(DATA) do
  try
  ParsedDataV1.InfoString:=InfoString;
  ParsedDataV1.InfoStringFontName:=InfoStringFontName;
  ParsedDataV1.InfoStringFontSize:=InfoStringFontSize;
  ParsedDataV1.InfoStringFontColor:=InfoStringFontColor;
  ParsedDataV1.InfoText:=InfoText;
  ParsedDataV1.InfoTextFontName:=InfoTextFontName;
  ParsedDataV1.InfoTextFontSize:=InfoTextFontSize;
  ParsedDataV1.InfoTextFontColor:=InfoTextFontColor;
  ParsedDataV1.InfoComponent:=InfoComponent;
  ParsedDataV1.StatusInfoText:=StatusInfoText;
  ParsedDataV1.Transparency:=Transparency;
  finally
  Destroy;
  end;
  end;
  end;

  procedure FreeItem(var Item: TItemTHINTVisualizationCash);
  begin
  if (Item.idDATAFile <> 0) then DATAFileRepository.DATAFile_Release(Item.idDATAFile);
  FreeAndNil(Item.DATA);
  end;

var
  ptrNewItem: pointer;
  ptrptr,ptrDestroyItem: pointer;
  ptrUpdateItem: pointer;
  Item: TItemTHINTVisualizationCash;
begin
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTHINTVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTHINTVisualizationCash), 0);
  with TItemTHINTVisualizationCash(ptrNewItem^) do begin
  idObj:=pidObj;
  idDATAFile:=0;
  DATA:=nil;
  end;
  UpdateItem(ptrNewItem);
  //.
  TypeSystem.Lock.Enter();
  try
  TItemTHINTVisualizationCash(ptrNewItem^).ptrNext:=FItems;
  if (FItems <> nil) then Index[TItemTHINTVisualizationCash(FItems^).idObj]:=ptrNewItem;
  FItems:=ptrNewItem;
  ptrptr:=Index[TItemTHINTVisualizationCash(ptrNewItem^).idObj];
  Index[TItemTHINTVisualizationCash(ptrNewItem^).idObj]:=Pointer(@FItems);
  ptrDestroyItem:=nil;
  if (ptrptr <> nil)
   then begin
    ptrDestroyItem:=Pointer(ptrptr^);
    Pointer(ptrptr^):=TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext;
    if (TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext <> nil) then Index[TItemTHINTVisualizationCash(TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext^).idObj]:=ptrptr;
    end;
  finally
  TypeSystem.Lock.Leave();
  end;
  if (ptrDestroyItem <> nil) then DestroyItem(ptrDestroyItem);
  end;
opUpdate: begin
  TypeSystem.Lock.Enter;
  try
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil) then CopyToItem(ptrUpdateItem, Item);
  finally
  TypeSystem.Lock.Leave;
  end;
  if (ptrUpdateItem <> nil)
   then begin
    UpdateItem(@Item);
    //.
    TypeSystem.Lock.Enter;
    try
    ptrUpdateItem:=GetPtrItem(pidObj);
    if (ptrUpdateItem <> nil)
     then MoveItem(Item,ptrUpdateItem)
     else FreeItem(Item);
    finally
    TypeSystem.Lock.Leave;
    end;
    end
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTHINTVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTHINTVisualizationCash), 0);
    with TItemTHINTVisualizationCash(ptrNewItem^) do begin
    idObj:=pidObj;
    idDATAFile:=0;
    DATA:=nil;
    end;
    UpdateItem(ptrNewItem);
    //.
    TypeSystem.Lock.Enter();
    try
    TItemTHINTVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    if (FItems <> nil) then Index[TItemTHINTVisualizationCash(FItems^).idObj]:=ptrNewItem;
    FItems:=ptrNewItem;
    ptrptr:=Index[TItemTHINTVisualizationCash(ptrNewItem^).idObj];
    Index[TItemTHINTVisualizationCash(ptrNewItem^).idObj]:=Pointer(@FItems);
    ptrDestroyItem:=nil;
    if (ptrptr <> nil)
     then begin
      ptrDestroyItem:=Pointer(ptrptr^);
      Pointer(ptrptr^):=TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext;
      if (TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext <> nil) then Index[TItemTHINTVisualizationCash(TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext^).idObj]:=ptrptr;
      end;
    finally
    TypeSystem.Lock.Leave();
    end;
    if (ptrDestroyItem <> nil) then DestroyItem(ptrDestroyItem);
    end;
  end;
opDestroy: begin
  TypeSystem.Lock.Enter;
  try
  RemoveItem(pidObj);
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
end;
end;

procedure TTHINTVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
ptrDelItem:=nil;
TypeSystem.Lock.Enter();
try
ptrptrDelItem:=Index[pidObj];
if (ptrptrDelItem <> nil)
 then begin
  Index[pidObj]:=nil;
  ptrDelItem:=Pointer(ptrptrDelItem^);
  Pointer(ptrptrDelItem^):=TItemTHINTVisualizationCash(ptrDelItem^).ptrNext;
  if (TItemTHINTVisualizationCash(ptrDelItem^).ptrNext <> nil) then Index[TItemTHINTVisualizationCash(TItemTHINTVisualizationCash(ptrDelItem^).ptrNext^).idObj]:=ptrptrDelItem;
  end
{last version
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTHINTVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if (idObj = pidObj)
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTHINTVisualizationCash(ptrDelItem^).ptrNext;
    //.
    DestroyItem(ptrDelItem); ///!!! may be deadlock make as above
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTHINTVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;}
finally
TypeSystem.Lock.Leave();
end;
if (ptrDelItem <> nil) then DestroyItem(ptrDelItem);
end;

procedure TTHINTVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetDATA(const ImageDATA: TBitmap): OLEVariant;
  var
    MS: TMemoryStream;
    DATAPtr: pointer;
  begin
  MS:=TMemoryStream.Create;
  with MS do
  try
  if (ImageDATA <> nil)
   then begin
    ImageDATA.SaveToStream(MS);
    Position:=0;
    end;
  Result:=VarArrayCreate([0,Size-1],varByte);
  DATAPtr:=VarArrayLock(Result);
  try
  Read(DATAPtr^,Size);
  finally
  VarArrayUnLock(Result);
  end;
  finally
  Destroy;
  end;
  end;

  function GetPrivateDATA(const DATA: TMemoryStream): OLEVariant;
  var
    MS: TMemoryStream;
    DATAPtr: pointer;
  begin
  MS:=TMemoryStream.Create;
  with MS do
  try
  if (DATA <> nil)
   then begin
    DATA.Position:=0;
    DATA.SaveToStream(MS);
    Position:=0;
    end;
  Result:=VarArrayCreate([0,Size-1],varByte);
  DATAPtr:=VarArrayLock(Result);
  try
  Read(DATAPtr^,Size);
  finally
  VarArrayUnLock(Result);
  end;
  finally
  Destroy;
  end;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
  //.
  DATAFilePtr: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTHINTVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('idDATAFile');       PropNode.nodeTypedValue:=idDATAFile;    ItemNode.appendChild(PropNode);
  //.
  if (DATAFIleRepository.DATAFile_Lock(idDATAFile,{out} DATAFilePtr))
   then with THINTVisualizationDATAFile(DATAFilePtr^) do
    try
    if (NOT flSaved)
     then begin
      PropNode:=Document.CreateElement('ImageDATA');
      PropNode.Set_dataType('bin.base64');
      PropNode.nodeTypedValue:=GetDATA(DATA);
      ItemNode.appendChild(PropNode);
      //.
      flSaved:=true;
      end;
    finally
    DATAFIleRepository.DATAFile_Unlock(DATAFilePtr);
    end;
  //.
  PropNode:=Document.CreateElement('DATA');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetPrivateDATA(DATA);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTHINTVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetDATA(DATA: Variant; out ImageDATA: TBitmap);
  var
    DATASize: integer;
    DATAPtr: pointer;
    MS: TMemoryStream;
  begin
  ImageDATA:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    MS:=TMemoryStream.Create;
    with MS do
    try
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    ImageDATA:=TBitmap.Create;
    ImageDATA.LoadFromStream(MS);
    finally
    Destroy;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(ImageDATA);
    Raise; //. =>
    end;
  end;

  procedure SetPrivateDATA(_DATA: Variant; out DATA: TMemoryStream);
  var
    DATASize: integer;
    DATAPtr: pointer;
  begin
  DATA:=nil;
  try
  if (_DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(_DATA,1)+1;
    DATAPtr:=VarArrayLock(_DATA);
    try
    DATA:=TMemoryStream.Create;
    with DATA do begin
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    end;
    finally
    VarArrayUnLock(_DATA);
    end;
    end;
  except
    FreeAndNil(DATA);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  ImageDATANode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  ptrptr,ptrDestroyItem: pointer;
  //.
  _idDATAFile: integer;
  _ImageDATA: Variant;
  _DATA: Variant;
  //.
  ImageDATA: TBitmap;
begin
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _idDATAFile:=ItemNode.selectSingleNode('idDATAFile').nodeTypedValue;
  ImageDATANode:=ItemNode.selectSingleNode('ImageDATA');
  if (ImageDATANode <> nil)
   then _ImageDATA:=ImageDATANode.nodeTypedValue
   else _ImageDATA:=null;
  _DATA:=ItemNode.selectSingleNode('DATA').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTHINTVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTHINTVisualizationCash), 0);
  with TItemTHINTVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  idDATAFile:=_idDATAFile;
  if (idDATAFile <> 0) 
   then begin
    if (NOT DATAFileRepository.DATAFile_AddRef(idDATAFile))
     then begin
      if (_ImageDATA <> null)
       then begin
        SetDATA(_ImageDATA, ImageDATA);
        if (NOT DATAFileRepository.AddDATAFile(idDATAFile,ImageDATA)) then ImageDATA.Destroy;
        end
       else EventLog.WriteMinorEvent('TTHINTVisualizationCache.LoadItems()','Could not restore HINTVisualization item ('+IntToStr(id)+') from stored context','DATAFile (ID: '+IntToStr(idDATAFile)+') was not found in repository');
      end;
    end;
  SetPrivateDATA(_DATA, DATA);
  with THintVisualizationDATA.Create(DATA) do
  try
  ParsedDataV1.InfoString:=InfoString;
  ParsedDataV1.InfoStringFontName:=InfoStringFontName;
  ParsedDataV1.InfoStringFontSize:=InfoStringFontSize;
  ParsedDataV1.InfoStringFontColor:=InfoStringFontColor;
  ParsedDataV1.InfoText:=InfoText;
  ParsedDataV1.InfoTextFontName:=InfoTextFontName;
  ParsedDataV1.InfoTextFontSize:=InfoTextFontSize;
  ParsedDataV1.InfoTextFontColor:=InfoTextFontColor;
  ParsedDataV1.InfoComponent:=InfoComponent;
  ParsedDataV1.StatusInfoText:=StatusInfoText;
  ParsedDataV1.Transparency:=Transparency;
  finally
  Destroy;
  end;
  end;
  TypeSystem.Lock.Enter();
  try
  if (FItems <> nil) then Index[TItemTHINTVisualizationCash(FItems^).idObj]:=ptrNewItem;
  FItems:=ptrNewItem;
  ptrptr:=Index[TItemTHINTVisualizationCash(ptrNewItem^).idObj];
  Index[TItemTHINTVisualizationCash(ptrNewItem^).idObj]:=Pointer(@FItems);
  ptrDestroyItem:=nil;
  if (ptrptr <> nil)
   then begin
    ptrDestroyItem:=Pointer(ptrptr^);
    Pointer(ptrptr^):=TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext;
    if (TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext <> nil) then Index[TItemTHINTVisualizationCash(TItemTHINTVisualizationCash(ptrDestroyItem^).ptrNext^).idObj]:=ptrptr;
    end;
  finally
  TypeSystem.Lock.Leave();
  end;
  if (ptrDestroyItem <> nil) then DestroyItem(ptrDestroyItem);
  end;
end;



//. Detailed picture-визуализация
{TSystemTDetailedPictureVisualization}

procedure TDetailedPictureVisualizationCashItemLevel_FreeAndNilSegments(const TypeSystem: TSystemTDetailedPictureVisualization; var Segments: pointer);
var
  ptrDestroySegment: pointer;
begin
while (Segments <> nil) do begin
  ptrDestroySegment:=Segments;
  Segments:=TSegmentItemOfTDetailedPictureVisualizationCash(ptrDestroySegment^).ptrNext;
  //.
  if (TypeSystem.SegmentsOGLTextures.flEnabled AND (TypeSystem.Cash.Segment_idOGLTexture(ptrDestroySegment) <> 0)) then TypeSystem.SegmentsOGLTextures.DeleteSegmentTexture(ptrDestroySegment);
  //.
  TypeSystem.Cash.Segment_SetDATA(ptrDestroySegment,nil);
  //.
  TypeSystem.Cash.AccessedSegmentsRevising.Remove(ptrDestroySegment);
  //.
  FreeMem(ptrDestroySegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
  end;
end;


procedure TDetailedPictureVisualizationCashItem_FreeAndNilLevels(const TypeSystem: TSystemTDetailedPictureVisualization; var Levels: pointer);
var
  ptrDestroyLevel: pointer;
begin
while (Levels <> nil) do begin
  ptrDestroyLevel:=Levels;
  Levels:=TLevelItemOfTDetailedPictureVisualizationCash(ptrDestroyLevel^).ptrNext;
  //.
  TLevelItemOfTDetailedPictureVisualizationCash(ptrDestroyLevel^).Lock.BeginWrite;
  try
  TDetailedPictureVisualizationCashItemLevel_FreeAndNilSegments(TypeSystem,TLevelItemOfTDetailedPictureVisualizationCash(ptrDestroyLevel^).Segments);
  finally
  TLevelItemOfTDetailedPictureVisualizationCash(ptrDestroyLevel^).Lock.EndWrite;
  end;
  //.
  TLevelItemOfTDetailedPictureVisualizationCash(ptrDestroyLevel^).SegmentLock.Destroy;
  //.
  TLevelItemOfTDetailedPictureVisualizationCash(ptrDestroyLevel^).Lock.Destroy;
  //.
  FreeMem(ptrDestroyLevel,SizeOf(TLevelItemOfTDetailedPictureVisualizationCash));
  end;
end;

procedure TDetailedPictureVisualizationCashItem_PrepareLevelsFromByteArray(const pptrItem: pointer; var Levels: pointer; const BA: TByteArray);
var
  LevelsCount: integer;
  I: integer;
  ptrNewLevel: pointer;
begin
LevelsCount:=(Length(BA) DIV SizeOf(TDetailedPictureVisualizationLevel));
for I:=0 to LevelsCount-1 do begin
  GetMem(ptrNewLevel,SizeOf(TLevelItemOfTDetailedPictureVisualizationCash));
  with TLevelItemOfTDetailedPictureVisualizationCash(ptrNewLevel^) do begin
  ptrNext:=Levels;
  ptrItem:=pptrItem;
  //.
  LevelIndex:=LevelsCount-I-1;
  Lock:=TMultiReadExclusiveWriteSynchronizer.Create;
  SegmentLock:=TCriticalSection.Create;
  Disabled:=false;
  flPersist:=false;
  Params:=TDetailedPictureVisualizationLevel(Pointer(@BA[I*SizeOf(TDetailedPictureVisualizationLevel)])^);
  Segments:=nil;
  end;
  Levels:=ptrNewLevel;
  end;
end;


function TDetailedPictureVisualizationCashItemLevelSegments_Insert(var Segments: pointer; const ptrSegment: pointer; const ptrptrExistedSegment: pointer = nil): boolean;
var
  XI,YI: integer;
  ptrptrSegment: pointer;
begin
with TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^).Params do begin
XI:=XIndex;
YI:=YIndex;
end;
//.
ptrptrSegment:=@Segments;
while (Pointer(ptrptrSegment^) <> nil) AND (YI > TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).Params.YIndex) do begin
  ptrptrSegment:=@TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).ptrNext;
  end;
while (Pointer(ptrptrSegment^) <> nil) AND ((YI = TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).Params.YIndex) AND (XI > TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).Params.XIndex)) do begin
  ptrptrSegment:=@TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).ptrNext;
  end;
if (NOT ((Pointer(ptrptrSegment^) <> nil) AND ((YI = TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).Params.YIndex) AND (XI = TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).Params.XIndex))))
 then begin
  TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^).ptrNext:=Pointer(ptrptrSegment^);
  Pointer(ptrptrSegment^):=ptrSegment;
  Result:=true;
  end
 else begin
  if (ptrptrExistedSegment <> nil) then Pointer(ptrptrExistedSegment^):=Pointer(ptrptrSegment^);
  Result:=false;
  end;
end;

procedure TDetailedPictureVisualizationCashItemLevel_PrepareSegmentsFromByteArray(const TypeSystem: TSystemTDetailedPictureVisualization; const idDetailedPictureVisualization: integer; const ptrLevel: pointer; const BA: TByteArray; ItemsList: TList = nil; const flAllItemsInList: boolean = false);
var
  P,Pend: pointer;
  LevelFolder: string;
  ptrNewSegment: pointer;
  DATASize: integer;
  SegmentFileName: string;
  ptrExistedItem: pointer;
begin
with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
Lock.BeginRead;
try
P:=@BA[0];
Pend:=Pointer(Integer(P)+Length(BA));
if (P <> Pend)
 then begin
  LevelFolder:=TypeSystem.Cash.Item_Level__GetContextFolder(idDetailedPictureVisualization,Params.ID);
  ForceDirectories(LevelFolder);
  repeat
    GetMem(ptrNewSegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
    with TSegmentItemOfTDetailedPictureVisualizationCash(ptrNewSegment^) do begin
    ptrNext:=nil;
    Lock:=TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).SegmentLock;
    with Params do begin
    id:=Integer(P^); Inc(DWord(P),SizeOf(id));
    XIndex:=Integer(P^); Inc(DWord(P),SizeOf(XIndex));
    YIndex:=Integer(P^); Inc(DWord(P),SizeOf(YIndex));
    DATASize:=Integer(P^); Inc(DWord(P),SizeOf(DATASize));
    _DATA:=TMemoryStream.Create;
    if (DATASize > 0)
     then begin
      _DATA.Size:=DATASize;
      _DATA.Write(P^,DATASize);
      Inc(DWord(P),DATASize);
      end;
    end;
    _idOGLTexture:=0;
    end;
    //.
    Lock.BeginWrite;
    try
    if (TDetailedPictureVisualizationCashItemLevelSegments_Insert(Segments,ptrNewSegment,@ptrExistedItem))
     then begin
      TypeSystem.Cash.AccessedSegmentsRevising.Add(ptrNewSegment,ptrLevel,idDetailedPictureVisualization); //. process segment as accessed
      if (ItemsList <> nil) then ItemsList.Add(ptrNewSegment);
      end
     else begin
      if ((ItemsList <> nil) AND flAllItemsInList) then ItemsList.Add(ptrExistedItem);
      FreeAndNil(TSegmentItemOfTDetailedPictureVisualizationCash(ptrNewSegment^).Params._DATA);
      FreeMem(ptrNewSegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
      ptrNewSegment:=nil;
      end;
    finally
    Lock.EndWrite;
    end;
    //.
    if (ptrNewSegment <> nil)
     then with TSegmentItemOfTDetailedPictureVisualizationCash(ptrNewSegment^).Params do begin //. save new segment into the local file
      //.
      TypeSystem.Cash.Segment_Lock(ptrNewSegment);
      try
      if ((_DATA <> nil) AND (_DATA.Size > 0))
       then begin
        SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
        if (NOT FileExists(SegmentFileName))
         then begin
          _DATA.Position:=0;
          _DATA.SaveToFile(SegmentFileName);
          end;
        end;
      finally
      TypeSystem.Cash.Segment_Unlock(ptrNewSegment);
      end;
      end;
  until (P = Pend);
  end;
finally
Lock.EndRead;
end;
end;
end;


Constructor TSystemTDetailedPictureVisualization.Create;
var
  EmptySegmentJI: TJPegImage;
begin
CreateNew(idTDetailedPictureVisualization,tnTDetailedPictureVisualization,TTDetailedPictureVisualizationFunctionality);
DetailedPictureDeferredReflectingList:=TThreadList.Create;
if Enabled then Cash:=TTDetailedPictureVisualizationCash.Create(Self);
//.
ReflectingBMP:=TBitmap.Create;
ReflectingBMP.HandleType:=bmDIB;
ReflectingBMP.PixelFormat:=pf24bit;
//.
LoadingImage:=TBitmap.Create;
LoadingImage.LoadFromFile(Space.WorkLocale+'\'+PathLib+'\BMP'+'\'+'Loading.bmp');
//.
EmptySegmentImageDATA:=TMemoryStream.Create;
EmptySegmentImageDATA.LoadFromFile('TypesDef\DetailedPictureVisualization\SegmentNotExist.jpg');
EmptySegmentImage:=TBitmap.Create;
EmptySegmentImage.HandleType:=bmDIB;
EmptySegmentImage.PixelFormat:=pf24bit;
EmptySegmentJI:=TJPegImage.Create;
try
EmptySegmentImageDATA.Position:=0;
EmptySegmentJI.LoadFromStream(EmptySegmentImageDATA);
EmptySegmentImage.Assign(EmptySegmentJI);
finally
EmptySegmentJI.Destroy;
end;
//.
SegmentsOGLTextures:=TDPVSegmentsOGLTextures.Create(Self);
//. to do: make following more optimally 
ContextTypeHolder:=TContextTypeHolder_Create();
end;

Destructor TSystemTDetailedPictureVisualization.Destroy;
begin
ContextTypeHolder.Free;
//.
EmptySegmentImage.Free;
EmptySegmentImageDATA.Free;
LoadingImage.Free;
ReflectingBMP.Free;
Cash.Free;
DetailedPictureDeferredReflectingList.Free;
SegmentsOGLTextures.Free();
Inherited;
end;

procedure TSystemTDetailedPictureVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTDetailedPictureVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTDetailedPictureVisualization.DoOnReflectorRemoval(const pReflector: TAbstractReflector);
var
  DeferredReflectings: TList;
  I: integer;
  _ReflectorsList: TList;
  J: integer;
begin
DeferredReflectings:=DetailedPictureDeferredReflectingList.LockList();
try
for I:=0 to DeferredReflectings.Count-1 do with TDetailedPictureDeferredReflecting(DeferredReflectings[I]) do begin
  _ReflectorsList:=ReflectorsList.LockList();
  try
  for J:=0 to _ReflectorsList.Count-1 do
    if (TAbstractReflector(_ReflectorsList[J]) = pReflector)
     then begin
      _ReflectorsList.Delete(J); 
      Break; //. >
      end; 
  finally
  ReflectorsList.UnlockList();
  end;
  end;
finally
DetailedPictureDeferredReflectingList.UnlockList();
end;
end;

procedure TSystemTDetailedPictureVisualization.Caching_Start;
begin
end;

procedure TSystemTDetailedPictureVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTDetailedPictureVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTDetailedPictureVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.NotRecombinatedGetPtrItem(idComponent) <> nil);
end;

procedure TSystemTDetailedPictureVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;

procedure TSystemTDetailedPictureVisualization.Context_ClearInactiveItems();

  procedure ProcessItem(const ptrItem: pointer; const pFigure,pAdditiveFigure: TFigureWinRefl);
  type
    TReflectingBound = record
      XIndexMin: integer;
      YIndexMin: integer;
      XIndexMax: integer;
      YIndexMax: integer;
    end;

    TReflectingBounds = array of TReflectingBound;
    
    TLevelItem = record
      Level: pointer;
      ReflectingBounds: TReflectingBounds;
    end;

    TLevelItems = array of TLevelItem;

    procedure ProcessReflector(const Reflector: TReflector; const ptrObject: TPtr; const pFigure,pAdditiveFigure: TFigureWinRefl; var LevelItems: TLevelItems);

      procedure GetReflectionWindowLevelContainerIndexes(const X0,Y0: double; const X1,Y1: double; const X3,Y3: double; const pReflectionWindow: TReflectionWindow; const SW,SH: double; out XIndexMin,XIndexMax,YIndexMin,YIndexMax: integer);

        procedure ProcessPoint(X,Y: double; out dX,dY: double);
        var
          QdA2: Extended;
          X_C,X_QdC,X_A1,X_QdB2: Extended;
          Y_C,Y_QdC,Y_A1,Y_QdB2: Extended;
        begin
        QdA2:=sqr(X-X0)+sqr(Y-Y0);
        //.
        X_QdC:=sqr(X1-X0)+sqr(Y1-Y0);
        X_C:=Sqrt(X_QdC);
        X_QdB2:=sqr(X-X1)+sqr(Y-Y1);
        X_A1:=(X_QdC-X_QdB2+QdA2)/(2*X_C);
        //.
        Y_QdC:=sqr(X3-X0)+sqr(Y3-Y0);
        Y_C:=Sqrt(Y_QdC);
        Y_QdB2:=sqr(X-X3)+sqr(Y-Y3);
        Y_A1:=(Y_QdC-Y_QdB2+QdA2)/(2*Y_C);
        //.
        dX:=X_A1;
        dY:=Y_A1;
        end;

      var
        dX,dY: double;
        dXMin,dYMin,dXMax,dYMax: double;
      begin
      pReflectionWindow.Lock.Enter;
      try
      ProcessPoint(pReflectionWindow.Xmn,pReflectionWindow.Ymn, dXMin,dYMin);
      dXMax:=dXMin; dYMax:=dYMin;
      ProcessPoint(pReflectionWindow.Xmx,pReflectionWindow.Ymn, dX,dY);
      if (dX < dXMin)
       then dXMin:=dX
       else
        if (dX > dXMax)
         then dXMax:=dX;
      if (dY < dYMin)
       then dYMin:=dY
       else
        if (dY > dYMax)
         then dYMax:=dY;
      ProcessPoint(pReflectionWindow.Xmx,pReflectionWindow.Ymx, dX,dY);
      if (dX < dXMin)
       then dXMin:=dX
       else
        if (dX > dXMax)
         then dXMax:=dX;
      if (dY < dYMin)
       then dYMin:=dY
       else
        if (dY > dYMax)
         then dYMax:=dY;
      ProcessPoint(pReflectionWindow.Xmn,pReflectionWindow.Ymx, dX,dY);
      if (dX < dXMin)
       then dXMin:=dX
       else
        if (dX > dXMax)
         then dXMax:=dX;
      if (dY < dYMin)
       then dYMin:=dY
       else
        if (dY > dYMax)
         then dYMax:=dY;
      finally
      pReflectionWindow.Lock.Leave;
      end;
      //.
      XIndexMin:=Trunc(dXMin/SW); XIndexMax:=Trunc(dXMax/SW);
      YIndexMin:=Trunc(dYMin/SH); YIndexMax:=Trunc(dYMax/SH);
      end;

    var
      X0,Y0,X1,Y1: Double;
      diffX1X0,diffY1Y0: Double;
      _Width: Double;
      Level: pointer;
      ptrLevel: pointer;
      MinFactor: Double;
      Factor: Double;
      LI: integer;
      flLevelFound: boolean;
      I: integer;
      Alfa: Double;
      b: Double;
      V: Double;
      S0_X3,S0_Y3: Double;
      S1_X3,S1_Y3: Double;
      Xc,Yc: double;
      diffX3X0,diffY3Y0: Double;
      SW,SH: Double;
      XIndexMin,XIndexMax,YIndexMin,YIndexMax: integer;
      RI: integer;
    begin
    with TItemTDetailedPictureVisualizationCash(ptrItem^) do
    with Reflector.Reflecting do begin
    Obj_PrepareFigures(ptrObject, Reflector.ReflectionWindow,WindowRefl, pFigure,pAdditiveFigure);
    if (pAdditiveFigure.CountScreenNodes > 0) OR (pFigure.CountScreenNodes > 0)
     then begin
      with pFigure do begin
      X0:=Nodes[0].X;Y0:=Nodes[0].Y;
      X1:=Nodes[1].X;Y1:=Nodes[1].Y;
      diffX1X0:=X1-X0;
      diffY1Y0:=Y1-Y0;
      _Width:=Sqrt(sqr(diffX1X0)+sqr(diffY1Y0));
      b:=(pFigure.Width*Reflector.ReflectionWindow.Scale);
      end;
      //. get reflector active level
      Level:=nil;
      MinFactor:=MaxDouble;
      ptrLevel:=TItemTDetailedPictureVisualizationCash(ptrItem^).Levels;
      while (ptrLevel <> nil) do with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
        Lock.BeginRead;
        try
        if (NOT Disabled)
         then begin
          Factor:=Abs(Params.SegmentWidth*Params.DivX/_Width-1);
          if (Factor < MinFactor)
           then begin
            Level:=ptrLevel;
            MinFactor:=Factor;
            end;
          end;
        finally
        Lock.EndRead;
        end;
        //. next level
        ptrLevel:=ptrNext;
        end;
      //.
      if (Level <> nil)
       then begin
        TLevelItemOfTDetailedPictureVisualizationCash(Level^).Lock.BeginRead;
        try
        if (diffX1X0 > 0) AND (diffY1Y0 >= 0)
         then Alfa:=2*PI+ArcTan(-diffY1Y0/diffX1X0)
         else
          if (diffX1X0 < 0) AND (diffY1Y0 > 0)
           then Alfa:=PI+ArcTan(-diffY1Y0/diffX1X0)
           else
            if (diffX1X0 < 0) AND (diffY1Y0 <= 0)
             then Alfa:=PI+ArcTan(-diffY1Y0/diffX1X0)
             else
              if (diffX1X0 > 0) AND (diffY1Y0 < 0)
               then Alfa:=ArcTan(-diffY1Y0/diffX1X0)
               else
                if diffY1Y0 > 0
                 then Alfa:=3*PI/2
                 else Alfa:=PI/2;
        if Abs(diffY1Y0) > Abs(diffX1X0)
         then begin
          V:=(b/2)/Sqrt(1+Sqr(diffX1X0/diffY1Y0));
          S0_X3:=(V)+X0;
          S0_Y3:=(-V)*(diffX1X0/diffY1Y0)+Y0;
          S1_X3:=(-V)+X0;
          S1_Y3:=(V)*(diffX1X0/diffY1Y0)+Y0;
          end
         else begin
          V:=(b/2)/Sqrt(1+Sqr(diffY1Y0/diffX1X0));
          S0_Y3:=(V)+Y0;
          S0_X3:=(-V)*(diffY1Y0/diffX1X0)+X0;
          S1_Y3:=(-V)+Y0;
          S1_X3:=(V)*(diffY1Y0/diffX1X0)+X0;
          end;
        if (3*PI/4 <= Alfa) AND (Alfa < 7*PI/4)
         then begin Xc:=S0_X3; Yc:=S0_Y3 end
         else begin Xc:=S1_X3; Yc:=S1_Y3 end;
        diffX3X0:=(X0-Xc)*2;
        diffY3Y0:=(Y0-Yc)*2;
        with TLevelItemOfTDetailedPictureVisualizationCash(Level^) do begin
        //. get ReflectionWindow level container indexes
        SW:=_Width/Params.DivX;
        SH:=b/Params.DivY;
        GetReflectionWindowLevelContainerIndexes(Xc,Yc, Xc+diffX1X0,Yc+diffY1Y0, Xc+diffX3X0,Yc+diffY3Y0, Reflector.ReflectionWindow, SW,SH,  XIndexMin,XIndexMax,YIndexMin,YIndexMax);
        if (XIndexMin < 0) then XIndexMin:=0;
        if (XIndexMax >= Params.DivX) then XIndexMax:=Params.DivX-1;
        if (XIndexMin > XIndexMax) then Exit; //. ->
        if (YIndexMin < 0) then YIndexMin:=0;
        if (YIndexMax >= Params.DivY) then YIndexMax:=Params.DivY-1;
        if (YIndexMin > YIndexMax) then Exit; //. ->
        end;
        //. get level item
        flLevelFound:=false;
        for I:=0 to Length(LevelItems)-1 do
          if (LevelItems[I].Level = Level)
           then begin
            LI:=I;
            flLevelFound:=true;
            Break; //. >
            end;
        if (NOT flLevelFound)
         then begin
          LI:=Length(LevelItems);
          SetLength(LevelItems,Length(LevelItems)+1);
          FillChar(LevelItems[LI],SizeOf(LevelItems[LI]), 0);
          LevelItems[LI].Level:=Level;
          end;
        //. create new reflecting bound
        with LevelItems[LI] do begin
        RI:=Length(ReflectingBounds);
        SetLength(ReflectingBounds,Length(ReflectingBounds)+1);
        //.
        ReflectingBounds[RI].XIndexMin:=XIndexMin;
        ReflectingBounds[RI].YIndexMin:=YIndexMin;
        ReflectingBounds[RI].XIndexMax:=XIndexMax;
        ReflectingBounds[RI].YIndexMax:=YIndexMax;
        end;
        finally
        TLevelItemOfTDetailedPictureVisualizationCash(Level^).Lock.EndRead;
        end;
        end;
      end;
    end;
    end;

  var
    I,J: integer;
    LevelItems: TLevelItems;
    ptrLevel: pointer;
    flLevelProcessed: boolean;
    ptrptrSegment: pointer;
    flSegmentVisible: boolean;
    ptrDestroySegment: pointer;
    LevelFolder: string;
    SegmentFileName: string;
  begin
  SetLength(LevelItems,0);
  try
  with TItemTDetailedPictureVisualizationCash(ptrItem^) do begin
  if ((ptrObj = nilPtr) OR (NOT Space.Obj_IsCached(ptrObj))) then Exit; //. ->
  for I:=0 to Space.ReflectorsList.Count-1 do if (TObject(Space.ReflectorsList[I]) is TReflector) then ProcessReflector(TReflector(Space.ReflectorsList[I]), ptrObj, pFigure,pAdditiveFigure, LevelItems);
  //. reforming levels
  ptrLevel:=Levels;
  while (ptrLevel <> nil) do with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
    Lock.BeginRead;
    try
    if (NOT flPersist)
     then begin
      LevelFolder:=Cash.Item_Level__GetContextFolder(idObj,Params.ID);
      ForceDirectories(LevelFolder);
      flLevelProcessed:=false;
      for I:=0 to Length(LevelItems)-1 do with LevelItems[I] do
        if (ptrLevel = Level)
         then begin
          ptrptrSegment:=@Segments;
          while (Pointer(ptrptrSegment^) <> nil) do with TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^) do begin
            flSegmentVisible:=false;
            for J:=0 to Length(ReflectingBounds)-1 do with ReflectingBounds[J] do
              if (((XIndexMin <= Params.XIndex) AND (Params.XIndex <= XIndexMax)) AND ((YIndexMin <= Params.YIndex) AND (Params.YIndex <= YIndexMax)))
               then begin
                flSegmentVisible:=true;
                Break; //. >
                end;
            if (NOT flSegmentVisible)
             then begin
              //. remove from list
              TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.BeginWrite;
              try
              ptrDestroySegment:=Pointer(ptrptrSegment^);
              Pointer(ptrptrSegment^):=TSegmentItemOfTDetailedPictureVisualizationCash(ptrDestroySegment^).ptrNext;
              finally
              TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.EndWrite;
              end;
              //.
              with TSegmentItemOfTDetailedPictureVisualizationCash(ptrDestroySegment^) do begin
              if (SegmentsOGLTextures.flEnabled AND (Cash.Segment_idOGLTexture(ptrDestroySegment) <> 0)) then SegmentsOGLTextures.DeleteSegmentTexture(ptrDestroySegment);
              Cash.Segment_Lock(ptrDestroySegment);
              try
              if (Params._DATA <> nil)
               then begin
                SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(Params.XIndex)+'Y'+IntToStr(Params.YIndex)+'.jpg';
                if ((Params._DATA.Size > 0) AND (NOT FileExists(SegmentFileName)))
                 then begin
                  Params._DATA.Position:=0;
                  Params._DATA.SaveToFile(SegmentFileName);
                  end;
                //.
                Cash.Segment_SetDATA(ptrDestroySegment,nil);
                end;
              finally
              Cash.Segment_Unlock(ptrDestroySegment);
              end;
              end;
              //.
              Cash.AccessedSegmentsRevising.Remove(ptrDestroySegment);
              //.
              FreeMem(ptrDestroySegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
              end
             else ptrptrSegment:=@ptrNext;
            end;
          flLevelProcessed:=true;
          Break; //. >
          end;
      if (NOT flLevelProcessed)
       then
        while (Segments <> nil) do begin
          //. destroy the segment
          TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.BeginWrite;
          try
          ptrDestroySegment:=Segments;
          Segments:=TSegmentItemOfTDetailedPictureVisualizationCash(ptrDestroySegment^).ptrNext;
          finally
          TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.EndWrite;
          end;
          //.
          with TSegmentItemOfTDetailedPictureVisualizationCash(ptrDestroySegment^) do begin
          if (SegmentsOGLTextures.flEnabled AND (Cash.Segment_idOGLTexture(ptrDestroySegment) <> 0)) then SegmentsOGLTextures.DeleteSegmentTexture(ptrDestroySegment);
          Cash.Segment_Lock(ptrDestroySegment);
          try
          if (Params._DATA <> nil)
           then begin
            SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(Params.XIndex)+'Y'+IntToStr(Params.YIndex)+'.jpg';
            if ((Params._DATA.Size > 0) AND (NOT FileExists(SegmentFileName)))
             then begin
              Params._DATA.Position:=0;
              Params._DATA.SaveToFile(SegmentFileName);
              end;
            //.
            Cash.Segment_SetDATA(ptrDestroySegment,nil);
            end;
          finally
          Cash.Segment_Unlock(ptrDestroySegment);
          end;
          end;
          //.
          Cash.AccessedSegmentsRevising.Remove(ptrDestroySegment);
          //.
          FreeMem(ptrDestroySegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
          end;
      end;
    finally
    Lock.EndRead;
    end;
    //. next level
    ptrLevel:=ptrNext;
    end;
  end;
  finally
  for I:=0 to Length(LevelItems)-1 do with LevelItems[I] do SetLength(ReflectingBounds,0);
  SetLength(LevelItems,0);
  end;
  end;

var
  ptrItem: pointer;
  Figure: TFigureWinRefl;
  AdditiveFigure: TFigureWinRefl;
begin
Figure:=TFigureWinRefl.Create;
AdditiveFigure:=TFigureWinRefl.Create;
try
Space.Lock.Enter;
try
Cash.Lock.BeginWrite; //. to avoid deleting segment on composition reflecting
try
ptrItem:=Cash.FItems;
while (ptrItem <> nil) do begin
  ProcessItem(ptrItem, Figure,AdditiveFigure);
  //. next item
  ptrItem:=TItemTDetailedPictureVisualizationCash(ptrItem^).ptrNext;
  end;
finally
Cash.Lock.EndWrite;
end;
finally
Space.Lock.Leave;
end;
finally
AdditiveFigure.Destroy;
Figure.Destroy;
end;
end;

procedure TSystemTDetailedPictureVisualization.Context_RemoveItem(const idComponent: integer);
begin
//. do not remove visualizations from context because we are using SUMMARY context (tile's files) for all users
end;

procedure TSystemTDetailedPictureVisualization.Context_ClearItems();
begin
//. do not remove visualizations from context because we are using SUMMARY context (tile's files) for all users
end;

procedure TSystemTDetailedPictureVisualization.DoOnContextIsInitialized;
begin
if (Space.flOffline OR (Cash = nil)) then Exit; //. ->
Cash.PersistLevelsProviding.Provide();
end;


{TDPVAccessedSegmentsRevising}
Constructor TDPVAccessedSegmentsRevising.Create(const pCache: TTDetailedPictureVisualizationCash);
const
  SegmentAvrSize = 16000;
  MemFactorToLoadSegments = 0.25;
var
  MemStatus: TMemoryStatus;
begin
Cache:=pCache;
Lock:=TCriticalSection.Create;
//.
Segments:=nil;
SegmentsCount:=0;
//. get amount of segments to live in memory
MemStatus.dwLength:=sizeof(TMemoryStatus);
GlobalMemoryStatus(MemStatus);
SegmentsMaxCount:=Round((MemStatus.dwTotalPhys*MemFactorToLoadSegments)/SegmentAvrSize);
//.
Inherited Create(true);
Priority:=tpIdle;
Resume;
end;

Destructor TDPVAccessedSegmentsRevising.Destroy;
begin
Inherited;
Clear;
Lock.Free;
end;

procedure TDPVAccessedSegmentsRevising.Add(const pSegment: pointer; const pptrLevel: pointer; const pidObj: integer);
var
  ptrptrItem: pointer;
  ptrItem: pointer;
begin
Lock.Enter;
try
ptrItem:=nil;
ptrptrItem:=@Segments;
while Pointer(ptrptrItem^) <> nil do with TDPVAccessedSegmentItem(Pointer(ptrptrItem^)^) do begin
  if (Segment = pSegment)
   then begin
    ptrItem:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TDPVAccessedSegmentItem(ptrItem^).ptrNext:=Segments;
    Segments:=ptrItem;
    Break; //. >
    end;
  ptrptrItem:=@ptrNext;
  end;
if (ptrItem = nil)
 then begin
  GetMem(ptrItem,SizeOf(TDPVAccessedSegmentItem));
  with TDPVAccessedSegmentItem(ptrItem^) do begin
  ptrNext:=Segments;
  Segment:=pSegment;
  ptrLevel:=pptrLevel;
  end;
  Segments:=ptrItem;
  Inc(SegmentsCount);
  end;
finally
Lock.Leave;
end;
end;

procedure TDPVAccessedSegmentsRevising.AddByList(const List: TList; const pptrLevel: pointer; const pidObj: integer);
var
  I: integer;
  pSegment: pointer;
  ptrptrItem: pointer;
  ptrItem: pointer;
begin
for I:=0 to List.Count-1 do begin
  pSegment:=List[I];
  //.
  Lock.Enter;
  try
  ptrItem:=nil;
  ptrptrItem:=@Segments;
  while Pointer(ptrptrItem^) <> nil do with TDPVAccessedSegmentItem(Pointer(ptrptrItem^)^) do begin
    if Segment = pSegment
     then begin
      ptrItem:=Pointer(ptrptrItem^);
      Pointer(ptrptrItem^):=ptrNext;
      TDPVAccessedSegmentItem(ptrItem^).ptrNext:=Segments;
      Segments:=ptrItem;
      Break; //. >
      end;
    ptrptrItem:=@ptrNext;
    end;
  if (ptrItem = nil)
   then begin
    GetMem(ptrItem,SizeOf(TDPVAccessedSegmentItem));
    with TDPVAccessedSegmentItem(ptrItem^) do begin
    ptrNext:=Segments;
    Segment:=pSegment;
    ptrLevel:=pptrLevel;
    end;
    Segments:=ptrItem;
    Inc(SegmentsCount);
    end;
  finally
  Lock.Leave;
  end;
  end;
end;

procedure TDPVAccessedSegmentsRevising.Remove(const pSegment: pointer);
var
  ptrptrItem: pointer;
  ptrDestroyItem: pointer;
begin
Lock.Enter;
try
ptrptrItem:=@Segments;
while (Pointer(ptrptrItem^) <> nil) do with TDPVAccessedSegmentItem(Pointer(ptrptrItem^)^) do
  if (Segment = pSegment)
   then begin
    ptrDestroyItem:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=TDPVAccessedSegmentItem(ptrDestroyItem^).ptrNext;
    FreeMem(ptrDestroyItem,SizeOf(TDPVAccessedSegmentItem));
    Dec(SegmentsCount);
    Exit; //. ->
    end
   else ptrptrItem:=@ptrNext;
finally
Lock.Leave;
end;
end;

function TDPVAccessedSegmentsRevising.RemoveOld(const Count: integer; out RemoveList: TList): boolean;
var
  Delta: integer;
  ptrptrItem: pointer;
  ptrDestroyItem: pointer;
  I: integer;
begin
Result:=false;
RemoveList:=nil;
Lock.Enter;
try
Delta:=(SegmentsCount-Count);
if (Delta <= 0) then Exit; //. ->
RemoveList:=TList.Create;
try
RemoveList.Capacity:=Delta;
ptrptrItem:=@Segments;
//. skip normal items
I:=0;
while (Pointer(ptrptrItem^) <> nil) do with TDPVAccessedSegmentItem(Pointer(ptrptrItem^)^) do
  if (I < Count)
   then begin
    ptrptrItem:=@ptrNext;
    Inc(I);
    end
   else Break; //. >
//. remove the rest
while (Pointer(ptrptrItem^) <> nil) do
  if (NOT (TLevelItemOfTDetailedPictureVisualizationCash(TDPVAccessedSegmentItem(Pointer(ptrptrItem^)^).ptrLevel^).flPersist))
   then with TDPVAccessedSegmentItem(Pointer(ptrptrItem^)^) do begin
    ptrDestroyItem:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=TDPVAccessedSegmentItem(ptrDestroyItem^).ptrNext;
    //.
    RemoveList.Add(ptrDestroyItem);
    end
   else ptrptrItem:=@TDPVAccessedSegmentItem(Pointer(ptrptrItem^)^).ptrNext; 
//.
Dec(SegmentsCount,Delta);
//.
Result:=true;
except
  FreeAndNil(RemoveList);
  Raise; //. =>
  end;
finally
Lock.Leave;
end;
end;

procedure TDPVAccessedSegmentsRevising.RemoveVisualizationSegments(const ptrVisualizationItem: pointer);
var
  ptrptrItem: pointer;
  ptrDestroyItem: pointer;
begin
Lock.Enter;
try
ptrptrItem:=@Segments;
while (Pointer(ptrptrItem^) <> nil) do with TDPVAccessedSegmentItem(Pointer(ptrptrItem^)^) do
  if (TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).ptrItem = ptrVisualizationItem)
   then begin
    ptrDestroyItem:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=TDPVAccessedSegmentItem(ptrDestroyItem^).ptrNext;
    FreeMem(ptrDestroyItem,SizeOf(TDPVAccessedSegmentItem));
    Dec(SegmentsCount); 
    end
   else ptrptrItem:=@ptrNext;
finally
Lock.Leave;
end;
end;

procedure TDPVAccessedSegmentsRevising.Clear;
var
  ptrDestroyItem: pointer;
begin
Lock.Enter;
try
while (Segments <> nil) do begin
  ptrDestroyItem:=Segments;
  Segments:=TDPVAccessedSegmentItem(ptrDestroyItem^).ptrNext;
  FreeMem(ptrDestroyItem,SizeOf(TDPVAccessedSegmentItem));
  end;
SegmentsCount:=0;
finally
Lock.Leave;
end;
end;

procedure TDPVAccessedSegmentsRevising.Execute;
const
  Delta = 7*7;
var
  R: boolean;
  LevelFolder: string;
  SegmentFileName: string;
  RemoveList: TList;
  RemoveTextureList: TList;
  I: integer;
begin
repeat
  //. check for items to remove
  Lock.Enter;
  try
  R:=((SegmentsCount > (SegmentsMaxCount+Delta)) AND RemoveOld(SegmentsMaxCount, RemoveList));
  finally
  Lock.Leave;
  end;
  //.
  if (R)
   then
    try
    RemoveTextureList:=TList.Create;
    try
    RemoveTextureList.Capacity:=RemoveList.Count;
    Cache.Lock.BeginRead;
    try
    for I:=0 to RemoveList.Count-1 do with TDPVAccessedSegmentItem(RemoveList[I]^) do begin
      TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.BeginRead;
      try
      LevelFolder:=Cache.Item_Level__GetContextFolder(TItemTDetailedPictureVisualizationCash(TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).ptrItem^).idObj,TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.ID);
      ForceDirectories(LevelFolder);
      with TSegmentItemOfTDetailedPictureVisualizationCash(Segment^) do begin
      Cache.Segment_Lock(Segment);
      try
      if (Params._DATA <> nil)
       then begin
        SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(Params.XIndex)+'Y'+IntToStr(Params.YIndex)+'.jpg';
        if ((Params._DATA.Size > 0) AND (NOT FileExists(SegmentFileName)))
         then begin
          Params._DATA.Position:=0;
          Params._DATA.SaveToFile(SegmentFileName);
          end;
        //.
        Cache.Segment_SetDATA(Segment,nil);
        //.
        if (Cache.Segment_idOGLTexture(Segment) <> 0) then RemoveTextureList.Add(Segment);
        end;
      finally
      Cache.Segment_Unlock(Segment);
      end;
      end;  
      finally
      TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.EndRead;
      end;
      end;
    if (TSystemTDetailedPictureVisualization(Cache.TypeSystem).SegmentsOGLTextures.flEnabled) then TSystemTDetailedPictureVisualization(Cache.TypeSystem).SegmentsOGLTextures.DeleteSegmentsItemsTextures(RemoveTextureList);
    finally
    Cache.Lock.EndRead;
    end;
    finally
    RemoveTextureList.Destroy;
    end;
    finally
    for I:=0 to RemoveList.Count-1 do FreeMem(RemoveList[I],SizeOf(TDPVAccessedSegmentItem));
    RemoveList.Destroy;
    end;
  //.
  Sleep(100);
until Terminated;
end;


{TDPVPersistLevelsProviding}
Constructor TDPVPersistLevelsProviding.Create(const pCache: TTDetailedPictureVisualizationCash);
const
  SegmentAvrSize = 16000; 
  MemFactorToLoadSegments = 0.1;
var
  MemStatus: TMemoryStatus;
begin
Cache:=pCache;
Lock:=TCriticalSection.Create;
evtQueryProviding:=CreateEvent(nil,false,false,nil);
if (NOT Cache.Space.flOffline)
 then flServerConnectionIsFast:=ServerConnectionIsFast()
 else flServerConnectionIsFast:=false;
//. get amount of segments to live in memory
MemStatus.dwLength:=sizeof(TMemoryStatus);
GlobalMemoryStatus(MemStatus);
PersistSegmentsMaxCount:=Round((MemStatus.dwTotalPhys*MemFactorToLoadSegments)/SegmentAvrSize);
//.
Inherited Create(false);
end;

Destructor TDPVPersistLevelsProviding.Destroy;
begin
Inherited;
CloseHandle(evtQueryProviding);
Lock.Free;
end;

procedure TDPVPersistLevelsProviding.Execute;
var
  R: DWord;
begin
if (Cache.Space.ProxySpaceServerType <> pssClient) then Exit; //. ->
//.
CoInitializeEx(nil, COINIT_MULTITHREADED);
try
repeat
  R:=WaitForSingleObject(evtQueryProviding, 100);
  if (R = WAIT_OBJECT_0)
   then
    try
    //. to avoid often calls
    while (WaitForSingleObject(evtQueryProviding, 300) = WAIT_OBJECT_0) do ;
    //.
    Providing();
    except
      On E: Exception do if (Cache.Space.State <> psstDestroying) then EventLog.WriteMajorEvent('SystemTDetailedPictureVisualization.Cache.TDPVPersistLevelsProviding','Error during providing persist levels.',E.Message);
      end;
until Terminated;
finally
CoUninitialize;
end;
end;

function TDPVPersistLevelsProviding.ServerConnectionIsFast: boolean;
const
  TryesCount = 3;
var
  I: integer;
  LT: TDateTime;
  RequestTime,MinRequestTime: integer;
begin
MinRequestTime:=MaxInt;
for I:=0 to TryesCount-1 do begin
  {$IFNDEF EmbeddedServer}
  Cache.Space.GlobalSpaceManagerLock.Enter();
  try
  {$ENDIF}
  LT:=Now;
  {$IFNDEF EmbeddedServer}
  Cache.Space.GlobalSpaceManager.SpaceSize();
  {$ELSE}
  SpaceManager_SpaceSize();
  {$ENDIF}
  RequestTime:=Round((Now-LT)*24*3600*1000);
  {$IFNDEF EmbeddedServer}
  finally
  Cache.Space.GlobalSpaceManagerLock.Leave();
  end;
  {$ENDIF}
  if (RequestTime < MinRequestTime)
   then MinRequestTime:=RequestTime;
  end;
Result:=(MinRequestTime < 100{milliseconds});
end;

procedure TDPVPersistLevelsProviding.Provide();
begin
SetEvent(evtQueryProviding);
end;

procedure TDPVPersistLevelsProviding.Providing;

  procedure ProcessVisualizationsForPersistLevels(out NewPersistLevels: TList);
  const
    PersistLevelVisualizationsMaxCount = 4;
    PersistLevelIndex = 3;
  var
    PersistLevelVisualizationsCount: integer;
    ptrItem,ptrLevel: pointer;
    PersistSegmentsCount,SC: integer;
  begin
  NewPersistLevels:=TList.Create;
  try
  PersistLevelVisualizationsCount:=PersistLevelVisualizationsMaxCount;
  Cache.Lock.BeginRead;
  try
  PersistSegmentsCount:=0;
  ptrItem:=Cache.FItems;
  while (ptrItem <> nil) do with TItemTDetailedPictureVisualizationCash(ptrItem^) do begin
    ptrLevel:=Levels;
    while (ptrLevel <> nil) do with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
      Lock.BeginRead;
      try
      if (PersistLevelVisualizationsCount > 0)
       then begin
        if ((LevelIndex = 0) OR (LevelIndex = PersistLevelIndex))
         then begin
          SC:=Params.DivX*Params.DivY;
          if ((PersistSegmentsCount+SC) <= PersistSegmentsMaxCount)
           then begin
            if (NOT flPersist)
             then begin
              Lock.BeginWrite;
              try
              flPersist:=true;
              finally
              Lock.EndWrite;
              end;
              Inc(PersistSegmentsCount,SC);
              //.
              NewPersistLevels.Add(Pointer(Params.id));
              end;
            end
           else begin
            EventLog.WriteCriticalEvent('Providing.ProcessVisualizationsForPersistLevels','Persist Level has been reset','((PersistSegmentsCount+SC) <= PersistSegmentsMaxCount)');
            if (flPersist)
             then begin
              Lock.BeginWrite;
              try
              flPersist:=false;
              finally
              Lock.EndWrite;
              end;
              end;
            end;
          end
         else begin
          if (flPersist)
           then begin
            Lock.BeginWrite;
            try
            flPersist:=false;
            finally
            Lock.EndWrite;
            end;
            end;
          end;
        end
       else begin
        if (flPersist)
         then begin
          Lock.BeginWrite;
          try
          flPersist:=false;
          finally
          Lock.EndWrite;
          end;
          end;
        end;
      finally
      Lock.EndRead;
      end;
      //. next level
      ptrLevel:=ptrNext;
      end;
    if (PersistLevelVisualizationsCount > 0) then Dec(PersistLevelVisualizationsCount);
    //. next visualization
    ptrItem:=ptrNext;
    end;
  finally
  Cache.Lock.EndRead;
  end;
  except
    FreeAndNil(NewPersistLevels);
    Raise; //. =>
    end;
  end;

  procedure ProvidePersistLevelsWithSegments(const PersistLevels: TList);
  const
    SegmentsGeneration_MaxDepth = 3;
  var
    ptrItem: pointer;
    ptrLevel: pointer;
    LevelsList: TList;
    SegmentID: integer;
    flAllItemsExists,flHasEmptySegment: boolean;
    ItemsTable: pointer;
    ItemsTableSize: integer;
    ExceptSegments: TByteArray;
    BA: TByteArray;
    IL,ReceivedSegmentsList: TList;
    LI: integer;
  begin
  try
  Cache.Lock.BeginRead;
  try
  ptrItem:=Cache.FItems;
  while (ptrItem <> nil) do begin //. processing ...
    LevelsList:=TList.Create;
    try
    ptrLevel:=TItemTDetailedPictureVisualizationCash(ptrItem^).Levels;
    while (ptrLevel <> nil) do with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
      Lock.BeginRead;
      try
      if (PersistLevels.IndexOf(Pointer(Params.id)) <> -1)
       then LevelsList.Add(ptrLevel);
      finally
      Lock.EndRead;
      end;
      //. next level
      ptrLevel:=ptrNext;
      end;
    for LI:=LevelsList.Count-1 downto 0 do begin
      ptrLevel:=LevelsList[LI];
      //.
      try
      TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.BeginRead;
      try
      //. get local segments
      flAllItemsExists:=Cache.Item_Level__GetVisibleSegmentsLocal(ptrItem, ptrLevel, 0,TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.DivX-1,0,TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.DivY-1, false, true, nil,  ItemsTable,ItemsTableSize, ExceptSegments, @flHasEmptySegment);
      try
      if (NOT flAllItemsExists OR flHasEmptySegment)
       then begin
        //. try to restore segments from saved context
        try
        flAllItemsExists:=Cache.Item_Level__RestoreSegmentsLocal(ptrItem, ptrLevel, 0,TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.DivX-1,0,TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.DivY-1, nil,  IL, ExceptSegments);
        except
          On E: Exception do begin
            EventLog.WriteMinorEvent('TDPVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of RestoreSegmentsLocal() of DetailedPicture visualization (ID: '+IntToStr(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj)+')',E.Message);
            Raise; //. =>
            end;
          end;
        if (IL <> nil)
         then IL.Destroy;
        //.
        if (NOT flAllItemsExists)
         then begin
          //. try to generate segments from down levels
          try
          flAllItemsExists:=Cache.Item_Level__GenerateSegmentsLocal(ptrItem, ptrLevel, 0,TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.DivX-1,0,TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.DivY-1, SegmentsGeneration_MaxDepth, nil,  IL, ExceptSegments);
          except
            On E: Exception do begin
              EventLog.WriteMinorEvent('TDPVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of GenerateSegmentsLocal() of DetailedPicture visualization (ID: '+IntToStr(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj)+')',E.Message);
              Raise; //. =>
              end;
            end;
          if (IL <> nil)
           then IL.Destroy;
          //. segments getting from remote server
          if (NOT flAllItemsExists AND (NOT Cache.Space.flOffline) AND flServerConnectionIsFast)
           then begin
            with TDetailedPictureVisualizationFunctionality(TComponentFunctionality_Create(idTDetailedPictureVisualization,TItemTDetailedPictureVisualizationCash(ptrItem^).idObj)) do
            try
            try
            Level_GetSegments(TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.id, 0,TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.DivX-1,0,TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.DivY-1, ExceptSegments, BA);
            except
              On E: Exception do begin
                EventLog.WriteMinorEvent('TDPVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of Level_GetSegments(idLevel = '+IntToStr(TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.id)+') of DetailedPicture visualization (ID: '+IntToStr(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj)+')',E.Message);
                Raise; //. =>
                end;
              end;
            finally
            Release;
            end;
            //.
            ReceivedSegmentsList:=TList.Create;
            try
            TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.BeginRead;
            try
            try
            TDetailedPictureVisualizationCashItemLevel_PrepareSegmentsFromByteArray(TSystemTDetailedPictureVisualization(Cache.TypeSystem), TItemTDetailedPictureVisualizationCash(ptrItem^).idObj, ptrLevel,BA, ReceivedSegmentsList);
            except
              On E: Exception do begin
                EventLog.WriteMinorEvent('TDPVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of PrepareSegmentsFromByteArray(idLevel = '+IntToStr(TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.id)+') of DetailedPicture visualization (ID: '+IntToStr(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj)+')',E.Message);
                Raise; //. =>
                end;
              end;
            if (ReceivedSegmentsList.Count > 0)
             then begin
              //. update OpenGL segments textures
              try
              if (TSystemTDetailedPictureVisualization(Cache.TypeSystem).SegmentsOGLTextures.flEnabled)
               then TSystemTDetailedPictureVisualization(Cache.TypeSystem).SegmentsOGLTextures.GenerateSegmentItemsTextures(ReceivedSegmentsList);
              except
                On E: Exception do begin
                  EventLog.WriteMinorEvent('TDPVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of GenerateSegmentItemsTextures() of DetailedPicture visualization (ID: '+IntToStr(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj)+')',E.Message);
                  Raise; //. =>
                  end;
                end;
              end;
            finally
            TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.EndRead;
            end;
            finally
            ReceivedSegmentsList.Destroy;
            end;
            //. empty segments degeneration
            try
            if (Cache.Item_Level__DegenerateSegmentsLocal(ptrItem, ptrLevel, 0,TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.DivX-1,0,TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.DivY-1, nil,  IL))
             then IL.Destroy;
            except
              On E: Exception do begin
                EventLog.WriteMinorEvent('TDPVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of DegenerateSegmentsLocal(idLevel = '+IntToStr(TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Params.id)+') of DetailedPicture visualization (ID: '+IntToStr(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj)+')',E.Message);
                Raise; //. =>
                end;
              end;
            end;
          end;
        end;
      finally
      if (ItemsTable <> nil) then FreeMem(ItemsTable,ItemsTableSize);
      end;
      finally
      TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.EndRead;
      end;
      except
        On E: Exception do begin
          EventLog.WriteMinorEvent('TDPVPersistLevelsProviding.ProvidePersistLevelsWithSegments','Error of processing DetailedPicture visualization (ID: '+IntToStr(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj)+')',E.Message);
          Raise; //. =>
          end;
        end;
      end;
    finally
    LevelsList.Destroy;
    end;
    //. next cache visualization
    ptrItem:=TItemTDetailedPictureVisualizationCash(ptrItem^).ptrNext;
    end;
  finally
  Cache.Lock.EndRead;
  end;
  except
    On E: Exception do EventLog.WriteMinorEvent('DetailedPictureDeferredReflecting.Execute','Unexpected error of processing DetailedPicture visualization (ID: '+IntToStr(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj)+')',E.Message);
    end;
  end;

var
  NewPersistLevels: TList;
begin
ProcessVisualizationsForPersistLevels(NewPersistLevels);
try
ProvidePersistLevelsWithSegments(NewPersistLevels);
finally
NewPersistLevels.Destroy;
end;
end;


//. TDPVSegmentsOGLTextures
Constructor TDPVSegmentsOGLTextures.Create(const pTypeSystem: TSystemTDetailedPictureVisualization);
const
  TextureSize = 256*256*3;
  MemFactorToLoadTextures = 0.125;
var
  BitsPtr: pointer;
  I: integer;
  MemStatus: TMemoryStatus;
begin
TypeSystem:=pTypeSystem;
//.
{$IFNDEF SpaceWindowReflectingTesting}
flEnabled:=(NOT (unitSpaceFunctionalServer.flYes OR unitAreaNotificationServer.flYes));
{$ELSE}
flEnabled:=false;
{$ENDIF}
//.
Texture_DC:=0;
DIB:=0;
DIB_DC:=0;
OperationLock:=nil;
evtStart:=0;
evtFinished:=0;
//.
_DrawCanvas_Functionality:=nil;
_DrawCanvas_Segments:=nil;
_DrawCanvas_Result:=false;
_NewTextureSegment:=nil;
_NewTexturesSegments:=nil;
_DeleteTextureSegment:=nil;
_DeleteSegmentsTextures:=nil;
//.
LastAccessTextureSegments:=nil;
LastAccessTextureSegmentsCount:=0;
//.
if (flEnabled)
 then begin
  Texture_DC:=CreateCompatibleDC(0);
  DIB_DC:=CreateCompatibleDC(0);
  ZeroMemory(@DIB_BitInfo,sizeof(BITMAPINFO));
  with DIB_BitInfo.bmiHeader do begin
  biSize:=sizeOf(DIB_BitInfo.bmiHeader);
  biBitCount:=24;
  biCompression:=BI_RGB;
  biPlanes:=1;
  biWidth :=Screen.Width+16{additional size to avoid clipped image (don't know why)};
  biHeight:=Screen.Height+16{additional size to avoid clipped image (don't know why)};
  biSizeImage:=(biWidth*(biBitCount div 8))*biHeight;
  end;
  DIB:=CreateDIBSection(DIB_DC, DIB_BitInfo, DIB_RGB_COLORS, BitsPtr, 0, 0);
  SelectObject(DIB_DC, DIB);
  OperationLock:=TCriticalSection.Create;
  evtStart:=CreateEvent(nil,false,false,nil);
  evtFinished:=CreateEvent(nil,false,false,nil);
  flInitialized:=false;
  flStarted:=false;
  //. calculate maximum number of textures in memory
  MemStatus.dwLength:=sizeof(TMemoryStatus);
  GlobalMemoryStatus(MemStatus);
  TexturesMaxCount:=Round((MemStatus.dwTotalPhys*MemFactorToLoadTextures)/TextureSize);
  end;
//.
Inherited Create(true);
//.
if (flEnabled)
 then begin
  Priority:=tpHigher;
  Resume();
  while (NOT flStarted) do Sleep(30);
  //.
  if (NOT flInitialized) then Raise Exception.Create('could not initialize OpenGL textures'); //. =>
  end;
end;

Destructor TDPVSegmentsOGLTextures.Destroy;
begin
if (OperationLock <> nil)
 then begin
  OperationLock.Enter;
  SetEvent(evtStart);
  OperationLock.Leave;
  OperationLock.Destroy;
  end;
//.
Inherited;
//.
if (evtStart <> 0) then CloseHandle(evtStart);
if (evtFinished <> 0) then CloseHandle(evtFinished);
//.
LastAccessTextureSegments_Clear();
//.
if (DIB <> 0)
 then begin
  SelectObject(DIB_DC,0);
  DeleteObject(DIB);
  end;
if (DIB_DC <> 0) then DeleteDC(DIB_DC);
if (Texture_DC <> 0) then DeleteDC(Texture_DC);
end;

procedure TDPVSegmentsOGLTextures.Execute;
var
  I: integer;
  idOldTexture: cardinal;
  OldTextureSegmentList: TList;
begin
OperationException:=nil;
try
OGLContext:=CreateRenderingContext(DIB_DC,[],24,0);
if (OGLContext = 0)
 then begin
  flStarted:=true;
  Raise Exception.Create('could not CreateRenderingContext()'); //. =>
  end;
wglMakeCurrent(DIB_DC,OGLContext);
try
glViewport(0,0, DIB_BitInfo.bmiHeader.biWidth,DIB_BitInfo.bmiHeader.biHeight);
glDisable(GL_LIGHTING);
glDisable(GL_FOG);
glDisable(GL_DEPTH_TEST);
glDisable(GL_ALPHA_TEST);
glDisable(GL_STENCIL_TEST);
glDisable(GL_SCISSOR_TEST);
glEnable(GL_TEXTURE_2D);
//.
flInitialized:=true;
flStarted:=true;
repeat
  if (WaitForSingleObject(evtStart,100) = WAIT_OBJECT_0)
   then begin
    OperationException:=nil;
    try
    //.
    if (_DrawCanvas_Segments <> nil)
     then begin
      _DrawCanvas_Result:=DoDrawOnCanvas(_DrawCanvas_Functionality,_DrawCanvas_Segments,_DrawCanvas_SegmentsSize, _DrawCanvas_SegmentWidth, _DrawCanvas_SegmentHeight, _DrawCanvas_XIndexMin,_DrawCanvas_YIndexMin, _DrawCanvas_dX,_DrawCanvas_dY,_DrawCanvas_WidthScale,_DrawCanvas_HeightScale,_DrawCanvas_Rotation,_DrawCanvas_flBestQuality);
      _DrawCanvas_Segments:=nil;
      end
     else
      if (_NewTexturesSegments <> nil)
       then begin
        for I:=0 to _NewTexturesSegments.Count-1 do begin
          TypeSystem.Cash.Segment_Lock(_NewTexturesSegments[I]);
          try
          if ((TSegmentItemOfTDetailedPictureVisualizationCash(_NewTexturesSegments[I]^).Params._DATA <> nil) AND (TSegmentItemOfTDetailedPictureVisualizationCash(_NewTexturesSegments[I]^).Params._DATA.Size > 0))
           then begin
            idOldTexture:=TypeSystem.Cash.Segment_SetidOGLTexture(_NewTexturesSegments[I],InstallTexture(TSegmentItemOfTDetailedPictureVisualizationCash(_NewTexturesSegments[I]^).Params._DATA));
            if (idOldTexture <> 0) then glDeleteTextures(1,@idOldTexture);
            LastAccessTextureSegments_Insert(_NewTexturesSegments[I]);
            end;
          finally
          TypeSystem.Cash.Segment_Unlock(_NewTexturesSegments[I]);
          end;
          end;
        //.
        _NewTexturesSegments:=nil;
        end
       else
        if (_NewTextureSegment <> nil)
         then begin
          TypeSystem.Cash.Segment_Lock(_NewTextureSegment);
          try
          if ((TSegmentItemOfTDetailedPictureVisualizationCash(_NewTextureSegment^).Params._DATA <> nil) AND (TSegmentItemOfTDetailedPictureVisualizationCash(_NewTextureSegment^).Params._DATA.Size > 0))
           then begin
            idOldTexture:=TypeSystem.Cash.Segment_SetidOGLTexture(_NewTextureSegment,InstallTexture(TSegmentItemOfTDetailedPictureVisualizationCash(_NewTextureSegment^).Params._DATA));
            if (idOldTexture <> 0) then glDeleteTextures(1,@idOldTexture);
            LastAccessTextureSegments_Insert(_NewTextureSegment);
            end;
          finally
          TypeSystem.Cash.Segment_Unlock(_NewTextureSegment);
          end;
          //.
          _NewTextureSegment:=nil;
          end
         else
          if (_DeleteSegmentsTextures <> nil)
           then begin
            for I:=0 to _DeleteSegmentsTextures.Count-1 do begin
              idOldTexture:=TypeSystem.Cash.Segment_SetidOGLTexture(_DeleteSegmentsTextures[I],0);
              if (idOldTexture <> 0)
               then begin
                glDeleteTextures(1,@idOldTexture);
                LastAccessTextureSegments_Remove(_DeleteSegmentsTextures[I]);
                end;
              end;
            //.
            _DeleteSegmentsTextures:=nil;
            end
           else
            if (_DeleteTextureSegment <> nil)
             then begin
              idOldTexture:=TypeSystem.Cash.Segment_SetidOGLTexture(_DeleteTextureSegment,0);
              if (idOldTexture <> 0)
               then begin
                glDeleteTextures(1,@idOldTexture);
                LastAccessTextureSegments_Remove(_DeleteTextureSegment);
                end;
              //.
              _DeleteTextureSegment:=nil;
              end
    except
      on E: Exception do begin OperationException:=E; end;
      end;
    //.
    SetEvent(evtFinished);
    end
   else begin
    //. remove textures from old segments
    if (LastAccessTextureSegmentsCount > TexturesMaxCount)
     then begin
      LastAccessTextureSegments_RemoveOld(TexturesMaxCount-(TexturesMaxCount SHR 2), OldTextureSegmentList);
      if (OldTextureSegmentList <> nil)
       then begin
        try
        for I:=0 to OldTextureSegmentList.Count-1 do begin
          idOldTexture:=TypeSystem.Cash.Segment_SetidOGLTexture(OldTextureSegmentList[I],0);
          if (idOldTexture <> 0)
           then begin
            glDeleteTextures(1,@idOldTexture);
            LastAccessTextureSegments_Remove(OldTextureSegmentList[I]);
            end;
          end;
        finally
        OldTextureSegmentList.Destroy;
        end;
        end
      end;
    end;
until Terminated;
finally
wglMakeCurrent(DIB_DC,0);
wglDeleteContext(OGLContext);
end;
except
  On E: Exception do begin
    OperationException:=E;
    EventLog.WriteMinorEvent('TDPVSegmentsOGLTextures.Execute','Fatal error',E.Message);
    end;
  end;
end;

procedure TDPVSegmentsOGLTextures.GenerateSegmentTexture(const Segment: pointer);
begin
if (NOT flEnabled) then Raise Exception.Create('OpenGL is disabled'); //. =>
OperationLock.Enter;
try
_NewTextureSegment:=Segment;
//. set start
ResetEvent(evtFinished);
SetEvent(evtStart);
//. wait operation end
WaitForSingleObject(evtFinished,INFINITE);
if (OperationException <> nil)
 then
  try
  Raise Exception.Create(OperationException.Message); //. =>
  finally
  FreeAndNil(OperationException);
  end;
finally
OperationLock.Leave;
end;
end;

procedure TDPVSegmentsOGLTextures.GenerateSegmentItemsTextures(const Segments: TList);
begin
if (NOT flEnabled) then Raise Exception.Create('OpenGL is disabled'); //. =>
OperationLock.Enter;
try
_NewTexturesSegments:=Segments;
//. set start
ResetEvent(evtFinished);
SetEvent(evtStart);
//. wait operation end
WaitForSingleObject(evtFinished,INFINITE);
if (OperationException <> nil)
 then
  try
  Raise Exception.Create(OperationException.Message); //. =>
  finally
  FreeAndNil(OperationException);
  end;
finally
OperationLock.Leave;
end;
end;

procedure TDPVSegmentsOGLTextures.DeleteSegmentTexture(const Segment: pointer);
begin
if (NOT flEnabled) then Raise Exception.Create('OpenGL is disabled'); //. =>
OperationLock.Enter;
try
_DeleteTextureSegment:=Segment;
//. set start
ResetEvent(evtFinished);
SetEvent(evtStart);
//. wait operation end
WaitForSingleObject(evtFinished,INFINITE);
if (OperationException <> nil)
 then
  try
  Raise Exception.Create(OperationException.Message); //. =>
  finally
  FreeAndNil(OperationException);
  end;
finally
OperationLock.Leave;
end;
end;

procedure TDPVSegmentsOGLTextures.DeleteSegmentsItemsTextures(const Segments: TList);
begin
if (NOT flEnabled) then Raise Exception.Create('OpenGL is disabled'); //. =>
OperationLock.Enter;
try
_DeleteSegmentsTextures:=Segments;
//. set start
ResetEvent(evtFinished);
SetEvent(evtStart);
//. wait operation end
WaitForSingleObject(evtFinished,INFINITE);
if (OperationException <> nil)
 then
  try
  Raise Exception.Create(OperationException.Message); //. =>
  finally
  FreeAndNil(OperationException);
  end;
finally
OperationLock.Leave;
end;
end;

function TDPVSegmentsOGLTextures.DrawOnCanvas(const Functionality: TBase2DVisualizationFunctionality; const Canvas: TCanvas; const Segments: pointer; const SegmentsSize: integer; const SegmentWidth: double; const SegmentHeight: double; const XIndexMin: integer; const YIndexMin: integer; const dX: Extended; const dY: Extended; const WidthScale: Extended; const HeightScale: Extended; const Rotation: Extended; const flBestQuality: boolean): boolean;
begin
if (NOT flEnabled) then Raise Exception.Create('OpenGL is disabled'); //. =>
OperationLock.Enter;
try
//. draw canvas to temp bitmap
BitBlt(DIB_DC, 0,0,DIB_BitInfo.bmiHeader.biWidth,DIB_BitInfo.bmiHeader.biHeight, Canvas.Handle, 0,0, SRCCOPY);
//.
_DrawCanvas_Functionality:=Functionality;
_DrawCanvas_Segments:=Segments;
_DrawCanvas_SegmentsSize:=SegmentsSize;
_DrawCanvas_SegmentWidth:=SegmentWidth;
_DrawCanvas_SegmentHeight:=SegmentHeight;
_DrawCanvas_XIndexMin:=XIndexMin;
_DrawCanvas_YIndexMin:=YIndexMin;
_DrawCanvas_dX:=dX;
_DrawCanvas_dY:=dY;
_DrawCanvas_WidthScale:=WidthScale;
_DrawCanvas_HeightScale:=HeightScale;
_DrawCanvas_Rotation:=Rotation;
_DrawCanvas_flBestQuality:=flBestQuality;
//. set start
ResetEvent(evtFinished);
SetEvent(evtStart);
//. wait operation end
WaitForSingleObject(evtFinished,INFINITE);
if (OperationException <> nil)
 then
  try
  Raise Exception.Create(OperationException.Message); //. =>
  finally
  FreeAndNil(OperationException);
  end;
//. draw back to canvas
BitBlt(Canvas.Handle, 0,0,DIB_BitInfo.bmiHeader.biWidth,DIB_BitInfo.bmiHeader.biHeight, DIB_DC, 0, 0, SRCCOPY);
//.
Result:=_DrawCanvas_Result;
finally
OperationLock.Leave;
end;
end;

procedure TDPVSegmentsOGLTextures.LastAccessTextureSegments_Insert(const pSegment: pointer);
var
  ptrptrItem: pointer;
  ptrItem: pointer;
begin
ptrItem:=nil;
ptrptrItem:=@LastAccessTextureSegments;
while Pointer(ptrptrItem^) <> nil do with TDPVTextureSegmentItem(Pointer(ptrptrItem^)^) do begin
  if Segment = pSegment
   then begin
    ptrItem:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TDPVTextureSegmentItem(ptrItem^).ptrNext:=LastAccessTextureSegments;
    LastAccessTextureSegments:=ptrItem;
    Break; //. >
    end;
  ptrptrItem:=@ptrNext;
  end;
if (ptrItem = nil)
 then begin
  GetMem(ptrItem,SizeOf(TDPVTextureSegmentItem));
  with TDPVTextureSegmentItem(ptrItem^) do begin
  ptrNext:=LastAccessTextureSegments;
  Segment:=pSegment;
  end;
  LastAccessTextureSegments:=ptrItem;
  Inc(LastAccessTextureSegmentsCount);
  end;
end;

procedure TDPVSegmentsOGLTextures.LastAccessTextureSegments_Remove(const pSegment: pointer);
var
  ptrptrItem: pointer;
  ptrDestroyItem: pointer;
begin
ptrptrItem:=@LastAccessTextureSegments;
while (Pointer(ptrptrItem^) <> nil) do with TDPVTextureSegmentItem(Pointer(ptrptrItem^)^) do
  if (Segment = pSegment)
   then begin
    ptrDestroyItem:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=TDPVTextureSegmentItem(ptrDestroyItem^).ptrNext;
    FreeMem(ptrDestroyItem,SizeOf(TDPVTextureSegmentItem));
    Dec(LastAccessTextureSegmentsCount);
    Exit; //. ->
    end
   else ptrptrItem:=@ptrNext;
end;

procedure TDPVSegmentsOGLTextures.LastAccessTextureSegments_RemoveOld(const Count: integer; out RemoveList: TList);
var
  Delta: integer;
  ptrptrItem: pointer;
  ptrDestroyItem: pointer;
  I: integer;
begin
RemoveList:=nil;
Delta:=(LastAccessTextureSegmentsCount-Count);
if (Delta <= 0) then Exit; //. ->
RemoveList:=TList.Create;
try
RemoveList.Capacity:=Delta;
ptrptrItem:=@LastAccessTextureSegments;
//. skip normal items
I:=0;
while (Pointer(ptrptrItem^) <> nil) do with TDPVTextureSegmentItem(Pointer(ptrptrItem^)^) do
  if (I < Count)
   then begin
    ptrptrItem:=@ptrNext;
    Inc(I);
    end
   else Break; //. >
//. remove the rest
while (Pointer(ptrptrItem^) <> nil) do with TDPVTextureSegmentItem(Pointer(ptrptrItem^)^) do begin
  ptrDestroyItem:=Pointer(ptrptrItem^);
  Pointer(ptrptrItem^):=TDPVTextureSegmentItem(ptrDestroyItem^).ptrNext;
  //.
  RemoveList.Add(TDPVTextureSegmentItem(ptrDestroyItem^).Segment);
  //.
  FreeMem(ptrDestroyItem,SizeOf(TDPVTextureSegmentItem));
  end;
//.
Dec(LastAccessTextureSegmentsCount,Delta);
except
  FreeAndNil(RemoveList);
  Raise; //. =>
  end;
end;

procedure TDPVSegmentsOGLTextures.LastAccessTextureSegments_Clear;
var
  ptrDestroyItem: pointer;
begin
while (LastAccessTextureSegments <> nil) do begin
  ptrDestroyItem:=LastAccessTextureSegments;
  LastAccessTextureSegments:=TDPVTextureSegmentItem(ptrDestroyItem^).ptrNext;
  FreeMem(ptrDestroyItem,SizeOf(TDPVTextureSegmentItem));
  end;
LastAccessTextureSegmentsCount:=0;
end;

function TDPVSegmentsOGLTextures.InstallTexture(const ImageStream: TMemoryStream): cardinal;

  function RoundDownToPowerOf2(Value: Integer): Integer;
  var
    LogTwo: Double;
  begin
  LogTwo:=log2(Value);
  if Trunc(LogTwo) < LogTwo then Result:=Trunc(Power(2,Trunc(LogTwo))) else Result:=Value;
  end;

  function CreateTextureObject(const DC: HDC; const MS: TMemoryStream; const MinFilter: Cardinal): cardinal;
  type
    TBA = array[0..0] of byte;
    PByteArray = ^TBA;

  var
    iWidth, iHeight, iNChannels: Integer;
    iDIBChannels: integer;
    iStatus: integer;
    jcprops: TJPEG_CORE_PROPERTIES;
    DIB: cardinal;
    DIB_BitInfo: TBitmapInfo;
    BitsPtr: PByteArray;
    AlignedWidth,AlignedHeight: integer;
    StretchedDC: cardinal;
    StretchedDIB: cardinal;
    StretchedDIB_BitInfo: TBitmapInfo;
    StretchedBitsPtr: PByteArray;
    ImageSize: Cardinal;
    Temp: Byte;
    J: integer;
  begin
  Result:=0;
  //.
  IJL_Lock.Enter;
  try
  iDIBchannels := 3;
  FillChar(jcprops,SizeOf(jcprops),0);
  iStatus:=ijlInit(@jcprops);
  if iStatus = IJL_OK
   then
    try
    jcprops.JPGBytes:=MS.Memory;
    jcprops.JPGSizeBytes:=MS.Size;
    iStatus:=ijlRead(@jcprops,IJL_JBUFF_READPARAMS);
    if iStatus = IJL_OK
     then begin
      iWidth:=jcprops.JPGWidth;
      iHeight:=jcprops.JPGHeight;
      iNChannels:=jcprops.JPGChannels;
      if (iNChannels = 3)
       then begin
        iDIBChannels:=iNChannels;
        //. create bitmap DIB
        ZeroMemory(@DIB_BitInfo,sizeof(BITMAPINFO));
        with DIB_BitInfo.bmiHeader do begin
        biSize:=sizeOf(DIB_BitInfo.bmiHeader);
        biBitCount:=24;
        biCompression:=BI_RGB;
        biPlanes:=1;
        biWidth:=iWidth;
        biHeight:=iHeight;
        biSizeImage:=(biWidth*(biBitCount div 8))*biHeight;
        end;
        //.
        DIB:=0;
        DIB:=CreateDIBSection(DC, DIB_BitInfo, DIB_RGB_COLORS, Pointer(BitsPtr), 0, 0);
        try
        jcprops.DIBWidth:=iWidth;
        jcprops.DIBHeight:=-iHeight;
        jcprops.DIBChannels:=iDIBChannels;
        jcprops.DIBColor:=IJL_BGR;
        jcprops.DIBPadBytes:=((((iWidth*iDIBChannels)+3) div 4)*4)-(iWidth*iDIBChannels);
        jcprops.DIBBytes:=Pointer(BitsPtr);
        iStatus:=ijlRead(@jcprops,IJL_JBUFF_READWHOLEIMAGE);
        if (iStatus < 0) then Exit; //. ->
        //.
        SelectObject(DC, DIB);
        //. aligning sizes if needed
        AlignedWidth:=RoundDownToPowerOf2(iWidth);
        AlignedHeight:=RoundDownToPowerOf2(iHeight);
        if ((AlignedWidth <> iWidth) OR (AlignedHeight <> iHeight))
         then begin
          StretchedDC:=CreateCompatibleDC(0);
          try
          ZeroMemory(@StretchedDIB_BitInfo,sizeof(BITMAPINFO));
          with StretchedDIB_BitInfo.bmiHeader do begin
          biSize:=sizeOf(StretchedDIB_BitInfo.bmiHeader);
          biBitCount:=24;
          biCompression:=BI_RGB;
          biPlanes:=1;
          biWidth:=AlignedWidth;
          biHeight:=AlignedHeight;
          biSizeImage:=(biWidth*(biBitCount div 8))*biHeight;
          end;
          //.
          StretchedDIB:=CreateDIBSection(StretchedDC, StretchedDIB_BitInfo, DIB_RGB_COLORS, Pointer(StretchedBitsPtr), 0, 0);
          try
          SelectObject(StretchedDC, StretchedDIB);
          //.
          SetStretchBltMode(StretchedDC,HALFTONE);
          StretchBlt(StretchedDC,0,0,AlignedWidth,AlignedHeight,DC,0,0,iWidth,iHeight,SRCCOPY);
          //.
          //. creating texture
          glGenTextures(1, @Result);
          glBindTexture(GL_TEXTURE_2D, Result);
          if (GL_EXT_bgra)
           then
            if (MinFilter = GL_NEAREST) or (MinFilter = GL_LINEAR)
              then glTexImage2d(GL_TEXTURE_2D, 0, 3, AlignedWidth, AlignedHeight, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE, StretchedBitsPtr)
              else gluBuild2DMipmaps(GL_TEXTURE_2D, 3, AlignedWidth, AlignedHeight, GL_BGR_EXT, GL_UNSIGNED_BYTE, StretchedBitsPtr)
           else begin
            {$ifopt R+} {$define RangeCheck} {$R-} {$endif}
            ImageSize:=AlignedWidth*AlignedHeight;
            for J := 0 to ImageSize - 1 do // swap blue with red to go from bgr to rgb
            begin
              Temp := StretchedBitsPtr[J * 3];
              StretchedBitsPtr[J * 3]:=StretchedBitsPtr[J * 3 + 2];
              StretchedBitsPtr[J * 3 + 2]:=Temp;
            end;
            {$ifdef RangeCheck} {$undef RangeCheck} {$R+} {$endif}
            if (MinFilter = GL_NEAREST) or (MinFilter = GL_LINEAR)
              then glTexImage2d(GL_TEXTURE_2D, 0, 3, AlignedWidth, AlignedHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, StretchedBitsPtr)
              else gluBuild2DMipmaps(GL_TEXTURE_2D, 3, AlignedWidth, AlignedHeight, GL_RGB, GL_UNSIGNED_BYTE, StretchedBitsPtr);
            end;
          finally
          if (StretchedDIB <> 0)
           then begin
            SelectObject(StretchedDC,0);
            DeleteObject(StretchedDIB);
            end;
          end;
          finally
          if (StretchedDC <> 0) then DeleteDC(StretchedDC);
          end;
          end
         else begin //. creating texture
          glGenTextures(1, @Result);
          glBindTexture(GL_TEXTURE_2D, Result);
          if (GL_EXT_bgra)
           then
            if (MinFilter = GL_NEAREST) or (MinFilter = GL_LINEAR)
              then glTexImage2d(GL_TEXTURE_2D, 0, 3, iWidth, iHeight, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE, BitsPtr)
              else gluBuild2DMipmaps(GL_TEXTURE_2D, 3, iWidth, iHeight, GL_BGR_EXT, GL_UNSIGNED_BYTE, BitsPtr)
           else begin
            {$ifopt R+} {$define RangeCheck} {$R-} {$endif}
            ImageSize:=iWidth*iHeight;
            for J := 0 to ImageSize - 1 do // swap blue with red to go from bgr to rgb
            begin
              Temp := BitsPtr[J * 3];
              BitsPtr[J * 3]:=BitsPtr[J * 3 + 2];
              BitsPtr[J * 3 + 2]:=Temp;
            end;
            {$ifdef RangeCheck} {$undef RangeCheck} {$R+} {$endif}
            if (MinFilter = GL_NEAREST) or (MinFilter = GL_LINEAR)
              then glTexImage2d(GL_TEXTURE_2D, 0, 3, iWidth, iHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, BitsPtr)
              else gluBuild2DMipmaps(GL_TEXTURE_2D, 3, iWidth, iHeight, GL_RGB, GL_UNSIGNED_BYTE, BitsPtr);
            end;
          end;
        finally
        if (DIB <> 0)
         then begin
          SelectObject(DC,0);
          DeleteObject(DIB);
          end;
        end;
        end;
      end;
    finally
    ijlFree(@jcprops);
    end;
  finally
  IJL_Lock.Leave;
  end;
  end;

begin
Result:=CreateTextureObject(Texture_DC,ImageStream,GL_NEAREST);
end;

function TDPVSegmentsOGLTextures.DoDrawOnCanvas(const Functionality: TBase2DVisualizationFunctionality; const Segments: pointer; const SegmentsSize: integer; const SegmentWidth: double; const SegmentHeight: double; const XIndexMin: integer; const YIndexMin: integer; const dX: Extended; const dY: Extended; const WidthScale: Extended; const HeightScale: Extended; const Rotation: Extended; const flBestQuality: boolean): boolean;
var
  I: integer;
  Segment: pointer;
begin
Result:=false;
//. draw
glMatrixMode(GL_PROJECTION);
glLoadIdentity;
glOrtho(0,DIB_BitInfo.bmiHeader.biWidth,0,DIB_BitInfo.bmiHeader.biHeight, 0, 1);
glTranslated(dX,DIB_BitInfo.bmiHeader.biHeight-dY, 0);
glMatrixMode(GL_MODELVIEW);
glLoadIdentity;
//. transformations
glRotated(-((180.0/PI)*Rotation),0,0,1);
glScaled(WidthScale,HeightScale,0);
//.
for I:=0 to (SegmentsSize DIV SizeOf(Pointer))-1 do begin
  Segment:=Pointer(Pointer(Integer(Segments)+I*SizeOf(Pointer))^);
  //.
  TypeSystem.Cash.Segment_Lock(Segment);
  try
  with TSegmentItemOfTDetailedPictureVisualizationCash(Segment^) do begin
  if ((Params._DATA <> nil) AND (Params._DATA.Size > 0))
   then begin
    if (_idOGLTexture = 0) then _idOGLTexture:=InstallTexture(Params._DATA);
    //. drawing ...
    with Params do begin
    glPushMatrix;
    glTranslated(((XIndex-XIndexMin)*SegmentWidth),-((YIndex-YIndexMin)*SegmentHeight),0);
    glBindTexture(GL_TEXTURE_2D, _idOGLTexture);
    if (flBestQuality)
     then begin
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
      end
     else begin
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
      end;
    glBegin(GL_QUAD_STRIP);
      glTexCoord2d(0, 1);
      glVertex2d(0, 0);
      glTexCoord2d(1, 1);
      glVertex2d(SegmentWidth, 0);
      glTexCoord2d(0, 0);
      glVertex2d(0, -SegmentHeight);
      glTexCoord2d(1, 0);
      glVertex2d(SegmentWidth,-SegmentHeight);
    glEnd;
    glPopMatrix;
    end;
    //. segment accessed
    LastAccessTextureSegments_Insert(Segment);
    end;
  end;
  finally
  TypeSystem.Cash.Segment_Unlock(Segment);
  end;
  //.
  //. ? if ((Functionality <> nil) AND (Now > Functionality.BestBeforeTime)) then Break; //. >
  end;
//.
glFlush;
//.
Result:=true;
end;


//. TTDetailedPictureVisualizationCash
Constructor TTDetailedPictureVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
Lock:=TMultiReadExclusiveWriteSynchronizer.Create;
AccessedSegmentsRevising:=TDPVAccessedSegmentsRevising.Create(Self);
PersistLevelsProviding:=TDPVPersistLevelsProviding.Create(Self); 
FItems:=nil;
end;

destructor TTDetailedPictureVisualizationCash.Destroy;
begin
Empty;
PersistLevelsProviding.Free;
AccessedSegmentsRevising.Free;
Lock.Free;
Inherited;
end;

procedure TTDetailedPictureVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
Lock.BeginWrite;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTDetailedPictureVisualizationCash(ptrDelItem^).ptrNext;
  //.
  TDetailedPictureVisualizationCashItem_FreeAndNilLevels(TSystemTDetailedPictureVisualization(TypeSystem),TItemTDetailedPictureVisualizationCash(ptrDelItem^).Levels);
  //.
  FreeMem(ptrDelItem,SizeOf(TItemTDetailedPictureVisualizationCash));
  end;
finally
Lock.EndWrite;
end;
end;

procedure TTDetailedPictureVisualizationCash.ConvertDATAToBMP(const DS: TMemoryStream; out BMP: TBitmap);
var
  JI: TJPEGImage;
begin
JI:=TJPEGImage.Create;
with JI do
try
with TBitmap.Create do
try
if DS.Size > 0
 then begin
  JI.LoadFromStream(DS);
  Canvas.Lock();
  try
  Assign(JI);
  finally
  Canvas.Unlock();
  end;
  end;
BMP:=TBitmap.Create;
BMP.Canvas.Lock();
try
BMP.HandleType:=bmDIB;
BMP.PixelFormat:=pf24bit;
BMP.Assign(JI);
finally
BMP.Canvas.Unlock();
end;
finally
Destroy;
end;
finally
Destroy;
end;
end;

procedure TTDetailedPictureVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TDetailedPictureVisualizationFunctionality;
  BA: TByteArray;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTDetailedPictureVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTDetailedPictureVisualizationCash), 0);
    with TItemTDetailedPictureVisualizationCash(ptrNewItem^) do begin
    ptrObj:=nilPtr;
    Levels:=nil;
    Width:=0;
    Height:=0;
    CF:=TDetailedPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetParams(Width,Height);
    CF.GetLevelsInfo(BA);
    TDetailedPictureVisualizationCashItem_PrepareLevelsFromByteArray(ptrNewItem,Levels,BA);
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    Lock.BeginWrite;
    try
    TItemTDetailedPictureVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    Lock.EndWrite;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTDetailedPictureVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTDetailedPictureVisualizationCash), 0);
    with TItemTDetailedPictureVisualizationCash(ptrNewItem^) do begin
    ptrObj:=nilPtr;
    Levels:=nil;
    Width:=0;
    Height:=0;
    CF:=TDetailedPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try CF.GetParams(Width,Height); except on E: EActionsGroup do ; else Raise; end;
    try CF.GetLevelsInfo(BA); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTDetailedPictureVisualizationCash(ItemsList[I]^) do with TDetailedPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    with TItemTDetailedPictureVisualizationCash(ItemsList[I]^) do GetParams(Width,Height);
    GetLevelsInfo(BA);
    TDetailedPictureVisualizationCashItem_PrepareLevelsFromByteArray(ItemsList[I],Levels,BA);
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  Lock.BeginWrite;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTDetailedPictureVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  Lock.EndWrite;
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;



procedure TTDetailedPictureVisualizationCash.Update;
begin
Empty;
end;

function TTDetailedPictureVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
Lock.BeginWrite;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTDetailedPictureVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTDetailedPictureVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit; //. ->
    end;
  ptrptrItem:=@ptrNext;
  end;
finally
Lock.EndWrite;
end;
end;

function TTDetailedPictureVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if (ptrItem = nil) then Exit; //. ->
Result:=true;
end;

function TTDetailedPictureVisualizationCash.NotRecombinatedGetPtrItem(const pidObj: integer): pointer;
begin
Lock.BeginRead;
try
Result:=FItems;
while (Result <> nil) do with TItemTDetailedPictureVisualizationCash(Result^) do begin
  if (idObj = pidObj) then Exit; //. ->
  //. next item
  Result:=ptrNext;
  end;
finally
Lock.EndRead;
end;
end;

function TTDetailedPictureVisualizationCash.NotRecombinatedGetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=NotRecombinatedGetPtrItem(pidObj);
if (ptrItem = nil) then Exit; //. ->
Result:=true;
end;

procedure TTDetailedPictureVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
Lock.BeginRead;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTDetailedPictureVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
Lock.EndRead;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTDetailedPictureVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TDetailedPictureVisualizationFunctionality;
    BA: TByteArray;
  begin
  with TItemTDetailedPictureVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TDetailedPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  TDetailedPictureVisualizationCashItem_FreeAndNilLevels(TSystemTDetailedPictureVisualization(TypeSystem),Levels);
  //.
  idObj:=CF.idObj;
  CF.GetParams(Width,Height);
  CF.GetLevelsInfo(BA);
  TDetailedPictureVisualizationCashItem_PrepareLevelsFromByteArray(ptrItem,Levels,BA);
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
  ptrDestroyItem: pointer;
begin
Lock.BeginWrite;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTDetailedPictureVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTDetailedPictureVisualizationCash), 0);
  with TItemTDetailedPictureVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  ptrObj:=nilPtr;
  Width:=0;
  Height:=0;
  Levels:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then begin
    //. remove segments
    AccessedSegmentsRevising.RemoveVisualizationSegments(ptrUpdateItem);
    Context_DestroyItemSegmentFiles(pidObj);
    //.
    UpdateItem(ptrUpdateItem);
    end
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTDetailedPictureVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTDetailedPictureVisualizationCash), 0);
    with TItemTDetailedPictureVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    ptrObj:=nilPtr;
    Width:=0;
    Height:=0;
    Levels:=nil;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  //. remove segments
  ptrDestroyItem:=GetPtrItem(pidObj);
  if (ptrDestroyItem <> nil) then AccessedSegmentsRevising.RemoveVisualizationSegments(ptrDestroyItem);
  Context_DestroyItemSegmentFiles(pidObj);
  //.
  RemoveItem(pidObj);
  end;
end;
finally
Lock.EndWrite;
end;
end;}

procedure TTDetailedPictureVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TDetailedPictureVisualizationFunctionality;
    BA: TByteArray;
  begin
  with TItemTDetailedPictureVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TDetailedPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  TDetailedPictureVisualizationCashItem_FreeAndNilLevels(TSystemTDetailedPictureVisualization(TypeSystem),Levels);
  //.
  idObj:=CF.idObj;
  CF.GetParams(Width,Height);
  CF.GetLevelsInfo(BA);
  TDetailedPictureVisualizationCashItem_PrepareLevelsFromByteArray(ptrItem,Levels,BA);
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTDetailedPictureVisualizationCash; const ptrItem: pointer);

    procedure Levels_ValidatePointers(const Levels: pointer; const ptrDestItem: pointer);
    var
      ptrLevel: pointer;
    begin
    ptrLevel:=Levels;
    while (ptrLevel <> nil) do with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
      ptrItem:=ptrDestItem;
      ptrLevel:=ptrNext;
      end;
    end;

  begin
  with TItemTDetailedPictureVisualizationCash(ptrItem^) do begin
  //. defaults
  TDetailedPictureVisualizationCashItem_FreeAndNilLevels(TSystemTDetailedPictureVisualization(TypeSystem),Levels);
  //.
  Width:=Item.Width;
  Height:=Item.Height;
  Levels:=Item.Levels;
  //. validate levels pointers to owner object
  Levels_ValidatePointers(Levels,ptrItem);
  end;
  end;

  procedure FreeItem(var Item: TItemTDetailedPictureVisualizationCash);
  begin
  TDetailedPictureVisualizationCashItem_FreeAndNilLevels(TSystemTDetailedPictureVisualization(TypeSystem),Item.Levels);
  end;

var
  Item: TItemTDetailedPictureVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
  ptrDestroyItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
Lock.BeginWrite;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTDetailedPictureVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTDetailedPictureVisualizationCash), 0);
  with TItemTDetailedPictureVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  ptrObj:=nilPtr;
  Width:=0;
  Height:=0;
  Levels:=nil;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then begin
    //. remove segments
    AccessedSegmentsRevising.RemoveVisualizationSegments(ptrUpdateItem);
    //. do not destroy segments files besause these are not to be removed on update operation // Context_DestroyItemSegmentFiles(pidObj);
    //.
    MoveItem(Item,ptrUpdateItem);
    end
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTDetailedPictureVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTDetailedPictureVisualizationCash), 0);
    with TItemTDetailedPictureVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    ptrObj:=nilPtr;
    Width:=0;
    Height:=0;
    Levels:=nil;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  //. remove segments
  ptrDestroyItem:=GetPtrItem(pidObj);
  if (ptrDestroyItem <> nil) then AccessedSegmentsRevising.RemoveVisualizationSegments(ptrDestroyItem);
  Context_DestroyItemSegmentFiles(pidObj);
  //.
  RemoveItem(pidObj);
  end;
end;
finally
Lock.EndWrite;
end;
end;

procedure TTDetailedPictureVisualizationCash.UpdateLocalForPartialUpdate(const idObj: integer; const Data: TByteArray);
var
  ptrData: pointer;
  Version: word;
  idLevel: integer;
  XMinIndex,YMinIndex,XMaxIndex,YMaxIndex: integer;
  ptrItem: pointer;
  ptrLevel: pointer;
  ExceptSegments: TByteArray;
begin
ptrData:=Pointer(@Data[0]);
Version:=Word(ptrData^); Inc(Integer(ptrData),SizeOf(Version));
case Version of
1: begin
  idLevel:=Integer(ptrData^); Inc(Integer(ptrData),SizeOf(idLevel));
  XMinIndex:=Integer(ptrData^); Inc(Integer(ptrData),SizeOf(XMinIndex));
  YMinIndex:=Integer(ptrData^); Inc(Integer(ptrData),SizeOf(YMinIndex));
  XMaxIndex:=Integer(ptrData^); Inc(Integer(ptrData),SizeOf(XMaxIndex));
  YMaxIndex:=Integer(ptrData^); Inc(Integer(ptrData),SizeOf(YMaxIndex));
  //. updating segments
  TSystemTDetailedPictureVisualization(TypeSystem).Cash.Lock.BeginRead;
  try
  ptrItem:=NotRecombinatedGetPtrItem(idObj);
  if (ptrItem = nil) then Exit; //. ->
  ptrLevel:=TItemTDetailedPictureVisualizationCash(ptrItem^).Levels;
  while (ptrLevel <> nil) do with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
    Lock.BeginRead;
    try
    if (Params.id = idLevel) then Break; //. >
    finally
    Lock.EndRead;
    end;
    //. next level
    ptrLevel:=ptrNext;
    end;
  if (ptrLevel = nil) then Exit; //. ->
  //.
  SetLength(ExceptSegments,0);
  Item_Level__UpdateSegmentsLocal(ptrItem,ptrLevel, XMinIndex,XMaxIndex,YMinIndex,YMaxIndex, ExceptSegments, nil);
  finally
  TSystemTDetailedPictureVisualization(TypeSystem).Cash.Lock.EndRead;
  end;
  end;
else
  EventLog.WriteMinorEvent('TTDetailedPictureVisualizationCash.UpdateLocalForPartialUpdate','Unknown update data version, Version = '+IntToStr(Version),'Supported version(s): 1');
end;
end;

procedure TTDetailedPictureVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
Lock.BeginWrite;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTDetailedPictureVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTDetailedPictureVisualizationCash(ptrDelItem^).ptrNext;
    //.
    TDetailedPictureVisualizationCashItem_FreeAndNilLevels(TSystemTDetailedPictureVisualization(TypeSystem),TItemTDetailedPictureVisualizationCash(ptrDelItem^).Levels);
    //.
    FreeMem(ptrDelItem,SizeOf(TItemTDetailedPictureVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTDetailedPictureVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
Lock.EndWrite;
end;
end;

function TTDetailedPictureVisualizationCash.Item_GetContextFolder(const Item_idObj: integer): string;
begin
with Space do Result:=WorkLocale+'\'+PathContexts+'\'+IntToStr(ID)+'\'+SUMMARYUserContextFolder+'\'+ChangeFileExt(ContextFileName,'')+'\'+'TypesSystem'+'\'+'DetailedPictureVisualization'+'\'+IntToStr(Item_idObj);
end;

function TTDetailedPictureVisualizationCash.Item_Level__GetContextFolder(const Item_idObj: integer; const idLevel: integer): string;
begin
with Space do Result:=WorkLocale+'\'+PathContexts+'\'+IntToStr(ID)+'\'+SUMMARYUserContextFolder+'\'+ChangeFileExt(ContextFileName,'')+'\'+'TypesSystem'+'\'+'DetailedPictureVisualization'+'\'+IntToStr(Item_idObj)+'\'+'L'+IntToStr(idLevel);
end;

function TTDetailedPictureVisualizationCash.Item_Level__GetSegmentsLocal(const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; out LocalSegments: TByteArray): boolean;
var
  SizeX,SizeY: integer;
  ItemsList: TList;
  Segment: pointer;
  SegmentID: integer;
  I: integer;
begin
SizeX:=(XIndexMax-XIndexMin+1);
SizeY:=(YIndexMax-YIndexMin+1);
with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
Lock.BeginRead;
try
//. prepare cached segments
ItemsList:=TList.Create;
try
ItemsList.Capacity:=(SizeX*SizeY);
Segment:=Segments;
while (Segment <> nil) AND (TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.YIndex < YIndexMin) do Segment:=TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).ptrNext;
while (Segment <> nil) AND (TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.YIndex <= YIndexMax) do begin
  if ((XIndexMin <= TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.XIndex) AND (TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.XIndex <= XIndexMax))
   then ItemsList.Add(Segment);
  Segment:=TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).ptrNext;
  end;
if (ItemsList.Count > 0)
 then begin
  if (ItemsList.Count <> (SizeX*SizeY))
   then begin
    SetLength(LocalSegments,(ItemsList.Count*SizeOf(SegmentID)));
    for I:=0 to ItemsList.Count-1 do begin
      SegmentID:=TSegmentItemOfTDetailedPictureVisualizationCash(ItemsList[I]^).Params.ID;
      Integer(Pointer(@LocalSegments[I*SizeOf(SegmentID)])^):=SegmentID;
      end;
    Result:=false;
    end
   else Result:=true;
  end
 else begin
  SetLength(LocalSegments,0);
  Result:=false;
  end;
finally
ItemsList.Destroy;
end;
finally
Lock.EndRead;
end;
end;
end;

function TTDetailedPictureVisualizationCash.Item_Level__GetVisibleSegmentsLocal(const ptrItem: pointer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const flSegmentsInMemory: boolean; const flLoadFromContextFiles: boolean; const ptrCancelFlag: pointer; out ItemsTable: pointer; out ItemsTableSize: integer; out ExceptSegments: TByteArray; const ptrHasEmptySegmentFlag: pointer = nil): boolean;
var
  ItemsList: TList;
  Segment: pointer;
  SegmentID: integer;
  I: integer;
  SizeX,SizeY: integer;
  ptr: pointer;
  LevelFolder: string;
  SegmentFileName: string;
  flGenerateTexture: boolean;
begin
ItemsTable:=nil;
try
SizeX:=(XIndexMax-XIndexMin+1);
SizeY:=(YIndexMax-YIndexMin+1);
with TItemTDetailedPictureVisualizationCash(ptrItem^) do
with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
//. prepare cached segments
ItemsList:=TList.Create;
try
ItemsList.Capacity:=(SizeX*SizeY);
Segment:=Segments;
while (Segment <> nil) AND (TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.YIndex < YIndexMin) do Segment:=TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).ptrNext;
while (Segment <> nil) AND (TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.YIndex <= YIndexMax) do begin
  if (
      ((XIndexMin <= TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.XIndex) AND (TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.XIndex <= XIndexMax)) AND
      (NOT flSegmentsInMemory OR (NOT Segment_DATAIsNull(Segment)))
  )
   then ItemsList.Add(Segment);
  Segment:=TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).ptrNext;
  end;
//.
if (ItemsList.Count > 0)
 then begin
  //. prepare items table
  ItemsTableSize:=ItemsList.Count*SizeOf(Pointer);
  GetMem(ItemsTable,ItemsTableSize);
  ptr:=ItemsTable;
  for I:=0 to ItemsList.Count-1 do begin
    Pointer(ptr^):=ItemsList[I];
    Inc(DWord(ptr),SizeOf(Pointer));
    end;
  {validate cached items}
  if ((NOT flSegmentsInMemory) AND flLoadFromContextFiles)
   then begin
    LevelFolder:=Item_Level__GetContextFolder(idObj,Params.ID);
    for I:=0 to ItemsList.Count-1 do with TSegmentItemOfTDetailedPictureVisualizationCash(ItemsList[I]^).Params do begin
      Segment_Lock(ItemsList[I]);
      try
      if (_DATA = nil)
       then begin
        SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
        _DATA:=TMemoryStream.Create();
        if (FileExists(SegmentFileName)) then _DATA.LoadFromFile(SegmentFileName);
        //.
        flGenerateTexture:=true;
        end
       else flGenerateTexture:=false;
      finally
      Segment_Unlock(ItemsList[I]);
      end;
      //.
      if (TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.flEnabled AND flGenerateTexture) then TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentTexture(ItemsList[I]);
      //.
      if (ptrCancelFlag <> nil)
       then begin
        Sleep(0); //. exit from the current thread to alow the cancel flag to be set
        if (Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
        end;
      end;
    end;
  {check empty segments}
  if (ptrHasEmptySegmentFlag <> nil)
   then begin
    Boolean(ptrHasEmptySegmentFlag^):=false;
    for I:=0 to ItemsList.Count-1 do 
      if (Segment_DATAIsEmpty(ItemsList[I]))
       then begin
        Boolean(ptrHasEmptySegmentFlag^):=true;
        Break; //. >
        end;
    end;
  //.
  if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
  {process items as accessed}
  AccessedSegmentsRevising.AddByList(ItemsList,ptrLevel,idObj);
  //.
  if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
  //.
  if (ItemsList.Count <> (SizeX*SizeY))
   then begin
    SetLength(ExceptSegments,(ItemsList.Count*SizeOf(SegmentID)));
    for I:=0 to ItemsList.Count-1 do begin
      SegmentID:=TSegmentItemOfTDetailedPictureVisualizationCash(ItemsList[I]^).Params.ID;
      Integer(Pointer(@ExceptSegments[I*SizeOf(SegmentID)])^):=SegmentID;
      end;
    Result:=false;
    end
   else Result:=true;
  end
 else begin
  SetLength(ExceptSegments,0);
  Result:=false;
  end;
finally
ItemsList.Destroy;
end;
end;
except
  if (ItemsTable <> nil) then FreeMem(ItemsTable,ItemsTableSize);
  Raise; //. =>
  end;
end;

function TTDetailedPictureVisualizationCash.Item_Level__RestoreSegmentsLocal(const ptrItem: pointer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ptrCancelFlag: pointer; out ItemsList: TList; var ExceptSegments: TByteArray): boolean;

  function ExceptSegments_SegmentFound(ExceptSegmentsPtr: pointer; ExceptSegmentsSize: integer; SegmentID: integer): boolean;
  begin
  asm
        PUSH EAX
        PUSH ECX
        PUSH EDI
        MOV EAX,SegmentID
        MOV EDI,ExceptSegmentsPtr
        CMP EDI,0 {nil}
        JE @M1
        MOV ECX,ExceptSegmentsSize
        JECXZ @M1
        CLD
        REPNE SCASD
        JNE @M1
          MOV Result,true
          JMP @M2
  @M1:  MOV Result,false
  @M2:  POP EDI
        POP ECX
        POP EAX
  end;
  end;

  function RestoreSegment(const idObj: integer; const LevelFolder: string; const X,Y: integer; out SegmentDATA: TMemoryStream): boolean;
  var
    SegmentFileName: string;
  begin
  Result:=false;
  SegmentDATA:=nil;
  SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(X)+'Y'+IntToStr(Y)+'.jpg';
  try
  if (NOT FileExists(SegmentFileName)) then Exit; //. ->
  SegmentDATA:=TMemoryStream.Create;
  SegmentDATA.LoadFromFile(SegmentFileName);
  Result:=true;
  except
    FreeAndNil(SegmentDATA);
    end;
  end;

var
  SizeX,SizeY: integer;
  LevelFolder: string;
  ExceptSegmentsPtr: pointer;
  ExceptSegmentsSize: integer;
  X,Y: integer;
  SegmentID: integer;
  RestoredSegmentDATA: TMemoryStream;
  RestoredSegment: pointer;
  ExistedSegment: pointer;
  Ofs: integer;
  I: integer;
begin
Result:=false;
ItemsList:=nil;
try
with TItemTDetailedPictureVisualizationCash(ptrItem^) do begin
//.
with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
Lock.BeginRead;
try
LevelFolder:=Item_Level__GetContextFolder(idObj,Params.ID);
//.
SizeX:=(XIndexMax-XIndexMin+1);
SizeY:=(YIndexMax-YIndexMin+1);
//.
ExceptSegmentsPtr:=@ExceptSegments[0];
ExceptSegmentsSize:=(Length(ExceptSegments) DIV SizeOf(SegmentID));
//.
ItemsList:=TList.Create;
ItemsList.Capacity:=(SizeX*SizeY-ExceptSegmentsSize);
for Y:=YIndexMin to YIndexMax do
  for X:=XIndexMin to XIndexMax do begin
    SegmentID:=SegmentPositionHashCode(X,Y);
    if (NOT ExceptSegments_SegmentFound(ExceptSegmentsPtr,ExceptSegmentsSize,SegmentID))
     then begin
      if (RestoreSegment(idObj, LevelFolder, X,Y, RestoredSegmentDATA))
       then begin
        //. create and insert restored item
        GetMem(RestoredSegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
        with TSegmentItemOfTDetailedPictureVisualizationCash(RestoredSegment^) do begin
        ptrNext:=nil;
        Lock:=TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).SegmentLock;
        with Params do begin
        id:=SegmentID;
        XIndex:=X;
        YIndex:=Y;
        _DATA:=RestoredSegmentDATA;
        end;
        _idOGLTexture:=0;
        end;
        //.
        Lock.BeginWrite;
        try
        if (TDetailedPictureVisualizationCashItemLevelSegments_Insert(Segments,RestoredSegment, @ExistedSegment))
         then begin
          AccessedSegmentsRevising.Add(RestoredSegment,ptrLevel,idObj); //. process segment as accessed
          ItemsList.Add(RestoredSegment);
          end
         else begin
          ItemsList.Add(ExistedSegment);
          //.
          FreeAndNil(TSegmentItemOfTDetailedPictureVisualizationCash(RestoredSegment^).Params._DATA);
          FreeMem(RestoredSegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
          end;
        finally
        Lock.EndWrite;
        end;
        //.
        if (ptrCancelFlag <> nil)
         then begin
          Sleep(0); //. exit from the current thread to alow the cancel flag to be set
          if (Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
          end;
        end;
      end;
    end;
if (ItemsList.Count > 0)
 then begin
  if ((ExceptSegmentsSize+ItemsList.Count) <> (SizeX*SizeY))
   then begin
    Ofs:=Length(ExceptSegments);
    SetLength(ExceptSegments,Length(ExceptSegments)+(ItemsList.Count*SizeOf(SegmentID)));
    for I:=0 to ItemsList.Count-1 do begin
      SegmentID:=TSegmentItemOfTDetailedPictureVisualizationCash(ItemsList[I]^).Params.ID;
      Integer(Pointer(@ExceptSegments[Ofs+I*SizeOf(SegmentID)])^):=SegmentID;
      end;
    end
   else Result:=true;
  //. update OpenGL segments textures
  if (TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.flEnabled)
   then TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentItemsTextures(ItemsList);
  end;
finally
Lock.EndRead;
end;
end;
end;
except
  if (ItemsList <> nil) then FreeAndNil(ItemsList);
  Raise; //. =>
  end;
end;

function TTDetailedPictureVisualizationCash.Item_Level__GenerateSegmentsLocal(const ptrItem: pointer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const MaxDepth: integer; const ptrCancelFlag: pointer; out ItemsList: TList; var ExceptSegments: TByteArray): boolean;

  function ExceptSegments_SegmentFound(ExceptSegmentsPtr: pointer; ExceptSegmentsSize: integer; SegmentID: integer): boolean;
  begin
  asm
        PUSH EAX
        PUSH ECX
        PUSH EDI
        MOV EAX,SegmentID
        MOV EDI,ExceptSegmentsPtr
        CMP EDI,0 {nil}
        JE @M1
        MOV ECX,ExceptSegmentsSize
        JECXZ @M1
        CLD
        REPNE SCASD
        JNE @M1
          MOV Result,true
          JMP @M2
  @M1:  MOV Result,false
  @M2:  POP EDI
        POP ECX
        POP EAX
  end;
  end;

  function Level_GenerateSegment(const ptrItem: pointer; const ptrLevel: pointer; const X,Y: integer; const Depth,MaxDepth: integer; const ResultBMP,SegmentBMP: TBitmap; out SegmentDATA: TMemoryStream): boolean;

    function ProcessSegment(const ptrItem: pointer; const ptrLevel: pointer; const X,Y: integer; const Depth,MaxDepth: integer; const ResultBMP,SegmentBMP: TBitmap; out SegmentDATA: TMemoryStream): boolean;
    var
      Segment: pointer;
      flSegmentFound: boolean;
      LevelFolder,SegmentFileName: string;
      NewSegment: pointer;
    begin
    Result:=false;
    //.
    SegmentDATA:=nil;
    try
    with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
    Lock.BeginRead;
    try
    LevelFolder:=Item_Level__GetContextFolder(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj,Params.ID);
    flSegmentFound:=false;
    Segment:=Segments;
    while (Segment <> nil) AND (TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.YIndex <> Y) do Segment:=TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).ptrNext;
    while (Segment <> nil) AND (TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.YIndex = Y) do begin
      if (TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.XIndex = X)
       then begin
        flSegmentFound:=true;
        Break; //. >
        end;
      //. next
      Segment:=TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).ptrNext;
      end;
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //.
    if (flSegmentFound)
     then begin
      with TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params do begin
      SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
      Segment_Lock(Segment);
      try
      if (_DATA <> nil)
       then begin
        if (_DATA.Size = 0) then Exit; //. ->
        _DATA.Position:=0;
        SegmentDATA:=TMemoryStream.Create;
        SegmentDATA.LoadFromStream(_DATA);
        end
       else begin
        if (NOT FileExists(SegmentFileName)) then Exit; //. ->
        SegmentDATA:=TMemoryStream.Create;
        SegmentDATA.LoadFromFile(SegmentFileName);
        end;
      finally
      Segment_Unlock(Segment);
      end;
      end;
      Result:=true;
      Exit; //. ->
      end;
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //. try to generate segment
    if (Level_GenerateSegment(ptrItem, ptrLevel, X,Y, Depth+1,MaxDepth, ResultBMP,SegmentBMP,  SegmentDATA))
     then begin
      Result:=true;
      GetMem(NewSegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
      with TSegmentItemOfTDetailedPictureVisualizationCash(NewSegment^) do begin
      Lock:=TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).SegmentLock;
      ptrNext:=nil;
      with Params do begin
      id:=SegmentPositionHashCode(X,Y);
      XIndex:=X;
      YIndex:=Y;
      _DATA:=TMemoryStream.Create;
      if (SegmentDATA.Size > 0)
       then begin
        SegmentDATA.Position:=0;
        SegmentDATA.SaveToStream(_DATA);
        end;
      end;
      _idOGLTexture:=0;
      end;
      //.
      TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.BeginWrite;
      try
      if (TDetailedPictureVisualizationCashItemLevelSegments_Insert(Segments,NewSegment))
       then AccessedSegmentsRevising.Add(NewSegment,ptrLevel,TItemTDetailedPictureVisualizationCash(ptrItem^).idObj) //. process segment as accessed
       else begin
        FreeAndNil(TSegmentItemOfTDetailedPictureVisualizationCash(NewSegment^).Params._DATA);
        FreeMem(NewSegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
        NewSegment:=nil;
        end;
      finally
      TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.EndWrite;
      end;
      //.
      if (NewSegment <> nil)
       then with TSegmentItemOfTDetailedPictureVisualizationCash(NewSegment^).Params do begin
        ForceDirectories(LevelFolder);
        Segment_Lock(NewSegment);
        try
        if (_DATA <> nil)
         then begin
          SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(X)+'Y'+IntToStr(Y)+'.jpg';
          if ((_DATA.Size > 0) AND (NOT FileExists(SegmentFileName)))
           then begin
            _DATA.Position:=0;
            _DATA.SaveToFile(SegmentFileName);
            end;
          Segment_SetDATA(NewSegment,nil);
          end;
        finally
        Segment_Unlock(NewSegment);
        end;
        end;
      //.
      if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
      end;
    finally
    Lock.EndRead;
    end;
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    end;
    except
      FreeAndNil(SegmentDATA);
      Raise; //. =>
      end;
    end;

  var
    ptrDownLevel: pointer;
    flAllSegmentsLocal: boolean;
    RSL: TList;
    LocalSegments: TByteArray;
    S00,S10,S01,S11: TMemoryStream;
    OfsX,OfsY: integer;
    SegmentJI: TJpegImage;
  begin
  Result:=false;
  //.
  if (NOT ((MaxDepth = -1) OR (Depth < MaxDepth))) then Exit; //. ->
  SegmentDATA:=nil;
  try
  with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
  if (ptrNext = nil) then Exit; //. =>
  ptrDownLevel:=ptrNext;
  //. check levels validity
  Lock.BeginRead;
  try
  TLevelItemOfTDetailedPictureVisualizationCash(ptrDownLevel^).Lock.BeginRead;
  try
  if ((2*Params.DivX <> TLevelItemOfTDetailedPictureVisualizationCash(ptrDownLevel^).Params.DivX) OR (2*Params.DivY <> TLevelItemOfTDetailedPictureVisualizationCash(ptrDownLevel^).Params.DivY)) then Exit; //. ->
  //.
  flAllSegmentsLocal:=Item_Level__GetSegmentsLocal(ptrDownLevel, 2*X,2*X+1,2*Y,2*Y+1, LocalSegments);
  //. try to restore down level segments from the saved context
  if (NOT flAllSegmentsLocal)
   then begin
    TSystemTDetailedPictureVisualization(TypeSystem).Cash.Item_Level__RestoreSegmentsLocal(ptrItem, ptrDownLevel, 2*X,2*X+1,2*Y,2*Y+1, ptrCancelFlag,  RSL, LocalSegments);
    RSL.Free;
    end;
  //.
  S00:=nil;
  S10:=nil;
  S01:=nil;
  S11:=nil;
  try
  Result:=(
    ProcessSegment(ptrItem, ptrDownLevel, 2*X,   2*Y,   Depth,MaxDepth, ResultBMP,SegmentBMP,  S00)
      AND
    ProcessSegment(ptrItem, ptrDownLevel, 2*X+1, 2*Y,   Depth,MaxDepth, ResultBMP,SegmentBMP,  S10)
      AND
    ProcessSegment(ptrItem, ptrDownLevel, 2*X,   2*Y+1, Depth,MaxDepth, ResultBMP,SegmentBMP,  S01)
      AND
    ProcessSegment(ptrItem, ptrDownLevel, 2*X+1, 2*Y+1, Depth,MaxDepth, ResultBMP,SegmentBMP,  S11)
  );
  //.
  if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
  //.
  if (Result)
   then begin
    Result:=false;
    //.
    ResultBMP.Width:=Round(TLevelItemOfTDetailedPictureVisualizationCash(ptrDownLevel^).Params.SegmentWidth*2);
    ResultBMP.Height:=Round(TLevelItemOfTDetailedPictureVisualizationCash(ptrDownLevel^).Params.SegmentHeight*2);
    //. (0;0)
    if (NOT GetBitmapFromJPEGStream(S00, SegmentBMP)) then Exit; //. ->
    BitBlt(ResultBMP.Canvas.Handle, 0,0, SegmentBMP.Width,SegmentBMP.Height,  SegmentBMP.Canvas.Handle, 0, 0, SRCCOPY);
    OfsX:=SegmentBMP.Width; OfsY:=SegmentBMP.Height;
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //. (1;0)
    if (NOT GetBitmapFromJPEGStream(S10, SegmentBMP)) then Exit; //. ->
    BitBlt(ResultBMP.Canvas.Handle, OfsX,0, SegmentBMP.Width,SegmentBMP.Height,  SegmentBMP.Canvas.Handle, 0, 0, SRCCOPY);
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //. (1;1)
    if (NOT GetBitmapFromJPEGStream(S11, SegmentBMP)) then Exit; //. ->
    BitBlt(ResultBMP.Canvas.Handle, OfsX,OfsY, SegmentBMP.Width,SegmentBMP.Height,  SegmentBMP.Canvas.Handle, 0, 0, SRCCOPY);
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //. (0;1)
    if (NOT GetBitmapFromJPEGStream(S01, SegmentBMP)) then Exit; //. ->
    BitBlt(ResultBMP.Canvas.Handle, 0,OfsY, SegmentBMP.Width,SegmentBMP.Height,  SegmentBMP.Canvas.Handle, 0, 0, SRCCOPY);
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //. save result
    SegmentBMP.Width:=Round(Params.SegmentWidth);
    SegmentBMP.Height:=Round(Params.SegmentHeight);
    //.
    if (NOT Bitmap_DrawToQuarterBitmap(ResultBMP, SegmentBMP)) then Exit; //. ->
    SegmentJI:=TJpegImage.Create;
    try
    SegmentJI.Assign(SegmentBMP);
    //. save segment to stream
    SegmentDATA:=TMemoryStream.Create;
    SegmentJI.SaveToStream(SegmentDATA);         
    finally
    SegmentJI.Destroy;
    end;
    //.
    if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
    //.
    Result:=true;
    end;
  finally
  S00.Free;
  S10.Free;
  S01.Free;
  S11.Free;
  end;
  finally
  TLevelItemOfTDetailedPictureVisualizationCash(ptrDownLevel^).Lock.EndRead;
  end;
  finally
  Lock.EndRead;
  end;
  end;
  except
    FreeAndNil(SegmentDATA);
    Raise; //. =>
    end;
  end;

var
  StartupInput: TGDIPlusStartupInput;
  ResultBMP,SegmentBMP: TBitmap;
  LevelFolder,SegmentFileName: string;
  SizeX,SizeY: integer;
  ExceptSegmentsPtr: pointer;
  ExceptSegmentsSize: integer;
  X,Y: integer;
  SegmentID: integer;
  GeneratedSegmentDATA: TMemoryStream;
  GeneratedSegment: pointer;
  ExistedSegment: pointer;
  ptr: pointer;
  I: integer;
  Ofs: integer;
begin
Result:=false;
//.
ItemsList:=nil;
try
with TItemTDetailedPictureVisualizationCash(ptrItem^) do begin
//.
with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
Lock.BeginRead;
try
if (ptrNext = nil) then Exit; //. =>
//. Initialize GDI+
StartupInput.DebugEventCallback := nil;
StartupInput.SuppressBackgroundThread:=False;
StartupInput.SuppressExternalCodecs:=False;
StartupInput.GdiplusVersion:=1;
GdiplusStartup(gdiplusToken, @StartupInput, nil);
try
ResultBMP:=TBitmap.Create;
ResultBMP.Canvas.Lock;
try
ResultBMP.HandleType:=bmDIB;
ResultBMP.PixelFormat:=pf24bit;
//.
SegmentBMP:=TBitmap.Create;
SegmentBMP.Canvas.Lock;
try
SegmentBMP.HandleType:=bmDIB;
SegmentBMP.PixelFormat:=pf24bit;
//.
LevelFolder:=Item_Level__GetContextFolder(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj,Params.ID);
//.
SizeX:=(XIndexMax-XIndexMin+1);
SizeY:=(YIndexMax-YIndexMin+1);
//.
ExceptSegmentsPtr:=@ExceptSegments[0];
ExceptSegmentsSize:=(Length(ExceptSegments) DIV SizeOf(SegmentID));
//.
ItemsList:=TList.Create;
ItemsList.Capacity:=(SizeX*SizeY-ExceptSegmentsSize);
for Y:=YIndexMin to YIndexMax do
  for X:=XIndexMin to XIndexMax do begin
    SegmentID:=SegmentPositionHashCode(X,Y);
    if (NOT ExceptSegments_SegmentFound(ExceptSegmentsPtr,ExceptSegmentsSize,SegmentID))
     then begin
      if (Level_GenerateSegment(ptrItem, ptrLevel, X,Y, 0,MaxDepth, ResultBMP,SegmentBMP,  GeneratedSegmentDATA))
       then begin
        //. create and insert generated item
        GetMem(GeneratedSegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
        with TSegmentItemOfTDetailedPictureVisualizationCash(GeneratedSegment^) do begin
        ptrNext:=nil;
        Lock:=TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).SegmentLock;
        with Params do begin
        id:=SegmentID;
        XIndex:=X;
        YIndex:=Y;
        _DATA:=GeneratedSegmentDATA;
        end;
        _idOGLTexture:=0;
        end;                     
        //.
        TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.BeginWrite;
        try
        if (TDetailedPictureVisualizationCashItemLevelSegments_Insert(Segments,GeneratedSegment, @ExistedSegment))
         then begin
          AccessedSegmentsRevising.Add(GeneratedSegment,ptrLevel,idObj); //. process segment as accessed
          ItemsList.Add(GeneratedSegment);
          end
         else begin
          ItemsList.Add(ExistedSegment);
          //.
          FreeAndNil(TSegmentItemOfTDetailedPictureVisualizationCash(GeneratedSegment^).Params._DATA);
          FreeMem(GeneratedSegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
          GeneratedSegment:=nil;
          end;
        finally
        TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.EndWrite;
        end;
        //.
        if (GeneratedSegment <> nil)
         then with TSegmentItemOfTDetailedPictureVisualizationCash(GeneratedSegment^).Params do begin
          ForceDirectories(LevelFolder);
          Segment_Lock(GeneratedSegment);
          try
          if ((_DATA <> nil) AND (_DATA.Size > 0))
           then begin
            SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(X)+'Y'+IntToStr(Y)+'.jpg';
            if (NOT FileExists(SegmentFileName))
             then begin
              _DATA.Position:=0;
              _DATA.SaveToFile(SegmentFileName);
              end;
            end;
          finally
          Segment_Unlock(GeneratedSegment);
          end;
          end;
        //.
        if (ptrCancelFlag <> nil)
         then begin
          Sleep(0); //. exit from the current thread to alow the cancel flag to be set
          if (Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
          end;
        end;
      end;
    end;
if (ItemsList.Count > 0)
 then begin
  if ((ExceptSegmentsSize+ItemsList.Count) <> (SizeX*SizeY))
   then begin
    Ofs:=Length(ExceptSegments);
    SetLength(ExceptSegments,Length(ExceptSegments)+(ItemsList.Count*SizeOf(SegmentID)));
    for I:=0 to ItemsList.Count-1 do begin
      SegmentID:=TSegmentItemOfTDetailedPictureVisualizationCash(ItemsList[I]^).Params.ID;
      Integer(Pointer(@ExceptSegments[Ofs+I*SizeOf(SegmentID)])^):=SegmentID;
      end;
    end
   else Result:=true;
  //. update OpenGL segments textures
  if (TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.flEnabled)
   then TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentItemsTextures(ItemsList);
  end;
finally
SegmentBMP.Canvas.Unlock;
SegmentBMP.Destroy;
end;
finally
ResultBMP.Canvas.Unlock;
ResultBMP.Destroy;
end;
finally
GdiplusShutdown(gdiplusToken);
end;
finally
Lock.EndRead;
end;
end;
end;
except
  if (ItemsList <> nil) then FreeAndNil(ItemsList);
  Raise; //. =>
  end;
end;

function TTDetailedPictureVisualizationCash.Item_Level__DegenerateSegmentsLocal(const ptrItem: pointer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ptrCancelFlag: pointer; out ItemsList: TList): boolean;

  function Item_ProcessLevel(const ptrItem: pointer; const DistLevel: pointer; const UpLevels: TList; const UpLevel: integer; XIndexMin,XIndexMax: integer; YIndexMin,YIndexMax: integer; out ItemsList: TList): boolean;

    function DrawCanvasScaledUsingGDIPlus(const DistCanvas: TCanvas; const DistX,DistY,DistWidth,DistHeight: Single; const BMP: TBitmap; const SrcX,SrcY,SrcWidth,SrcHeight: Single): GDIPAPI.TStatus;
    var
      Rect: TGPRectF;
      GDIPlusGraphics: TGPGraphics;
      GDIPlusBitmap: TGPBitmap;
    begin
    with Rect do begin
    X:=DistX;
    Y:=DistY;
    Width:=DistWidth;
    Height:=DistHeight;
    end;
    GDIPlusGraphics:=TGPGraphics.Create(DistCanvas.Handle);
    try
    GDIPlusGraphics.SetInterpolationMode(InterpolationModeBilinear);
    GDIPlusBitmap:=TGPBitmap.Create(BMP.Handle,BMP.Palette);
    try
    Result:=GDIPlusGraphics.DrawImage(GDIPlusBitmap, Rect, SrcX,SrcY,SrcWidth,SrcHeight, UnitPixel);
    finally
    GDIPlusBitmap.Destroy;
    end;
    finally
    GDIPlusGraphics.Destroy;
    end;
    end;

  var
    DistLevelFolder: string;
    SrcLevel: pointer;
    SrcLevelFolder: string;
    EmptySegments: TList;
    Segment: pointer;
    SegmentFileName: string;
    flAllItemsExists: boolean;
    ItemsTable: pointer;
    ItemsTableSize: integer;
    IL,RSL: TList;
    ExceptSegments: TByteArray;
    BA: TByteArray;
    L: TList;
    I,J: integer;
    SX,SY: integer;
    mulX,mulY: integer;
    DegenerateSegmentBMP: TBitmap;
    DegeneratedSegmentBMP: TBitmap;
    DegeneratedSegmentJI: TJpegImage;
    flDegenerateSegmentProcessed: boolean;
    DS: TMemoryStream;
  begin
  Result:=false;
  //.
  if (UpLevel < 0) then Exit; //. ->
  //.
  SrcLevel:=UpLevels[UpLevel];
  if (NOT ((2*TLevelItemOfTDetailedPictureVisualizationCash(SrcLevel^).Params.DivX = TLevelItemOfTDetailedPictureVisualizationCash(DistLevel^).Params.DivX) AND (2*TLevelItemOfTDetailedPictureVisualizationCash(SrcLevel^).Params.DivY = TLevelItemOfTDetailedPictureVisualizationCash(DistLevel^).Params.DivY))) then Exit; //. ->
  SrcLevelFolder:=Item_Level__GetContextFolder(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj,TLevelItemOfTDetailedPictureVisualizationCash(SrcLevel^).Params.ID);
  //.
  ItemsList:=nil;
  try
  DegenerateSegmentBMP:=TBitmap.Create;
  DegenerateSegmentBMP.Canvas.Lock;
  try
  DegenerateSegmentBMP.HandleType:=bmDIB;
  DegenerateSegmentBMP.PixelFormat:=pf24bit;
  with TLevelItemOfTDetailedPictureVisualizationCash(DistLevel^) do begin
  DegeneratedSegmentBMP:=TBitmap.Create;
  DegeneratedSegmentBMP.Canvas.Lock;
  try
  DegeneratedSegmentBMP.HandleType:=bmDIB;
  DegeneratedSegmentBMP.PixelFormat:=pf24bit;
  DegeneratedSegmentBMP.Width:=Round(Params.SegmentWidth);
  DegeneratedSegmentBMP.Height:=Round(Params.SegmentHeight);
  //.
  Lock.BeginRead;
  try
  DistLevelFolder:=Item_Level__GetContextFolder(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj,Params.ID);
  //.
  EmptySegments:=TList.Create;
  try
  EmptySegments.Capacity:=(XIndexMax-XIndexMin+1)*(YIndexMax-YIndexMin+1);
  Segment:=Segments;
  while (Segment <> nil) AND (TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.YIndex < YIndexMin) do Segment:=TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).ptrNext;
  while (Segment <> nil) AND (TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.YIndex <= YIndexMax) do begin
    if ((XIndexMin <= TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.XIndex) AND (TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params.XIndex <= XIndexMax))
     then with TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).Params do begin
      Segment_Lock(Segment);
      try
      if (_DATA = nil)
       then begin
        SegmentFileName:=DistLevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
        _DATA:=TMemoryStream.Create();
        if (FileExists(SegmentFileName)) then _DATA.LoadFromFile(SegmentFileName);
        end;
      //.
      if (_DATA.Size = 0) then EmptySegments.Add(Segment);
      finally
      Segment_Unlock(Segment);
      end;
      //.
      if ((ptrCancelFlag <> nil) AND (Boolean(ptrCancelFlag^))) then Raise EUnnecessaryExecuting.Create(''); //. =>
      end;
    Segment:=TSegmentItemOfTDetailedPictureVisualizationCash(Segment^).ptrNext;
    end;
  //. processing empty segments
  if (EmptySegments.Count > 0)
   then begin
    XIndexMin:=(XIndexMin SHR 1); XIndexMax:=(XIndexMax SHR 1);
    YIndexMin:=(YIndexMin SHR 1); YIndexMax:=(YIndexMax SHR 1);
    //.
    IL:=TList.Create;
    try
    IL.Capacity:=(XIndexMax-XIndexMin+1)*(YIndexMax-YIndexMin+1);
    //.
    TLevelItemOfTDetailedPictureVisualizationCash(SrcLevel^).Lock.BeginRead;
    try
    flAllItemsExists:=Item_Level__GetVisibleSegmentsLocal(ptrItem, SrcLevel, XIndexMin,XIndexMax,YIndexMin,YIndexMax, false,true, ptrCancelFlag,  ItemsTable,ItemsTableSize, ExceptSegments);
    try
    if (NOT flAllItemsExists)
     then begin
      //. try to restore segments from saved context
      flAllItemsExists:=TSystemTDetailedPictureVisualization(TypeSystem).Cash.Item_Level__RestoreSegmentsLocal(ptrItem, SrcLevel, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ptrCancelFlag,  RSL, ExceptSegments);
      if (RSL <> nil)
       then
        try
        for I:=0 to RSL.Count-1 do IL.Add(RSL[I]);
        finally
        RSL.Destroy;
        end;
      //. get segments from server
      if (NOT flAllItemsExists AND NOT Space.flOffline)
       then begin
        with TDetailedPictureVisualizationFunctionality(TComponentFunctionality_Create(idTDetailedPictureVisualization,TItemTDetailedPictureVisualizationCash(ptrItem^).idObj)) do
        try
        Level_GetSegments(TLevelItemOfTDetailedPictureVisualizationCash(SrcLevel^).Params.id, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ExceptSegments, BA);
        //.
        TDetailedPictureVisualizationCashItemLevel_PrepareSegmentsFromByteArray(TSystemTDetailedPictureVisualization(TypeSystem), TItemTDetailedPictureVisualizationCash(ptrItem^).idObj, SrcLevel,BA, IL, true);
        finally
        Release;
        end;
        end;
      end;
    //.
    if (ItemsTable <> nil) then for I:=0 to (ItemsTableSize DIV SizeOf(Pointer))-1 do IL.Add(Pointer(Pointer(Integer(ItemsTable)+I*SizeOf(Pointer))^));
    //.
    finally
    if (ItemsTable <> nil) then FreeMem(ItemsTable,ItemsTableSize);
    end;
    //.
    if (Item_ProcessLevel(ptrItem, SrcLevel, UpLevels,UpLevel-1, XIndexMin,XIndexMax,YIndexMin,YIndexMax, L)) then L.Destroy();
    //.
    ForceDirectories(DistLevelFolder);
    for I:=0 to EmptySegments.Count-1 do with TSegmentItemOfTDetailedPictureVisualizationCash(EmptySegments[I]^).Params do begin
      SX:=(XIndex SHR 1); SY:=(YIndex SHR 1);
      flDegenerateSegmentProcessed:=false;
      for J:=0 to IL.Count-1 do with TSegmentItemOfTDetailedPictureVisualizationCash(IL[J]^).Params do
        if ((XIndex = SX) AND (YIndex = SY))
         then begin
          Segment_Lock(IL[J]);
          try
          if (_DATA = nil)
           then begin
            SegmentFileName:=SrcLevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
            _DATA:=TMemoryStream.Create();
            if (FileExists(SegmentFileName)) then _DATA.LoadFromFile(SegmentFileName);
            end;
          //.
          if (_DATA.Size > 0) then flDegenerateSegmentProcessed:=GetBitmapFromJPEGStream(_DATA, DegenerateSegmentBMP);
          finally
          Segment_Unlock(IL[J]);
          end;
          //.
          Break; //. >
          end;
      if (flDegenerateSegmentProcessed)
       then begin
        //. degenerating
        mulX:=(XIndex MOD 2); mulY:=(YIndex MOD 2);
        //.
        DrawCanvasScaledUsingGDIPlus(DegeneratedSegmentBMP.Canvas, 0,0,DegeneratedSegmentBMP.Width+1,DegeneratedSegmentBMP.Height+1, DegenerateSegmentBMP, (mulX*(DegenerateSegmentBMP.Width/2)),(mulY*(DegenerateSegmentBMP.Height/2)),(DegenerateSegmentBMP.Width/2),(DegenerateSegmentBMP.Height/2));
        //.
        DegeneratedSegmentJI:=TJpegImage.Create;
        try
        DegeneratedSegmentJI.Assign(DegeneratedSegmentBMP);
        //. saving new DATA
        DS:=TMemoryStream.Create;
        DegeneratedSegmentJI.SaveToStream(DS);
        if (TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.flEnabled AND (Segment_idOGLTexture(EmptySegments[I]) <> 0)) then TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.DeleteSegmentTexture(EmptySegments[I]);
        Segment_SetDATA(EmptySegments[I],DS);
        finally
        DegeneratedSegmentJI.Destroy;
        end;
        //.
        Segment_Lock(EmptySegments[I]);
        try
        if ((_DATA <> nil) AND (_DATA.Size > 0))
         then begin
          SegmentFileName:=DistLevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
          if (NOT FileExists(SegmentFileName))
           then begin
            _DATA.Position:=0;
            _DATA.SaveToFile(SegmentFileName);
            end;
          end;
        finally
        Segment_Unlock(EmptySegments[I]);
        end;
        //.
        if (ItemsList = nil)
         then begin
          ItemsList:=TList.Create;
          ItemsList.Capacity:=EmptySegments.Count;
          end;
        ItemsList.Add(EmptySegments[I]);
        //.
        Result:=true;
        end
       else begin //. exceptional case - no segment to degenerate
        if (TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.flEnabled AND (Segment_idOGLTexture(EmptySegments[I]) <> 0)) then TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.DeleteSegmentTexture(EmptySegments[I]);
        //.
        TSystemTDetailedPictureVisualization(TypeSystem).EmptySegmentImageDATA.Position:=0;
        DS:=TMemoryStream.Create;
        DS.LoadFromStream(TSystemTDetailedPictureVisualization(TypeSystem).EmptySegmentImageDATA);
        Segment_SetDATA(EmptySegments[I],DS);
        //.
        if (ItemsList = nil)
         then begin
          ItemsList:=TList.Create;
          ItemsList.Capacity:=EmptySegments.Count;
          end;
        ItemsList.Add(EmptySegments[I]);
        //.
        Result:=true;
        end;
      //.
      if (ptrCancelFlag <> nil)
       then begin
        Sleep(0); //. exit from the current thread to alow the cancel flag to be set
        if (Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
        end;
      end;
    finally
    TLevelItemOfTDetailedPictureVisualizationCash(SrcLevel^).Lock.EndRead;
    end;
    finally
    IL.Destroy;
    end;
    end;
  finally
  EmptySegments.Destroy;
  end;
  finally
  Lock.EndRead;
  end;
  finally
  DegeneratedSegmentBMP.Canvas.Unlock;
  DegeneratedSegmentBMP.Destroy;
  end;
  end;
  finally
  DegenerateSegmentBMP.Canvas.Unlock;
  DegenerateSegmentBMP.Destroy;
  end;
  except
    if (ItemsList <> nil) then FreeAndNil(ItemsList);
    Raise; //. =>
    end;
  end;

var
  StartupInput: TGDIPlusStartupInput;
  UpLevels: TList;
  LevelPtr: pointer;
begin 
Result:=false;
ItemsList:=nil;
try
//. Initialize GDI+
StartupInput.DebugEventCallback := nil;
StartupInput.SuppressBackgroundThread:=False;
StartupInput.SuppressExternalCodecs:=False;
StartupInput.GdiplusVersion:=1;
GdiplusStartup(gdiplusToken, @StartupInput, nil);
try
with TItemTDetailedPictureVisualizationCash(ptrItem^) do begin
UpLevels:=TList.Create;
try
UpLevels.Capacity:=16;
//.
LevelPtr:=Levels;
while (LevelPtr <> nil) do begin
  if (LevelPtr = ptrLevel)
   then Break //. >
   else begin
    UpLevels.Add(LevelPtr);
    LevelPtr:=TLevelItemOfTDetailedPictureVisualizationCash(LevelPtr^).ptrNext;
    end;
  end;
//. process target level
TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.BeginRead;
try
Result:=Item_ProcessLevel(ptrItem, ptrLevel,UpLevels,UpLevels.Count-1, XIndexMin,XIndexMax,YIndexMin,YIndexMax,  ItemsList);
//. update OpenGL segments textures
if ((ItemsList <> nil) AND (ItemsList.Count > 0))
 then 
  if (TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.flEnabled)
   then TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentItemsTextures(ItemsList);
finally
TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.EndRead;
end;
finally
UpLevels.Destroy;
end;
end;
finally
GdiplusShutdown(gdiplusToken);
end;
except
  if (ItemsList <> nil) then FreeAndNil(ItemsList);
  Raise; //. =>
  end;
end;

function TTDetailedPictureVisualizationCash.Item_Level__UpdateSegmentsLocal(const ptrItem: pointer; const ptrLevel: pointer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ExceptSegments: TByteArray; const ptrCancelFlag: pointer): boolean;
const
  NullSegmentHashCode     = -1;
  ExceptedSegmentHashCode = 0;

  function Item_RectangleIsInContext(const ptrItem: pointer; const ptrLevel: pointer; const UpLevels: TList; const UpLevelIndex: integer; XIndexMin,XIndexMax: integer; YIndexMin,YIndexMax: integer): boolean;

    function LevelRectangleIsInContext(const ptrLevel: pointer): boolean;
    var
      ptrSegment: pointer;
      X,Y: integer;
      LevelFolder,SegmentFileName: string;
    begin
    Result:=true;
    with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
    Lock.BeginRead;
    try
    //. check in-range segments in memory
    ptrSegment:=Segments;
    while (ptrSegment <> nil) do with TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^).Params do begin
      if (((XIndexMin <= XIndex) AND (XIndex <= XIndexMax)) AND ((YIndexMin <= YIndex) AND (YIndex <= YIndexMax)))
       then Exit; //. ->
      //. next segment
      ptrSegment:=ptrNext;
      end;
    //. check in-range segments in file context
    LevelFolder:=Item_Level__GetContextFolder(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj,Params.ID);
    for Y:=YIndexMin to YIndexMax do
      for X:=XIndexMin to XIndexMax do begin
        SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(X)+'Y'+IntToStr(Y)+'.jpg';
        if (FileExists(SegmentFileName)) then Exit; //. ->
        end;
    finally
    Lock.EndRead;
    end;
    end;
    Result:=false;
    end;

  var
    L: integer;
  begin
  Result:=true;
  if (LevelRectangleIsInContext(ptrLevel)) then Exit; //. ->
  for L:=UpLevelIndex downto 0 do begin
    XIndexMin:=(XIndexMin SHR 1); XIndexMax:=(XIndexMax SHR 1);
    YIndexMin:=(YIndexMin SHR 1); YIndexMax:=(YIndexMax SHR 1);
    if (LevelRectangleIsInContext(UpLevels[L])) then Exit; //. ->
    end;
  Result:=false;
  end;

  function Item_ProcessLevel(const ptrItem: pointer; const ptrLevel: pointer; const UpLevels: TList; const UpLevelIndex: integer; const XIndexMin,XIndexMax: integer; const YIndexMin,YIndexMax: integer; const ExceptSegments: TByteArray): boolean;

    procedure UpdateSegmentsFromByteArray(const ptrLevel: pointer; const BA: TByteArray);

      function GetSegment(var Segments: pointer; const XI,YI: integer; out ptrSegment: pointer): boolean;
      var
        ptrptrSegment: pointer;
      begin
      ptrSegment:=nil;
      //.
      ptrptrSegment:=@Segments;
      while (Pointer(ptrptrSegment^) <> nil) AND (YI > TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).Params.YIndex) do begin
        ptrptrSegment:=@TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).ptrNext;
        end;
      while (Pointer(ptrptrSegment^) <> nil) AND ((YI = TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).Params.YIndex) AND (XI > TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).Params.XIndex)) do begin
        ptrptrSegment:=@TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).ptrNext;
        end;
      if ((Pointer(ptrptrSegment^) <> nil) AND ((YI = TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).Params.YIndex) AND (XI = TSegmentItemOfTDetailedPictureVisualizationCash(Pointer(ptrptrSegment^)^).Params.XIndex)))
       then begin
        ptrSegment:=Pointer(ptrptrSegment^);
        Result:=true;
        end
       else Result:=false;
      end;

      procedure UpdateSegmentsOnUpLevels(const XIndex,YIndex: integer; const SegmentData: TMemoryStream);
      var
        SrcBMP,DestBMP,B: TBitmap;
        DestLevelFolder: string;
        X,Y: integer;
        OfsX,OfsY: integer;
        UpLevel: integer;
        ptrUpLevel: pointer;
        ptrDestSegment: pointer;
        ExceptSegments: TByteArray;
        RSL: TList;
        SegmentFileName: string;
        SegmentJI: TJpegImage;
        SegmentNewDATA: TMemoryStream;
      begin
      SrcBMP:=TBitmap.Create;
      SrcBMP.Canvas.Lock;
      DestBMP:=TBitmap.Create;
      DestBMP.Canvas.Lock;
      try
      SrcBMP.HandleType:=bmDIB;
      SrcBMP.PixelFormat:=pf24bit;
      DestBMP.HandleType:=bmDIB;
      DestBMP.PixelFormat:=pf24bit;
      //.
      SegmentData.Position:=0;
      if (NOT GetBitmapFromJPEGStream(SegmentData,SrcBMP)) then Raise Exception.Create('TTDetailedPictureVisualizationCash.Item_Level__UpdateSegmentsLocal: GetBitmapFromJPEGStream fails'); //. =>
      //.
      X:=XIndex;
      Y:=YIndex;
      OfsX:=0;
      OfsY:=0;
      for UpLevel:=UplevelIndex downto 0 do begin
        ptrUpLevel:=UpLevels[UpLevel];
        with TLevelItemOfTDetailedPictureVisualizationCash(ptrUpLevel^) do begin
        DestLevelFolder:=Item_Level__GetContextFolder(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj,Params.ID);
        Lock.BeginRead;
        try
        if ((X AND 1) = 1) then Inc(OfsX,Trunc(Params.SegmentWidth));
        if ((Y AND 1) = 1) then Inc(OfsY,Trunc(Params.SegmentHeight));
        OfsX:=(OfsX SHR 1);
        OfsY:=(OfsY SHR 1);
        X:=(X SHR 1);
        Y:=(Y SHR 1);
        DestBMP.Width:=(SrcBMP.Width SHR 1);
        DestBMP.Height:=(SrcBMP.Height SHR 1);
        //.
        if (NOT Bitmap_DrawToQuarterBitmap(SrcBMP,DestBMP)) then Raise Exception.Create('TTDetailedPictureVisualizationCash.Item_Level__UpdateSegmentsLocal: Bitmap_DrawToQuarterBitmap fails'); //. =>
        //.
        ptrDestSegment:=nil;
        if (NOT GetSegment(TLevelItemOfTDetailedPictureVisualizationCash(ptrUpLevel^).Segments, X,Y, {out} ptrDestSegment))
         then begin
          SetLength(ExceptSegments,0);
          if (TSystemTDetailedPictureVisualization(TypeSystem).Cash.Item_Level__RestoreSegmentsLocal(ptrItem, ptrUpLevel, X,X,Y,Y, nil,  RSL, ExceptSegments))
           then ptrDestSegment:=RSL[0];
          RSL.Free;
          end;
        if (ptrDestSegment <> nil)
         then begin
          //. delete segment texture for updating segment (it will be generated later on reflecting)
          if (TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.flEnabled) then TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.DeleteSegmentTexture(ptrDestSegment);
          //.
          Segment_Lock(ptrDestSegment);
          with TSegmentItemOfTDetailedPictureVisualizationCash(ptrDestSegment^) do
          try
          SegmentFileName:=DestLevelFolder+'\'+'X'+IntToStr(Params.XIndex)+'Y'+IntToStr(Params.YIndex)+'.jpg';
          if (Params._DATA = nil)
           then begin
            Params._DATA:=TMemoryStream.Create();
            if (FileExists(SegmentFileName)) then Params._DATA.LoadFromFile(SegmentFileName);
            end;
          //.
          if (Params._DATA.Size > 0)
           then begin
            if (NOT GetBitmapFromJPEGStream(Params._DATA,SrcBMP)) then Raise Exception.Create('TTDetailedPictureVisualizationCash.Item_Level__UpdateSegmentsLocal: GetBitmapFromJPEGStream fails'); //. =>
            SrcBMP.Canvas.Draw(OfsX,OfsY,DestBMP);
            //.
            SegmentNewDATA:=TMemoryStream.Create;
            try
            SegmentJI:=TJpegImage.Create;
            try
            SegmentJI.Assign(SrcBMP);
            //. save segment to stream
            SegmentJI.SaveToStream(SegmentNewDATA);
            finally
            SegmentJI.Destroy;
            end;
            except
              FreeAndNil(SegmentNewDATA);
              Raise; //. =>
              end;
            //. assign new data to segment
            Segment_SetDATA(ptrDestSegment,SegmentNewDATA);
            //. save new data to context file
            SegmentNewDATA.SaveToFile(SegmentFileName);
            end;
          finally
          Segment_Unlock(ptrDestSegment);
          end;
          end;
        //.
        B:=SrcBMP; SrcBMP:=DestBMP; DestBMP:=B;
        finally
        Lock.EndRead;
        end;
        end;
        end;
      finally
      DestBMP.Destroy;
      SrcBMP.Destroy;
      end;
      end;

    var
      ItemsList: TList;
      P,Pend,SDP: pointer;
      LevelFolder: string;
      _id: integer;
      _XIndex,_YIndex: integer;
      ptrSegment: pointer;
      DATASize: integer;
      ptrExistedSegment: pointer;
      SegmentFileName: string;
      DS: TMemoryStream;
    begin
    with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
    Lock.BeginRead;
    try
    P:=@BA[0];
    Pend:=Pointer(Integer(P)+Length(BA));
    if (P <> Pend)
     then begin
      ItemsList:=TList.Create;
      try
      LevelFolder:=Item_Level__GetContextFolder(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj,Params.ID);
      ForceDirectories(LevelFolder);
      repeat
        //. get segment params
        _id:=Integer(P^); Inc(DWord(P),SizeOf(_id));
        _XIndex:=Integer(P^); Inc(DWord(P),SizeOf(_XIndex));
        _YIndex:=Integer(P^); Inc(DWord(P),SizeOf(_YIndex));
        //.
        SDP:=P;
        if (GetSegment(TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Segments, _XIndex,_YIndex, ptrSegment))
         then begin
          //. assign new data
          DATASize:=Integer(P^); Inc(DWord(P),SizeOf(DATASize));
          DS:=TMemoryStream.Create;
          if (DATASize > 0)
           then begin
            DS.Size:=DATASize;
            DS.Write(P^,DATASize);
            Inc(DWord(P),DATASize);
            end;
          //.
          if (TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.flEnabled AND (Segment_idOGLTexture(ptrSegment) <> 0)) then TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.DeleteSegmentTexture(ptrSegment);
          Segment_SetDATA(ptrSegment,DS);
          end
         else begin
          GetMem(ptrSegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
          with TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^) do begin
          ptrNext:=nil;
          Lock:=TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).SegmentLock;
          with Params do begin
          id:=_id;
          XIndex:=_XIndex;
          YIndex:=_YIndex;
          DATASize:=Integer(P^); Inc(DWord(P),SizeOf(DATASize));
          _DATA:=TMemoryStream.Create;
          if (DATASize > 0)
           then begin
            _DATA.Size:=DATASize;
            _DATA.Write(P^,DATASize);
            Inc(DWord(P),DATASize);
            end;
          end;
          _idOGLTexture:=0;
          end;
          TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.BeginWrite;
          try
          if (TDetailedPictureVisualizationCashItemLevelSegments_Insert(TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Segments,ptrSegment,@ptrExistedSegment))
           then AccessedSegmentsRevising.Add(ptrSegment,ptrLevel,TItemTDetailedPictureVisualizationCash(ptrItem^).idObj) //. process segment as accessed
           else begin
            Segment_SetDATA(ptrExistedSegment,TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^).Params._DATA);
            FreeMem(ptrSegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
            ptrSegment:=ptrExistedSegment;
            end;
          finally
          TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.EndWrite;
          end;
          end;
        //.
        if (ptrSegment <> nil)
         then begin
          //. save new segment into the local file
          Segment_Lock(ptrSegment);
          try
          with TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^).Params do
          if ((_DATA <> nil) AND (_DATA.Size > 0))
           then begin
            SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(XIndex)+'Y'+IntToStr(YIndex)+'.jpg';
            _DATA.Position:=0;
            _DATA.SaveToFile(SegmentFileName);
            end;
          finally
          Segment_Unlock(ptrSegment);
          end;
          //.
          ItemsList.Add(ptrSegment);
          //. update segments on up levels
          DATASize:=Integer(SDP^); Inc(DWord(SDP),SizeOf(DATASize));
          DS:=TMemoryStream.Create;
          try
          if (DATASize > 0)
           then begin
            DS.Size:=DATASize;
            DS.Write(SDP^,DATASize);
            end;
          UpdateSegmentsOnUpLevels(_XIndex,_YIndex,DS);
          finally
          DS.Destroy;
          end;
          end;
      until (P = Pend);
      //. generate textures for the updated segments
      if (TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.flEnabled) then TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentItemsTextures(ItemsList);
      finally
      ItemsList.Destroy;
      end;
      end;
    finally
    Lock.EndRead;
    end;
    end;
    end;

    function ExceptSegments_SegmentFound(ExceptSegmentsPtr: pointer; ExceptSegmentsSize: integer; SegmentID: integer): boolean;
    begin
    asm
          PUSH EAX
          PUSH ECX
          PUSH EDI
          MOV EAX,SegmentID
          MOV EDI,ExceptSegmentsPtr
          MOV ECX,ExceptSegmentsSize
          JECXZ @M1
          CLD
          REPNE SCASD
          JNE @M1
            MOV Result,true
            JMP @M2
    @M1:  MOV Result,false
    @M2:  POP EDI
          POP ECX
          POP EAX
    end;
    end;

    function IsSegmentRequiresUpdate(const LevelFolder: string; const X,Y: integer; const NewSegmentHashCode: integer): boolean;
    var
      SegmentFileName: string;
      FA: integer;
    begin
    Result:=false;
    //.
    SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(X)+'Y'+IntToStr(Y)+'.jpg';
    FA:=FileAge(SegmentFileName);
    if (FA = -1) then Exit; //. ->
    Result:=(FA < NewSegmentHashCode);
    end;

  var
    LevelFolder: string;
    SizeX,SizeY: integer;
    SegmentsSize: integer;
    SegmentsTable: pointer;
    SegmentsHashes: TByteArray;
    SegmentHashItemPtr: pointer;
    ExceptSegmentsCount: integer;
    ExceptSegmentsPtr: pointer;
    SegmentID: integer;
    SegmentHashCode: integer;
    X,Y: integer;
    SegmentsToUpdateCount: integer;
    NullSegmentsCount: integer;
    I: integer;
    NewExceptSegments: TByteArray;
    UpLevel_SizeX,UpLevel_SizeY: integer;
    UpLevel_SegmentsSize: integer;
    UpLevel_SegmentsTable: pointer;
    UpLevel_NullSegmentsCount: integer;
    UpLevel_X,UpLevel_Y: integer;
    NewSegments: TByteArray;
    UpLevel_XIndexMin,UpLevel_YIndexMin,UpLevel_XIndexMax,UpLevel_YIndexMax: integer;
  begin
  Result:=false;
  with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
  Lock.BeginRead;
  try
  //. get segments hash codes
  with TDetailedPictureVisualizationFunctionality(TComponentFunctionality_Create(idTDetailedPictureVisualization,TItemTDetailedPictureVisualizationCash(ptrItem^).idObj)) do
  try
  Level_GetSegmentsHashes(Params.ID, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ExceptSegments, SegmentsHashes);
  //.
  if (ptrCancelFlag <> nil)
   then begin
    Sleep(0); //. exit from the current thread to alow the cancel flag to be set
    if (Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
    end;
  //.
  LevelFolder:=Item_Level__GetContextFolder(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj,Params.ID);
  SizeX:=(XIndexMax-XIndexMin+1); SizeY:=(YIndexMax-YIndexMin+1);
  //.
  SegmentsSize:=(SizeX*SizeY)*SizeOf(SegmentHashCode);
  GetMem(SegmentsTable,SegmentsSize);
  try
  SegmentsToUpdateCount:=0;
  NullSegmentsCount:=0;
  SegmentHashItemPtr:=@SegmentsHashes[0];
  ExceptSegmentsPtr:=@ExceptSegments[0];
  ExceptSegmentsCount:=(Length(ExceptSegments) DIV SizeOf(SegmentID));
  for Y:=YIndexMin to YIndexMax do
    for X:=XIndexMin to XIndexMax do begin
      SegmentID:=SegmentPositionHashCode(X,Y);
      if (NOT ExceptSegments_SegmentFound(ExceptSegmentsPtr,ExceptSegmentsCount,SegmentID))
       then begin
        SegmentHashCode:=Integer(SegmentHashItemPtr^);
        Inc(DWord(SegmentHashItemPtr),SizeOf(SegmentHashCode));
        //.
        if (SegmentHashCode <> NullSegmentHashCode)
         then begin //. check segment for update
          if (IsSegmentRequiresUpdate(LevelFolder, X,Y, SegmentHashCode))
           then Inc(SegmentsToUpdateCount)
           else SegmentHashCode:=ExceptedSegmentHashCode;
          end
         else Inc(NullSegmentsCount);
        end
       else SegmentHashCode:=ExceptedSegmentHashCode;
      //.
      Integer(Pointer(Integer(SegmentsTable)+((Y-YIndexMin)*SizeX+(X-XIndexMin))*SizeOf(SegmentHashCode))^):=SegmentHashCode;
      end;
  //.
  if (SegmentsToUpdateCount > 0)
   then begin
    SetLength(NewExceptSegments,((SizeX*SizeY)-SegmentsToUpdateCount)*SizeOf(SegmentID));
    ExceptSegmentsPtr:=@NewExceptSegments[0];
    for Y:=YIndexMin to YIndexMax do
      for X:=XIndexMin to XIndexMax do begin
        SegmentHashCode:=Integer(Pointer(Integer(SegmentsTable)+((Y-YIndexMin)*SizeX+(X-XIndexMin))*SizeOf(SegmentHashCode))^);
        if ((SegmentHashCode = ExceptedSegmentHashCode) OR (SegmentHashCode = NullSegmentHashCode))
         then begin
          Integer(ExceptSegmentsPtr^):=SegmentPositionHashCode(X,Y);
          Inc(DWord(ExceptSegmentsPtr),SizeOf(SegmentID));
          end;
        end;
    //. get the update segments from the server
    Level_GetSegments(Params.ID, XIndexMin,XIndexMax,YIndexMin,YIndexMax, NewExceptSegments, NewSegments);
    //. update segments from byte array
    UpdateSegmentsFromByteArray(ptrLevel,NewSegments);
    //.
    Result:=true;
    end;
  if ((NullSegmentsCount > 0) AND (UpLevelIndex >= 0))
   then begin
    UpLevel_XIndexMin:=XIndexMin SHR 1; UpLevel_YIndexMin:=YIndexMin SHR 1;
    UpLevel_XIndexMax:=XIndexMax SHR 1; UpLevel_YIndexMax:=YIndexMax SHR 1;
    UpLevel_SizeX:=(UpLevel_XIndexMax-UpLevel_XIndexMin+1);
    UpLevel_SizeY:=(UpLevel_YIndexMax-UpLevel_YIndexMin+1);
    UpLevel_SegmentsSize:=(UpLevel_SizeX*UpLevel_SizeY)*SizeOf(SegmentHashCode);
    GetMem(UpLevel_SegmentsTable,UpLevel_SegmentsSize);
    try
    //.
    for I:=0 to (UpLevel_SizeX*UpLevel_SizeY)-1 do Integer(Pointer(Integer(UpLevel_SegmentsTable)+I*SizeOf(SegmentHashCode))^):=ExceptedSegmentHashCode;
    //.
    UpLevel_NullSegmentsCount:=0;
    for Y:=YIndexMin to YIndexMax do
      for X:=XIndexMin to XIndexMax do begin
        SegmentHashCode:=Integer(Pointer(Integer(SegmentsTable)+((Y-YIndexMin)*SizeX+(X-XIndexMin))*SizeOf(SegmentHashCode))^);
        if (SegmentHashCode = NullSegmentHashCode)
         then begin //. prepare for up level
          UpLevel_X:=X SHR 1; UpLevel_Y:=Y SHR 1;
          if (Integer(Pointer(Integer(UpLevel_SegmentsTable)+((UpLevel_Y-UpLevel_YIndexMin)*UpLevel_SizeX+(UpLevel_X-UpLevel_XIndexMin))*SizeOf(SegmentHashCode))^) <> NullSegmentHashCode)
           then begin
            Integer(Pointer(Integer(UpLevel_SegmentsTable)+((UpLevel_Y-UpLevel_YIndexMin)*UpLevel_SizeX+(UpLevel_X-UpLevel_XIndexMin))*SizeOf(SegmentHashCode))^):=NullSegmentHashCode;
            Inc(UpLevel_NullSegmentsCount);
            end;
          end;
        end;
    //. correspond processing to the up level if the level null segments exist
    SetLength(NewExceptSegments,((UpLevel_SizeX*UpLevel_SizeY)-UpLevel_NullSegmentsCount)*SizeOf(SegmentID));
    ExceptSegmentsPtr:=@NewExceptSegments[0];
    for UpLevel_Y:=UpLevel_YIndexMin to UpLevel_YIndexMax do
      for UpLevel_X:=UpLevel_XIndexMin to UpLevel_XIndexMax do begin
        SegmentHashCode:=Integer(Pointer(Integer(UpLevel_SegmentsTable)+((UpLevel_Y-UpLevel_YIndexMin)*UpLevel_SizeX+(UpLevel_X-UpLevel_XIndexMin))*SizeOf(SegmentHashCode))^);
        if (SegmentHashCode = ExceptedSegmentHashCode)
         then begin
          Integer(ExceptSegmentsPtr^):=SegmentPositionHashCode(UpLevel_X,UpLevel_Y);
          Inc(DWord(ExceptSegmentsPtr),SizeOf(SegmentID));
          end;
        end;
    //. process up level for empty segments
    Result:=(Result OR Item_ProcessLevel(ptrItem, UpLevels[UpLevelIndex], UpLevels,UpLevelIndex-1, UpLevel_XIndexMin,UpLevel_XIndexMax,UpLevel_YIndexMin,UpLevel_YIndexMax, NewExceptSegments));
    finally
    FreeMem(UpLevel_SegmentsTable,UpLevel_SegmentsSize);
    end;
    end;
  finally
  FreeMem(SegmentsTable,SegmentsSize);
  end;
  finally
  Release;
  end;
  finally
  Lock.EndRead;
  end;
  end;
  end;

var
  UpLevels: TList;
  LevelPtr: pointer;
begin
with TItemTDetailedPictureVisualizationCash(ptrItem^) do begin
UpLevels:=TList.Create;
try
UpLevels.Capacity:=16;
//.
LevelPtr:=Levels;
while (LevelPtr <> nil) do begin
  if (LevelPtr = ptrLevel)
   then Break //. >
   else begin
    UpLevels.Add(LevelPtr);
    LevelPtr:=TLevelItemOfTDetailedPictureVisualizationCash(LevelPtr^).ptrNext;
    end;
  end;
//. process target level if segments context exists
if (Item_RectangleIsInContext(ptrItem, ptrLevel, UpLevels,UpLevels.Count-1, XIndexMin,XIndexMax,YIndexMin,YIndexMax))
 then Result:=Item_ProcessLevel(ptrItem, ptrLevel, UpLevels,UpLevels.Count-1, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ExceptSegments)
 else Result:=false;
finally
UpLevels.Destroy;
end;
end;
end;

procedure TTDetailedPictureVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetSegmentDATA(const ImageStream: TMemoryStream): OLEVariant;
  var
    MS: TMemoryStream;
    DATAPtr: pointer;
  begin
  MS:=TMemoryStream.Create;
  with MS do
  try
  if (ImageStream <> nil)
   then begin
    ImageStream.SaveToStream(MS);
    Position:=0;
    end;
  Result:=VarArrayCreate([0,Size-1],varByte);
  DATAPtr:=VarArrayLock(Result);
  try
  Read(DATAPtr^,Size);
  finally
  VarArrayUnLock(Result);
  end;
  finally
  Destroy;
  end;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
  //.
  LevelsNode: IXMLDOMElement;
  ptrLevel: pointer;
  LevelNode: IXMLDOMElement;
  LevelFolder: string;
  SegmentsNode: IXMLDOMElement;
  ptrSegment: pointer;
  SegmentFileName: string;
  SegmentNode: IXMLDOMElement;
begin
Lock.BeginRead;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTDetailedPictureVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('Width');        PropNode.nodeTypedValue:=Width;    ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Height');       PropNode.nodeTypedValue:=Height;   ItemNode.appendChild(PropNode);
  //. process levels
  LevelsNode:=Document.CreateElement('Levels');
  ptrLevel:=Levels;
  while (ptrLevel <> nil) do with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
    Lock.BeginRead;
    try
    LevelNode:=Document.CreateElement('Level'+IntToStr(LevelIndex));
    PropNode:=Document.CreateElement('id');                 PropNode.nodeTypedValue:=Params.id;              LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('Disabled');           PropNode.nodeTypedValue:=Disabled;               LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('Persist');            PropNode.nodeTypedValue:=flPersist;              LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('DivX');               PropNode.nodeTypedValue:=Params.DivX;            LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('DivY');               PropNode.nodeTypedValue:=Params.DivY;            LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('SegmentWidth');       PropNode.nodeTypedValue:=Params.SegmentWidth;    LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('SegmentHeight');      PropNode.nodeTypedValue:=Params.SegmentHeight;   LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('VisibleMinScale');    PropNode.nodeTypedValue:=Params.VisibleMinScale; LevelNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('VisibleMaxScale');    PropNode.nodeTypedValue:=Params.VisibleMaxScale; LevelNode.appendChild(PropNode);
    //. process segments
    SegmentsNode:=Document.CreateElement('Segments');
    if (Segments <> nil)
     then begin
      LevelFolder:=Item_Level__GetContextFolder(idObj,Params.ID);
      ForceDirectories(LevelFolder);
      end;
    //.
    ptrSegment:=Segments;
    while (ptrSegment <> nil) do with TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^) do begin
      Segment_Lock(ptrSegment);
      try
      if ((Params._DATA <> nil) AND (Params._DATA.Size > 0))
       then begin
        SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(Params.XIndex)+'Y'+IntToStr(Params.YIndex)+'.jpg';
        if (NOT FileExists(SegmentFileName))
         then begin
          Params._DATA.Position:=0;
          Params._DATA.SaveToFile(SegmentFileName);
          end;
        end;
      finally
      Segment_Unlock(ptrSegment);
      end;
      //. next segment
      ptrSegment:=ptrNext;
      end;
    //.
    ptrSegment:=Segments;
    while (ptrSegment <> nil) do with TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^) do begin
      SegmentNode:=Document.CreateElement('Segment'+IntToStr(Params.id));
      PropNode:=Document.CreateElement('id');     PropNode.nodeTypedValue:=Params.id;     SegmentNode.appendChild(PropNode);
      PropNode:=Document.CreateElement('XIndex'); PropNode.nodeTypedValue:=Params.XIndex; SegmentNode.appendChild(PropNode);
      PropNode:=Document.CreateElement('YIndex'); PropNode.nodeTypedValue:=Params.YIndex; SegmentNode.appendChild(PropNode);
      //. full save
      {PropNode:=Document.CreateElement('DATA');
      PropNode.Set_dataType('bin.base64');
      PropNode.nodeTypedValue:=GetSegmentDATA(Params.DATA);
      SegmentNode.appendChild(PropNode);}
      //.
      SegmentsNode.appendChild(SegmentNode);
      //. next segment
      ptrSegment:=ptrNext;
      end;
    LevelNode.appendChild(SegmentsNode);
    //.
    LevelsNode.appendChild(LevelNode);
    finally
    Lock.EndRead;
    end;
    //. next level
    ptrLevel:=ptrNext;
    end;
  ItemNode.appendChild(LevelsNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
Lock.EndRead;
end;
end;

procedure TTDetailedPictureVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetSegmentDATA(DATA: Variant; out ImageStream: TMemoryStream);
  var
    DATASize: integer;
    DATAPtr: pointer;
    MS: TMemoryStream;
  begin
  ImageStream:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    MS:=TMemoryStream.Create;
    with MS do
    try
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    ImageStream:=TMemoryStream.Create;
    ImageStream.LoadFromStream(MS);
    finally
    Destroy;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(ImageStream);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _Width: integer;
  _Height: integer;
  LevelsNode: IXMLDOMNode;
  J: integer;
  LevelNode: IXMLDOMNode;
  ptrLastLevel: pointer;
  ptrNewLevel: pointer;
  LevelFolder: string;
  SegmentsNode: IXMLDOMNode;
  K: integer;
  SegmentNode: IXMLDOMNode;
  ptrLastSegment: pointer;
  ptrNewSegment: pointer;
  SegmentFileName: string;
begin
Lock.BeginWrite;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _Width:=ItemNode.selectSingleNode('Width').nodeTypedValue;
  _Height:=ItemNode.selectSingleNode('Height').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTDetailedPictureVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTDetailedPictureVisualizationCash), 0);
  with TItemTDetailedPictureVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  ptrObj:=nilPtr;
  //.
  Width:=_Width;
  Height:=_Height;
  Levels:=nil;
  //. process levels
  ptrLastLevel:=@Levels;
  LevelsNode:=ItemNode.selectSingleNode('Levels');
  for J:=0 to LevelsNode.childNodes.length-1 do begin
    LevelNode:=LevelsNode.childNodes[J];
    //. process level
    GetMem(ptrNewLevel,SizeOf(TLevelItemOfTDetailedPictureVisualizationCash));
    with TLevelItemOfTDetailedPictureVisualizationCash(ptrNewLevel^) do begin
    ptrNext:=nil;
    ptrItem:=ptrNewItem;
    LevelIndex:=J;
    //.
    Lock:=TMultiReadExclusiveWriteSynchronizer.Create;
    SegmentLock:=TCriticalSection.Create;
    Disabled:=LevelNode.selectSingleNode('Disabled').nodeTypedValue;
    {///? if (LevelNode.selectSingleNode('Persist') <> nil)
     then flPersist:=LevelNode.selectSingleNode('Persist').nodeTypedValue
     else flPersist:=false;}
    flPersist:=false;
    Params.ID:=LevelNode.selectSingleNode('id').nodeTypedValue;
    Params.DivX:=LevelNode.selectSingleNode('DivX').nodeTypedValue;
    Params.DivY:=LevelNode.selectSingleNode('DivY').nodeTypedValue;
    Params.SegmentWidth:=LevelNode.selectSingleNode('SegmentWidth').nodeTypedValue;
    Params.SegmentHeight:=LevelNode.selectSingleNode('SegmentHeight').nodeTypedValue;
    Params.VisibleMinScale:=LevelNode.selectSingleNode('VisibleMinScale').nodeTypedValue;
    Params.VisibleMaxScale:=LevelNode.selectSingleNode('VisibleMaxScale').nodeTypedValue;
    LevelFolder:=Item_Level__GetContextFolder(idObj,Params.ID);
    //. process segments
    Segments:=nil;
    ptrLastSegment:=@Segments;
    SegmentsNode:=LevelNode.selectSingleNode('Segments');
    for K:=0 to SegmentsNode.childNodes.length-1 do begin
      SegmentNode:=SegmentsNode.childNodes[K];
      GetMem(ptrNewSegment,SizeOf(TSegmentItemOfTDetailedPictureVisualizationCash));
      with TSegmentItemOfTDetailedPictureVisualizationCash(ptrNewSegment^) do begin
      ptrNext:=nil;
      Lock:=TLevelItemOfTDetailedPictureVisualizationCash(ptrNewLevel^).SegmentLock;
      Params.id:=SegmentNode.selectSingleNode('id').nodeTypedValue;
      Params.XIndex:=SegmentNode.selectSingleNode('XIndex').nodeTypedValue;
      Params.YIndex:=SegmentNode.selectSingleNode('YIndex').nodeTypedValue;
      Params._DATA:=nil;
      _idOGLTexture:=0;
      //. load segment data if Level.flPersist = true 
      {if (flPersist)
       then begin
        SegmentFileName:=LevelFolder+'\'+'X'+IntToStr(Params.XIndex)+'Y'+IntToStr(Params.YIndex)+'.jpg';
        Params._DATA:=TMemoryStream.Create();
        if (FileExists(SegmentFileName)) then Params._DATA.LoadFromFile(SegmentFileName);
        end;}
      //. full loading
      {SetSegmentDATA(SegmentNode.selectSingleNode('DATA').nodeTypedValue, Params.DATA);
      if (SegmentsOGLTextures.flEnabled) then TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentTexture(ptrNewSegment);}
      end;
      Pointer(ptrLastSegment^):=ptrNewSegment;
      ptrLastSegment:=ptrNewSegment;
      end;
    end;
    Pointer(ptrLastLevel^):=ptrNewLevel;
    ptrLastLevel:=ptrNewLevel;
    end;
  end;
  FItems:=ptrNewItem;
  end;
finally
Lock.EndWrite;
end;
end;

procedure TTDetailedPictureVisualizationCash.Context_DestroyItemSegmentFiles(const pidObj: integer);

  procedure DeleteFolder(const Folder: string);
  var
    sr: TSearchRec;
    FN: string;
  begin
  if (FindFirst(Folder+'\*.*', faAnyFile-faDirectory, sr) = 0)
   then
    try
    repeat
      if (NOT ((sr.Name = '.') OR (sr.Name = '..')))
       then begin
        FN:=Folder+'\'+sr.name;
        DeleteFile(FN);
        end;
    until FindNext(sr) <> 0;
    finally
    FindClose(sr);
    end;
  if (FindFirst(Folder+'\*.*', faDirectory, sr) = 0)
   then
    try
    repeat
      if (NOT ((sr.Name = '.') OR (sr.Name = '..')) AND ((sr.Attr and faDirectory) = faDirectory)) then DeleteFolder(Folder+'\'+sr.name);
    until FindNext(sr) <> 0;
    finally
    FindClose(sr);
    end;
  RemoveDir(Folder);
  end;

var
  ptrItem: pointer;
  ObjFolder: string;
begin
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTDetailedPictureVisualizationCash(ptrItem^) do begin
  if (idObj = pidObj)
   then begin
    ObjFolder:=Item_GetContextFolder(TItemTDetailedPictureVisualizationCash(ptrItem^).idObj);
    DeleteFolder(ObjFolder);
    Exit; //. ->
    end;
  //.
  ptrItem:=ptrNext;
  end;
end;

function TTDetailedPictureVisualizationCash.SegmentPositionHashCode(X,Y: integer): integer;
begin
asm
      PUSH EAX
      PUSH EDX
      MOV EAX,Y
      SHL EAX,16
      MOV EDX,X
      OR AX,DX
      MOV Result,EAX
      POP EDX
      POP EAX
end;
end;

procedure TTDetailedPictureVisualizationCash.Segment_Lock(const ptrSegment: pointer);
begin
TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^).Lock.Enter;
end;

procedure TTDetailedPictureVisualizationCash.Segment_UnLock(const ptrSegment: pointer);
begin
TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^).Lock.Leave;
end;

function TTDetailedPictureVisualizationCash.Segment_SetidOGLTexture(const ptrSegment: pointer; const Value: cardinal): cardinal;
begin
with TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^) do begin
Lock.Enter;
try
Result:=_idOGLTexture;
_idOGLTexture:=Value;
finally
Lock.Leave;
end;
end;
end;

function TTDetailedPictureVisualizationCash.Segment_idOGLTexture(const ptrSegment: pointer): cardinal;
begin
with TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^) do begin
Lock.Enter;
try
Result:=_idOGLTexture;
finally
Lock.Leave;
end;
end;
end;

procedure TTDetailedPictureVisualizationCash.Segment_SetDATA(const ptrSegment: pointer; const pDATA: TMemoryStream);
begin
with TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^) do begin
Lock.Enter;
try
Params._DATA.Free();
Params._DATA:=pDATA;
finally
Lock.Leave;
end;
end;
end;

function TTDetailedPictureVisualizationCash.Segment_DATAIsNull(const ptrSegment: pointer): boolean;
begin
with TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^) do begin
Lock.Enter;
try
Result:=(Params._DATA = nil);
finally
Lock.Leave;
end;
end;
end;

function TTDetailedPictureVisualizationCash.Segment_DATAIsEmpty(const ptrSegment: pointer): boolean;
{
  ! to use in TTDetailedPictureVisualizationCash.Item_Level__GetVisibleSegmentsLocal() especially for TDetailedPictureVisualizationFunctionality.Reflect()
}
begin
with TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^) do begin
Lock.Enter;
try
Result:=((Params._DATA <> nil) AND (Params._DATA.Size = 0));
finally
Lock.Leave;
end;
end;
end;

function TTDetailedPictureVisualizationCash.Segment_DATAIsNotEmpty(const ptrSegment: pointer): boolean;
{
  ! to use in TDetailedPictureVisualizationFunctionality.Reflect().Composition_ProcessSegment()
}
begin
with TSegmentItemOfTDetailedPictureVisualizationCash(ptrSegment^) do begin
Lock.Enter;
try
Result:=((Params._DATA <> nil) AND (Params._DATA.Size > 0));
finally
Lock.Leave;
end;
end;
end;


{TDetailedPictureDeferredReflecting}
Constructor TDetailedPictureDeferredReflecting.Create(const pTypeSystem: TSystemTDetailedPictureVisualization; const pflLiveUpdateOnly: boolean; const pReflector: TReflector; const pidObj: integer; const pptrObj: TPtr; const pidLevel: integer; const pXIndexMin,pXIndexMax,pYIndexMin,pYIndexMax: integer; const pExceptSegments: TByteArray; const pptrCancelFlag: pointer);
begin
TypeSystem:=pTypeSystem;
flFinished:=false;
flLiveUpdateOnly:=pflLiveUpdateOnly;
ReflectorsList:=TThreadList.Create;
if (pReflector <> nil) then ReflectorsList.Add(pReflector);
idObj:=pidObj;
ptrObj:=pptrObj;
idLevel:=pidLevel;
XIndexMin:=pXIndexMin; XIndexMax:=pXIndexMax;
YIndexMin:=pYIndexMin; YIndexMax:=pYIndexMax;
ExceptSegments:=pExceptSegments;
ptrCancelFlag:=pptrCancelFlag;
FreeOnTerminate:=true;
flUpdateIsNeeded:=false;
TypeSystem.DetailedPictureDeferredReflectingList.Add(Self);
Inherited Create(true);
Priority:=tpLowest;
end;

procedure TDetailedPictureDeferredReflecting.Execute;
{
  if you change this update TDetailedPictureVisualizationFunctionality.ReflectOnCanvas.SupplyLevelWithSegments() as well
}

  function ChangeSegmentsGettingForBestReflecting(const XIndexMin,XIndexMax,YIndexMin,YIndexMax: integer; var ExceptSegments: TByteArray): boolean;
  label
    SearchEnd;
  const
    SegmentsPortionForHighSpeed = 4;
    SegmentsPortionForLowSpeed = 1;
  var
    SegmentsPortion: integer;
    Count: integer;
    ExceptCount: integer;
    _CountToExcept: integer;
    ExceptSegmentsPtr: pointer;
    ExceptSegmentsSize: integer;
    _XIndexMin,_XIndexMax,_YIndexMin,_YIndexMax: integer;
    X,Y: integer;

    function ProcessSegmentPosition(const X,Y: integer): boolean;

      function ExceptSegments_SegmentFound(ExceptSegmentsPtr: pointer; ExceptSegmentsSize: integer; SegmentID: integer): boolean;
      begin
      asm
            PUSH EAX
            PUSH ECX
            PUSH EDI
            MOV EAX,SegmentID
            MOV EDI,ExceptSegmentsPtr
            MOV ECX,ExceptSegmentsSize
            JECXZ @M1
            CLD
            REPNE SCASD
            JNE @M1
              MOV Result,true
              JMP @M2
      @M1:  MOV Result,false
      @M2:  POP EDI
            POP ECX
            POP EAX
      end;
      end;

    var
      ID: integer;
    begin
    Result:=false;  
    ID:=TypeSystem.Cash.SegmentPositionHashCode(X,Y);
    if (NOT ExceptSegments_SegmentFound(ExceptSegmentsPtr,ExceptSegmentsSize,ID))
     then begin
      Integer(Pointer(DWord(ExceptSegmentsPtr)+ExceptCount*SizeOf(Integer))^):=ID;
      Inc(ExceptCount);
      //.
      Dec(_CountToExcept);
      Result:=(_CountToExcept = 0);
      end;
    end;

  begin
  Result:=false;
  //. change ExceptSegments for segments portion
  if (TypeSystem.Cash.PersistLevelsProviding.flServerConnectionIsFast)
   then SegmentsPortion:=SegmentsPortionForHighSpeed
   else SegmentsPortion:=SegmentsPortionForLowSpeed;
  Count:=(XIndexMax-XIndexMin+1)*(YIndexMax-YIndexMin+1);
  if (Count > SegmentsPortion)
   then begin
    ExceptCount:=Length(ExceptSegments) DIV SizeOf(Integer);
    _CountToExcept:=Count-ExceptCount-SegmentsPortion;
    if (_CountToExcept > 0)
     then begin
      SetLength(ExceptSegments,(ExceptCount+_CountToExcept)*SizeOf(Integer));
      ExceptSegmentsSize:=ExceptCount;
      ExceptSegmentsPtr:=Pointer(@ExceptSegments[0]);
      _XIndexMin:=XIndexMin; _XIndexMax:=XIndexMax;
      _YIndexMin:=YIndexMin; _YIndexMax:=YIndexMax;
      X:=_XIndexMax;
      Y:=_YIndexMax;
      repeat
        if (_YIndexMin = _YIndexMax)
         then begin
          for X:=_XIndexMax downto _XIndexMin do if (ProcessSegmentPosition(X,_YIndexMin)) then GoTo SearchEnd; //. >>
          Break; //. ->
          end;
        if (_XIndexMin = _XIndexMax)
         then begin
          for Y:=_YIndexMax downto _YIndexMin do if (ProcessSegmentPosition(_XIndexMin,Y)) then GoTo SearchEnd; //. >>
          Break; //. ->
          end;
        while (X > _XIndexMin) do begin
          if (ProcessSegmentPosition(X,Y)) then GoTo SearchEnd; //. >>
          Dec(X);
          end;
        while (Y > _YIndexMin) do begin
          if (ProcessSegmentPosition(X,Y)) then GoTo SearchEnd; //. >>
          Dec(Y);
          end;
        while (X < _XIndexMax) do begin
          if (ProcessSegmentPosition(X,Y)) then GoTo SearchEnd; //. >>
          Inc(X);
          end;
        while (Y < _YIndexMax) do begin
          if (ProcessSegmentPosition(X,Y)) then GoTo SearchEnd; //. >>
          Inc(Y);
          end;
        Dec(X);
        Dec(Y);
        Inc(_XIndexMin); Dec(_XIndexMax);
        Inc(_YIndexMin); Dec(_YIndexMax);
      until ((_CountToExcept = 0) OR (_XIndexMin > _XIndexMax) OR (_YIndexMin > _YIndexMax));
      SearchEnd: 
      if (_CountToExcept <> 0) then Raise Exception.Create('duplicate hash code has been found'); //. =>
      Result:=true;
      end;
    end;
  end;

const
  SegmentsGeneration_MaxDepth = 2;
var
  ptrItem: pointer;
  ptrLevel: pointer;
  SegmentID: integer;
  flAllItemsExists: boolean;
  flDegenerate: boolean;
  BA: TByteArray;
  IL,ReceivedSegmentsList: TList;
  _ReflectorsList: TList;
  I: integer;
begin
try
if (Terminated) then Exit; //. ->
try
TSystemTDetailedPictureVisualization(TypeSystem).Cash.Lock.BeginRead;
try
try
try
try
if (NOT TSystemTDetailedPictureVisualization(TypeSystem).Cash.GetItem(Self.idObj, ptrItem)) then Exit; //. ->
//. processing ...
ptrLevel:=TItemTDetailedPictureVisualizationCash(ptrItem^).Levels;
while (ptrLevel <> nil) do with TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^) do begin
  Lock.BeginRead;
  try
  if (Params.id = idLevel) then Break; //. >
  finally
  Lock.EndRead;
  end;
  //. next level
  ptrLevel:=ptrNext;
  end;
if (ptrLevel = nil) then Exit; //. ->
//. to avoid often calls
for I:=1 to 2 do begin
  Sleep(100);
  if ((ptrCancelFlag <> nil) AND Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
  end;
//. try to restore segments from saved context
try
flAllItemsExists:=TSystemTDetailedPictureVisualization(TypeSystem).Cash.Item_Level__RestoreSegmentsLocal(ptrItem, ptrLevel, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ptrCancelFlag,  IL, ExceptSegments);
except
  On E: EUnnecessaryExecuting do Raise; //. =>
  On E: Exception do begin
    EventLog.WriteMinorEvent('DetailedPictureDeferredReflecting.Execute','Error of RestoreSegmentsLocal() of DetailedPicture visualization (ID: '+IntToStr(idObj)+')',E.Message);
    Raise; //. =>
    end;
  end;
if (IL <> nil)
 then
  try
  flUpdateIsNeeded:=flUpdateIsNeeded OR (IL.Count > 0);
  finally
  IL.Destroy;
  end;
//.
if (NOT flAllItemsExists)
 then begin
  //. try to generate segments from down levels
  try
  flAllItemsExists:=TSystemTDetailedPictureVisualization(TypeSystem).Cash.Item_Level__GenerateSegmentsLocal(ptrItem, ptrLevel, XIndexMin,XIndexMax,YIndexMin,YIndexMax, SegmentsGeneration_MaxDepth, ptrCancelFlag,  IL, ExceptSegments);
  except
    On E: EUnnecessaryExecuting do Raise; //. =>
    On E: Exception do begin
      EventLog.WriteMinorEvent('DetailedPictureDeferredReflecting.Execute','Error of GenerateSegmentsLocal() of DetailedPicture visualization (ID: '+IntToStr(idObj)+')',E.Message);
      Raise; //. =>
      end;
    end;
  if (IL <> nil)
   then
    try
    flUpdateIsNeeded:=flUpdateIsNeeded OR (IL.Count > 0);
    finally
    IL.Destroy;
    end;
  //. segments getting from remote server
  if (NOT flAllItemsExists AND NOT TypeSystem.Space.flOffline)
   then begin
    //.
    if (ptrCancelFlag <> nil)
     then begin
      Sleep(0); //. exit from the current thread to alow the cancel flag to be set
      if (Boolean(ptrCancelFlag^)) then Raise EUnnecessaryExecuting.Create(''); //. =>
      end;
    //.
    flDegenerate:=true;
    //.
    try
    flDegenerate:=(NOT ChangeSegmentsGettingForBestReflecting(XIndexMin,XIndexMax,YIndexMin,YIndexMax,{ref} ExceptSegments));
    except
      On E: Exception do begin
        EventLog.WriteMajorEvent('DetailedPictureDeferredReflecting.Execute','Error of ChangeSegmentsGettingForBestReflecting()',E.Message);
        Raise; //. =>
        end;
      end;
    //.
    with TDetailedPictureVisualizationFunctionality(TComponentFunctionality_Create(idTDetailedPictureVisualization,TItemTDetailedPictureVisualizationCash(ptrItem^).idObj)) do
    try
    try
    Level_GetSegments(idLevel, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ExceptSegments, BA);
    except
      On E: EUnnecessaryExecuting do Raise; //. =>
      On E: Exception do begin
        EventLog.WriteMinorEvent('DetailedPictureDeferredReflecting.Execute','Error of Level_GetSegments(idLevel = '+IntToStr(idLevel)+') of DetailedPicture visualization (ID: '+IntToStr(idObj)+')',E.Message);
        Raise; //. =>
        end;
      end;
    finally
    Release;
    end; 
    //.
    ReceivedSegmentsList:=TList.Create;
    try
    TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.BeginRead;
    try
    try
    TDetailedPictureVisualizationCashItemLevel_PrepareSegmentsFromByteArray(TypeSystem, Self.idObj, ptrLevel,BA, ReceivedSegmentsList);
    except
      On E: EUnnecessaryExecuting do Raise; //. =>
      On E: Exception do begin
        EventLog.WriteMinorEvent('DetailedPictureDeferredReflecting.Execute','Error of PrepareSegmentsFromByteArray(idLevel = '+IntToStr(idLevel)+') of DetailedPicture visualization (ID: '+IntToStr(idObj)+')',E.Message);
        Raise; //. =>
        end;
      end;
    if (ReceivedSegmentsList.Count > 0)
     then begin
      //. update OpenGL segments textures
      try
      if (TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.flEnabled)
       then TSystemTDetailedPictureVisualization(TypeSystem).SegmentsOGLTextures.GenerateSegmentItemsTextures(ReceivedSegmentsList);
      except
        On E: EUnnecessaryExecuting do Raise; //. =>
        On E: Exception do begin
          EventLog.WriteMinorEvent('DetailedPictureDeferredReflecting.Execute','Error of GenerateSegmentItemsTextures() of DetailedPicture visualization (ID: '+IntToStr(idObj)+')',E.Message);
          Raise; //. =>
          end;
        end;
      flUpdateIsNeeded:=true;
      end;
    finally
    TLevelItemOfTDetailedPictureVisualizationCash(ptrLevel^).Lock.EndRead;
    end;
    finally
    ReceivedSegmentsList.Destroy;
    end;
    //. empty segments degeneration
    if (flDegenerate)
     then
      try
      if (TSystemTDetailedPictureVisualization(TypeSystem).Cash.Item_Level__DegenerateSegmentsLocal(ptrItem, ptrLevel, XIndexMin,XIndexMax,YIndexMin,YIndexMax, ptrCancelFlag,  IL))
       then
        try
        flUpdateIsNeeded:=flUpdateIsNeeded OR (IL.Count > 0);
        finally
        IL.Destroy;
        end;
      except
        On E: EUnnecessaryExecuting do Raise; //. =>
        On E: Exception do begin
          EventLog.WriteMinorEvent('DetailedPictureDeferredReflecting.Execute','Error of DegenerateSegmentsLocal(idLevel = '+IntToStr(idLevel)+') of DetailedPicture visualization (ID: '+IntToStr(idObj)+')',E.Message);
          Raise; //. =>
          end;
        end;
    end;
  end;
finally
TypeSystem.DetailedPictureDeferredReflectingList.Remove(Self);
end;
except
  On E: EUnnecessaryExecuting do
    flUpdateIsNeeded:=true;
  else
    Raise; //. =>
  end;
//. update reflectors
try
if (flUpdateIsNeeded)
 then begin
  _ReflectorsList:=ReflectorsList.LockList;
  try
  for I:=0 to _ReflectorsList.Count-1 do TReflector(_ReflectorsList[I]).Reflecting.RevisionReflect(ptrObj,actRefresh);
  finally
  ReflectorsList.UnlockList;
  end;
  end;
except
  On E: EUnnecessaryExecuting do Raise; //. =>
  On E: Exception do begin
    EventLog.WriteMinorEvent('DetailedPictureDeferredReflecting.Execute','Error of RevisionReflect() of DetailedPicture visualization (ID: '+IntToStr(idObj)+')',E.Message);
    Raise; //. =>
    end;
  end;
finally
FreeAndNil(ReflectorsList);
end;
finally
TSystemTDetailedPictureVisualization(TypeSystem).Cash.Lock.EndRead;
end;
except
  On E: EUnnecessaryExecuting do Raise; //. =>
  On E: Exception do EventLog.WriteMinorEvent('DetailedPictureDeferredReflecting.Execute','Error of processing DetailedPicture visualization (ID: '+IntToStr(idObj)+')',E.Message);
  end;
finally
flFinished:=true;
//. provide visualization with persist level for smart reflecting 
TSystemTDetailedPictureVisualization(TypeSystem).Cash.PersistLevelsProviding.Provide();
end;
end;

function TDetailedPictureDeferredReflecting.ReflectorsList_Add(const Reflector: TReflector): boolean;
var
  _ReflectorsList: TList;
begin
if (Reflector = nil) then Exit; //. -> 
_ReflectorsList:=ReflectorsList.LockList;
try
if (_ReflectorsList.IndexOf(Reflector) = -1) then _ReflectorsList.Add(Reflector);
Result:=true;
finally
ReflectorsList.UnlockList;
end;
end;










//. CoVisualization-визуализация
{TSystemTCoVisualization}
Constructor TSystemTCoVisualization.Create;
begin
CreateNew(idTCoVisualization,tnTCoVisualization,TTCoVisualizationFunctionality);
if Enabled then Cash:=TTCoVisualizationCash.Create(Self);
Figure:=TFigureWinRefl.Create;
AdditionalFigure:=TFigureWinRefl.Create;
end;

Destructor TSystemTCoVisualization.Destroy;
begin
AdditionalFigure.Free;
Figure.Free;
Cash.Free;
Inherited;
end;

procedure TSystemTCoVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTCoVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited; 
end;

procedure TSystemTCoVisualization.Caching_Start;
begin
end;

procedure TSystemTCoVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTCoVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTCoVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTCoVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTCoVisualizationCash
Constructor TTCoVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTCoVisualizationCash.Destroy;
begin
Empty();
Inherited;
end;

procedure TTCoVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTCoVisualizationCash(ptrDelItem^).ptrNext;
  TItemTCoVisualizationCash(ptrDelItem^)._Space.Free();
  FreeSpaceComponentsUpdaters(ptrDelItem);
  FreeMem(ptrDelItem,SizeOf(TItemTCoVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCoVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TCoVisualizationFunctionality;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTCoVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTCoVisualizationCash), 0);
    with TItemTCoVisualizationCash(ptrNewItem^) do begin
    _Space:=nil;
    _SpaceComponentsUpdaters:=nil;
    idDATAFile:=0;
    CF:=TCoVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    idDATAFile:=CF.DATAFileID;
    if (idDATAFile <> 0)
     then begin
      if (NOT GetComponentFile(idDATAFile, _Space)) then CF.GetSpace(_Space,Space.Configuration.VisualizationMaxSize);
      CreateSpaceComponentsUpdaters(ptrNewItem);
      end
     else begin
      _Space:=nil;
      _SpaceComponentsUpdaters:=nil;
      end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTCoVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTCoVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTCoVisualizationCash), 0);
    with TItemTCoVisualizationCash(ptrNewItem^) do begin
    _Space:=nil;
    _SpaceComponentsUpdaters:=nil;
    idDATAFile:=0;
    CF:=TCoVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try idDATAFile:=CF.DATAFileID; except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTCoVisualizationCash(ItemsList[I]^) do with TCoVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    idDATAFile:=DATAFileID;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  ActionsGroups.ActionsGroup_Start(ptrActionsGroup);
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then with TItemTCoVisualizationCash(ItemsList[I]^) do with TCoVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if (idDATAFile <> 0)
     then begin if (NOT GetComponentFile(idDATAFile, _Space)) then try GetSpace(_Space,Space.Configuration.VisualizationMaxSize); except on E: EActionsGroup do ; else Raise; end; end
     else begin
      _Space:=nil;
      _SpaceComponentsUpdaters:=nil;
      end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item Space of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    finally
    Release;
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do if (ItemsList[I] <> nil) then with TItemTCoVisualizationCash(ItemsList[I]^) do with TCoVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if (idDATAFile <> 0)
     then begin
      if (_Space = nil) then GetSpace(_Space,Space.Configuration.VisualizationMaxSize);
      CreateSpaceComponentsUpdaters(ItemsList[I]);
      end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item Space of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTCoVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;


procedure TTCoVisualizationCash.Update;
begin
Empty;
end;

function TTCoVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTCoVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTCoVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTCoVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTCoVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCoVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTCoVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTCoVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TCoVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
  begin
  with TItemTCoVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TCoVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  _idDATAFile:=CF.DATAFileID;
  if (idDATAFile <> _idDATAFile)
   then begin
    //. free last
    FreeAndNil(_Space);
    FreeSpaceComponentsUpdaters(ptrItem);
    //.
    if (_idDATAFile <> 0)
     then begin
      if (NOT GetComponentFile(_idDATAFile, _Space)) then CF.GetSpace(_Space,Space.Configuration.VisualizationMaxSize);
      CreateSpaceComponentsUpdaters(ptrItem);
      end;
    idDATAFile:=_idDATAFile;
    end;
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTCoVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTCoVisualizationCash), 0);
  with TItemTCoVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  idDATAFile:=0;
  _Space:=nil;
  _SpaceComponentsUpdaters:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTCoVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTCoVisualizationCash), 0);
    with TItemTCoVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    idDATAFile:=0;
    _Space:=nil;
    _SpaceComponentsUpdaters:=nil;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTCoVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TCoVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
  begin
  with TItemTCoVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TCoVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  _idDATAFile:=CF.DATAFileID;
  if (idDATAFile <> _idDATAFile)
   then begin
    //. free last
    FreeAndNil(_Space);
    FreeSpaceComponentsUpdaters(ptrItem);
    //.
    if (_idDATAFile <> 0)
     then begin
      if (NOT GetComponentFile(_idDATAFile, _Space)) then CF.GetSpace(_Space,Space.Configuration.VisualizationMaxSize);
      CreateSpaceComponentsUpdaters(ptrItem);
      end;
    idDATAFile:=_idDATAFile;
    end;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure CopyToItem(const ptrItem: pointer; var Item: TItemTCoVisualizationCash);
  begin
  Item:=TItemTCoVisualizationCash(ptrItem^);
  //. copy item reference fields
  if (TItemTCoVisualizationCash(ptrItem^)._Space <> nil)
   then begin
    Item._Space:=TMemoryStream.Create;
    Item._Space.LoadFromStream(TItemTCoVisualizationCash(ptrItem^)._Space);
    CreateSpaceComponentsUpdaters(@Item);
    end;
  end;

  procedure MoveItem(const Item: TItemTCoVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTCoVisualizationCash(ptrItem^) do begin
  if (idDATAFile <> Item.idDATAFile)
   then begin
    FreeAndNil(_Space);
    FreeSpaceComponentsUpdaters(ptrItem);
    //.
    _Space:=Item._Space;
    _SpaceComponentsUpdaters:=Item._SpaceComponentsUpdaters;
    idDATAFile:=Item.idDATAFile;
    end
   else begin
    Item._Space.Free();
    FreeSpaceComponentsUpdaters(@Item);
    end;
  end;
  end;

  procedure FreeItem(var Item: TItemTCoVisualizationCash);
  begin
  FreeAndNil(Item._Space);
  FreeSpaceComponentsUpdaters(@Item);
  end;
  
var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
  Item: TItemTCoVisualizationCash;
begin
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTCoVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTCoVisualizationCash), 0);
  with TItemTCoVisualizationCash(ptrNewItem^) do begin
  idObj:=pidObj;
  idDATAFile:=0;
  _Space:=nil;
  _SpaceComponentsUpdaters:=nil;
  end;
  UpdateItem(ptrNewItem);
  //.
  TypeSystem.Lock.Enter;
  try
  TItemTCoVisualizationCash(ptrNewItem^).ptrNext:=FItems;
  FItems:=ptrNewItem;
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
opUpdate: begin
  TypeSystem.Lock.Enter;
  try
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil) then CopyToItem(ptrUpdateItem, Item);
  finally
  TypeSystem.Lock.Leave;
  end;
  if (ptrUpdateItem <> nil)
   then begin
    UpdateItem(@Item);
    //.
    TypeSystem.Lock.Enter;
    try
    ptrUpdateItem:=GetPtrItem(pidObj);
    if (ptrUpdateItem <> nil)
     then MoveItem(Item,ptrUpdateItem)
     else FreeItem(Item);
    finally
    TypeSystem.Lock.Leave;
    end;
    end
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTCoVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTCoVisualizationCash), 0);
    with TItemTCoVisualizationCash(ptrNewItem^) do begin
    idObj:=pidObj;
    idDATAFile:=0;
    _Space:=nil;
    _SpaceComponentsUpdaters:=nil;
    end;
    UpdateItem(ptrNewItem);
    //.
    TypeSystem.Lock.Enter;
    try
    TItemTCoVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
end;

procedure TTCoVisualizationCash.Context_RemoveSpaceComponents(const ptrItem: pointer);

  procedure TypesSystem__Cache_RemoveObj(const SpacePtr: pointer; const ptrObj: TPtr);
  var
    Obj: TSpaceObj;
    ptrOwnerObj: TPtr;
  begin
  Obj:=TSpaceObj(Pointer(Integer(SpacePtr)+ptrObj)^);
  if (Obj.idObj <> 0) then TypesSystem.Context_RemoveItem(Obj.idTObj,Obj.idObj);
  //. process own objects ...
  ptrOwnerObj:=Obj.ptrListOwnerObj;
  while (ptrOwnerObj <> nilPtr) do begin
    TypesSystem__Cache_RemoveObj(SpacePtr,ptrOwnerObj);
    //.
    ptrOwnerObj:=TPtr(Pointer(Integer(SpacePtr)+ptrOwnerObj)^);
    end;
  end;

var
  SpacePtr: pointer;
  ptrObj: TPtr;
  ptr: pointer;
begin
with TItemTCoVisualizationCash(ptrItem^) do
if ((_Space <> nil) AND (_Space.Size <> 0))
 then begin
  SpacePtr:=_Space.Memory;
  //.
  ptrObj:=0;
  while (ptrObj <> nilPtr) do begin
    TypesSystem__Cache_RemoveObj(SpacePtr,ptrObj);
    //. next
    ptr:=Pointer(Integer(SpacePtr)+ptrObj);
    ptrObj:=TPtr(ptr^);
    end;
  end;
end;

procedure TTCoVisualizationCash.CreateSpaceComponentsUpdaters(const ptrItem: pointer);

  procedure ProcessObject(const ptrItem: pointer; const SpacePtr: pointer; const ptrObj: TPtr);
  var
    Obj: TSpaceObj;
    ComponentHolder: TComponentPresentUpdater;
    ptrOwnerObj: TPtr;
  begin
  Obj:=TSpaceObj(Pointer(Integer(SpacePtr)+ptrObj)^);
  with TComponentFunctionality_Create(Obj.idTObj,Obj.idObj) do
  try
  ComponentHolder:=TContextComponentHolder_Create();
  finally
  Release;
  end;
  if (ComponentHolder <> nil) then TItemTCoVisualizationCash(ptrItem^)._SpaceComponentsUpdaters.Add(ComponentHolder);
  //. process own objects ...
  ptrOwnerObj:=Obj.ptrListOwnerObj;
  while (ptrOwnerObj <> nilPtr) do begin
    ProcessObject(ptrItem,SpacePtr,ptrOwnerObj);
    //.
    ptrOwnerObj:=TPtr(Pointer(Integer(SpacePtr)+ptrOwnerObj)^);
    end;
  end;

var
  SpacePtr: pointer;
  ptrObj: TPtr;
  ptr: pointer;
begin
with TItemTCoVisualizationCash(ptrItem^) do
if ((_Space <> nil) AND (_Space.Size <> 0))
 then begin
  _SpaceComponentsUpdaters:=TList.Create();
  //.
  SpacePtr:=_Space.Memory;
  //.
  ptrObj:=0;
  while (ptrObj <> nilPtr) do begin
    ProcessObject(ptrItem,SpacePtr,ptrObj);
    //. next
    ptr:=Pointer(Integer(SpacePtr)+ptrObj);
    ptrObj:=TPtr(ptr^);
    end;
  end
 else _SpaceComponentsUpdaters:=nil;
end;

procedure TTCoVisualizationCash.FreeSpaceComponentsUpdaters(const ptrItem: pointer);
var
  I: integer;
begin
with TItemTCoVisualizationCash(ptrItem^) do
if (_SpaceComponentsUpdaters <> nil)
 then begin
  for I:=0 to _SpaceComponentsUpdaters.Count-1 do TObject(_SpaceComponentsUpdaters[I]).Destroy();
  FreeAndNil(_SpaceComponentsUpdaters); 
  end;
end;

procedure TTCoVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTCoVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTCoVisualizationCash(ptrDelItem^).ptrNext;
    if (ComponentFileRefCount(TItemTCoVisualizationCash(ptrDelItem^).idDATAFile) = 1) then Context_RemoveSpaceComponents(ptrDelItem);
    TItemTCoVisualizationCash(ptrDelItem^)._Space.Free;
    FreeSpaceComponentsUpdaters(ptrDelItem);
    FreeMem(ptrDelItem,SizeOf(TItemTCoVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTCoVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTCoVisualizationCash.GetComponentFile(const pidDATAFile: integer; out DATA: TMemoryStream): boolean;
var
  ptrItem: pointer;
begin
Result:=false;
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTCoVisualizationCash(ptrItem^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    if (_Space <> nil)
     then begin
      DATA:=TMemoryStream.Create;
      _Space.SaveToStream(DATA);
      DATA.Position:=0;
      end
     else DATA:=nil;
    Result:=true;
    Exit; //. ->
    end;
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTCoVisualizationCash.ComponentFileRefCount(const pidDATAFile: integer): integer;
var
  ptrItem: pointer;
begin
Result:=0;
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTCoVisualizationCash(ptrItem^) do begin
  if (idDATAFile = pidDATAFile) then Inc(Result);
  //.
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCoVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetSpace(const MS: TMemoryStream): OLEVariant;
  var
    DATAPtr: pointer;
  begin
  if (MS <> nil)
   then with MS do begin
    Position:=0;
    Result:=VarArrayCreate([0,Size-1],varByte);
    DATAPtr:=VarArrayLock(Result);
    try
    Read(DATAPtr^,Size);
    finally
    VarArrayUnLock(Result);
    end;
    end
   else Result:=null;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTCoVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('idDATAFile');       PropNode.nodeTypedValue:=idDATAFile;    ItemNode.appendChild(PropNode);
  //.
  PropNode:=Document.CreateElement('Space');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetSpace(_Space);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCoVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetSpace(DATA: Variant; out MS: TMemoryStream);
  var
    DATASize: integer;
    DATAPtr: pointer;
  begin
  MS:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    MS:=TMemoryStream.Create;
    with MS do begin
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(MS);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _idDATAFile: integer;
  DATA: Variant;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _idDATAFile:=ItemNode.selectSingleNode('idDATAFile').nodeTypedValue;
  DATA:=ItemNode.selectSingleNode('Space').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTCoVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTCoVisualizationCash), 0);
  with TItemTCoVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  _Space:=nil;
  _SpaceComponentsUpdaters:=nil;
  //.
  idDATAFile:=_idDATAFile;
  SetSpace(DATA,{out} _Space);
  CreateSpaceComponentsUpdaters(ptrNewItem);
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

function CoVisualization_GetOwnSpaceHINTVisualizationLocally(const idCoVisualization: integer; out idHINTVisualization: integer): boolean;
begin
with TCoVisualizationFunctionality(TComponentFunctionality_Create(idTCoVisualization,idCoVisualization)) do
try
Result:=GetOwnSpaceHINTVisualizationLocally({out} idHINTVisualization);
finally
Release;
end;
end;






//. Forum-message
Constructor TSystemTForumMessage.Create;
begin
CreateNew(idTForumMessage,tnTForumMessage,TTForumMessageFunctionality);
end;






//. Forum
Constructor TSystemTForum.Create;
begin
CreateNew(idTForum,tnTForum,TTForumFunctionality);
end;






//.  CUSTOM-Visualization
{TSystemTCUSTOMVisualization}
Constructor TSystemTCUSTOMVisualization.Create;
begin
CreateNew(idTCUSTOMVisualization,tnTCUSTOMVisualization,TTCUSTOMVisualizationFunctionality);
if Enabled then Cash:=TTCUSTOMVisualizationCash.Create(Self);
end;

Destructor TSystemTCUSTOMVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTCUSTOMVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTCUSTOMVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTCUSTOMVisualization.Caching_Start;
begin
end;

procedure TSystemTCUSTOMVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTCUSTOMVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTCUSTOMVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTCUSTOMVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTCUSTOMVisualizationCash
Constructor TTCUSTOMVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTCUSTOMVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTCUSTOMVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTCUSTOMVisualizationCash(ptrDelItem^).ptrNext;
  with TItemTCUSTOMVisualizationCash(ptrDelItem^) do begin
  MODULEName:='';
  FunctionName:='';
  end;
  FreeMem(ptrDelItem,SizeOf(TItemTCUSTOMVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCUSTOMVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TCUSTOMVisualizationFunctionality;
  DS: TMemoryStream;
  CDT: TComponentFileType;
  WS,WS1,WS2: WideString;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin  
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTCUSTOMVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTCUSTOMVisualizationCash), 0);
    try
    with TItemTCUSTOMVisualizationCash(ptrNewItem^) do begin
    CF:=TCUSTOMVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetParams(WS,WS1,FunctionVersion);
    MODULEName:=WS; FunctionName:=WS1;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTCUSTOMVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTCUSTOMVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTCUSTOMVisualizationCash), 0);
    with TItemTCUSTOMVisualizationCash(ptrNewItem^) do begin
    CF:=TCUSTOMVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try
    CF.GetParams(WS,WS1,FunctionVersion);
    MODULEName:=WS; FunctionName:=WS1;
    except
      on E: EActionsGroup do ;
      else Raise;
      end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTCUSTOMVisualizationCash(ItemsList[I]^) do with TCUSTOMVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    with TItemTCUSTOMVisualizationCash(ItemsList[I]^) do
    try
    GetParams(WS,WS1,FunctionVersion);
    MODULEName:=WS; FunctionName:=WS1;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTCUSTOMVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;

procedure TTCUSTOMVisualizationCash.Update;
begin
Empty;
end;

function TTCUSTOMVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTCUSTOMVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTCUSTOMVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTCUSTOMVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTCUSTOMVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCUSTOMVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTCUSTOMVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTCUSTOMVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    WS,WS1: WideString;
    CF: TCUSTOMVisualizationFunctionality;
  begin
  try
  with TItemTCUSTOMVisualizationCash(ptrItem^) do begin
  CF:=TCUSTOMVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(WS,WS1,FunctionVersion);
  MODULEName:=WS; FunctionName:=WS1;
  finally
  CF.Release;
  end;
  end;
  except
    end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTCUSTOMVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTCUSTOMVisualizationCash), 0);
  with TItemTCUSTOMVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTCUSTOMVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTCUSTOMVisualizationCash), 0);
    with TItemTCUSTOMVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTCUSTOMVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    WS,WS1: WideString;
    CF: TCUSTOMVisualizationFunctionality;
  begin
  with TItemTCUSTOMVisualizationCash(ptrItem^) do begin
  CF:=TCUSTOMVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(WS,WS1,FunctionVersion);
  MODULEName:=WS; FunctionName:=WS1;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTCUSTOMVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTCUSTOMVisualizationCash(ptrItem^) do begin
  FunctionVersion:=Item.FunctionVersion;
  MODULEName:=Item.MODULEName;
  FunctionName:=Item.FunctionName;
  end;
  end;

var
  Item: TItemTCUSTOMVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTCUSTOMVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTCUSTOMVisualizationCash), 0);
  with TItemTCUSTOMVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTCUSTOMVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTCUSTOMVisualizationCash), 0);
    with TItemTCUSTOMVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCUSTOMVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTCUSTOMVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTCUSTOMVisualizationCash(ptrDelItem^).ptrNext;
    with TItemTCUSTOMVisualizationCash(ptrDelItem^) do begin
    MODULEName:='';
    FunctionName:='';
    end;
    FreeMem(ptrDelItem,SizeOf(TItemTCUSTOMVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTCUSTOMVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCUSTOMVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);
var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTCUSTOMVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('MODULEName');      PropNode.nodeTypedValue:=MODULEName;       ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('FunctionName');    PropNode.nodeTypedValue:=FunctionName;     ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('FunctionVersion'); PropNode.nodeTypedValue:=FunctionVersion;  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCUSTOMVisualizationCash.LoadItems(Node: IXMLDOMNode);
var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _MODULEName: string;
  _FunctionName: string;
  _FunctionVersion: integer;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _MODULEName:=ItemNode.selectSingleNode('MODULEName').nodeTypedValue;
  _FunctionName:=ItemNode.selectSingleNode('FunctionName').nodeTypedValue;
  _FunctionVersion:=ItemNode.selectSingleNode('FunctionVersion').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTCUSTOMVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTCUSTOMVisualizationCash), 0);
  with TItemTCUSTOMVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  MODULEName:=_MODULEName;
  FunctionName:=_FunctionName;
  FunctionVersion:=_FunctionVersion;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;




//.  HREF-Visualization
{TSystemTHREFVisualization}
Constructor TSystemTHREFVisualization.Create;
begin
CreateNew(idTHREFVisualization,tnTHREFVisualization,TTHREFVisualizationFunctionality);
if Enabled then Cash:=TTVisualizationCash.Create(Self);
end;





//.  OLE-Visualization
{TSystemTOLEVisualization}
Constructor TSystemTOLEVisualization.Create;
begin
CreateNew(idTOLEVisualization,tnTOLEVisualization,TTOLEVisualizationFunctionality);
if Enabled then Cash:=TTOLEVisualizationCash.Create(Self);
end;

Destructor TSystemTOLEVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTOLEVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTOLEVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited; 
end;

procedure TSystemTOLEVisualization.Caching_Start;
begin
end;

procedure TSystemTOLEVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTOLEVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTOLEVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTOLEVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTOLEVisualizationCash
Constructor TTOLEVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTOLEVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTOLEVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTOLEVisualizationCash(ptrDelItem^).ptrNext;
  TItemTOLEVisualizationCash(ptrDelItem^).WMF.Free;
  FreeMem(ptrDelItem,SizeOf(TItemTOLEVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOLEVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TOLEVisualizationFunctionality;
  DS: TClientBlobStream;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTOLEVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTOLEVisualizationCash), 0);
    with TItemTOLEVisualizationCash(ptrNewItem^) do begin
    WMF:=nil;
    LastUser_ID:=0;
    LastUser_flRead:=false;
    CF:=TOLEVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetDATA(DS,Space.Configuration.VisualizationMaxSize);
    try
    GetObjWMF(DS, WMF);
    finally
    DS.Destroy;
    end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTOLEVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTOLEVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTOLEVisualizationCash), 0);
    with TItemTOLEVisualizationCash(ptrNewItem^) do begin
    WMF:=nil;
    LastUser_ID:=0;
    LastUser_flRead:=false;
    CF:=TOLEVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try CF.GetDATA(DS,Space.Configuration.VisualizationMaxSize); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTOLEVisualizationCash(ItemsList[I]^) do with TOLEVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    GetDATA(DS,Space.Configuration.VisualizationMaxSize);
    try
    GetObjWMF(DS, WMF);
    finally
    DS.Destroy;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTOLEVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;


procedure TTOLEVisualizationCash.Update;
begin
Empty;
end;

function TTOLEVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTOLEVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTOLEVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTOLEVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTOLEVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOLEVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOLEVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTOLEVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    DATAStream: TClientBlobStream;
    CF: TOLEVisualizationFunctionality;
    DS: TClientBlobStream;
  begin
  with TItemTOLEVisualizationCash(ptrItem^) do begin
  WMF.Free;
  WMF:=nil;
  LastUser_ID:=0;
  //. updating item
  CF:=TOLEVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetDATA(DS,Space.Configuration.VisualizationMaxSize);
  try
  GetObjWMF(DS, WMF);
  finally
  DS.Destroy;
  end;
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTOLEVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOLEVisualizationCash), 0);
  with TItemTOLEVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  WMF:=nil;
  LastUser_ID:=0;
  LastUser_flRead:=false;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTOLEVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTOLEVisualizationCash), 0);
    with TItemTOLEVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    WMF:=nil;
    LastUser_ID:=0;
    LastUser_flRead:=false;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTOLEVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    DATAStream: TClientBlobStream;
    CF: TOLEVisualizationFunctionality;
    DS: TClientBlobStream;
  begin
  with TItemTOLEVisualizationCash(ptrItem^) do begin
  WMF.Free;
  WMF:=nil;
  LastUser_ID:=0;
  //. updating item
  CF:=TOLEVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetDATA(DS,Space.Configuration.VisualizationMaxSize);
  try
  GetObjWMF(DS, WMF);
  finally
  DS.Destroy;
  end;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTOLEVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTOLEVisualizationCash(ptrItem^) do begin
  WMF.Free;
  LastUser_ID:=0;
  //.
  WMF:=Item.WMF;
  end;
  end;

var
  Item: TItemTOLEVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTOLEVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOLEVisualizationCash), 0);
  with TItemTOLEVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  WMF:=nil;
  LastUser_ID:=0;
  LastUser_flRead:=false;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTOLEVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTOLEVisualizationCash), 0);
    with TItemTOLEVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    WMF:=nil;
    LastUser_ID:=0;
    LastUser_flRead:=false;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOLEVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTOLEVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTOLEVisualizationCash(ptrDelItem^).ptrNext;
    TItemTOLEVisualizationCash(ptrDelItem^).WMF.Free;
    FreeMem(ptrDelItem,SizeOf(TItemTOLEVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTOLEVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOLEVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetDATA(const WMF: TMetaFile): OLEVariant;
  var
    MS: TMemoryStream;
    DATAPtr: pointer;
  begin
  MS:=TMemoryStream.Create;
  with MS do
  try
  if (WMF <> nil)
   then begin
    WMF.SaveToStream(MS);
    Position:=0;
    end;
  Result:=VarArrayCreate([0,Size-1],varByte);
  DATAPtr:=VarArrayLock(Result);
  try
  Read(DATAPtr^,Size);
  finally
  VarArrayUnLock(Result);
  end;
  finally
  Destroy;
  end;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOLEVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('WMF');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetDATA(WMF);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOLEVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetDATA(DATA: Variant; out WMF: TMetaFile);
  var
    DATASize: integer;
    DATAPtr: pointer;
    MS: TMemoryStream;
  begin
  WMF:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    MS:=TMemoryStream.Create;
    with MS do
    try
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    WMF:=TMetaFile.Create;
    WMF.LoadFromStream(MS);
    finally
    Destroy;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(WMF);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  DATA: Variant;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  DATA:=ItemNode.selectSingleNode('WMF').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTOLEVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOLEVisualizationCash), 0);
  with TItemTOLEVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  LastUser_ID:=0;
  LastUser_flRead:=false;
  SetDATA(DATA, WMF);
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;




//.  HTML-Visualization
{TSystemTHTMLVisualization}
Constructor TSystemTHTMLVisualization.Create;
begin
CreateNew(idTHTMLVisualization,tnTHTMLVisualization,TTHTMLVisualizationFunctionality);
if Enabled then Cash:=TTHTMLVisualizationCash.Create(Self);
end;

Destructor TSystemTHTMLVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTHTMLVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTHTMLVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTHTMLVisualization.Caching_Start;
begin
end;

procedure TSystemTHTMLVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTHTMLVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTHTMLVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTHTMLVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTHTMLVisualizationCash
Constructor TTHTMLVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTHTMLVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTHTMLVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTHTMLVisualizationCash(ptrDelItem^).ptrNext;
  TItemTHTMLVisualizationCash(ptrDelItem^).DataStream.Free;
  FreeMem(ptrDelItem,SizeOf(TItemTHTMLVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTHTMLVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: THTMLVisualizationFunctionality;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTHTMLVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTHTMLVisualizationCash), 0);
    with TItemTHTMLVisualizationCash(ptrNewItem^) do begin
    DataStream:=nil;
    Width:=0;
    LastUser_ID:=0;
    LastUser_flRead:=false;
    CF:=THTMLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    Width:=CF.Width;
    CF.GetDATA(DataStream,Space.Configuration.VisualizationMaxSize);
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTHTMLVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTHTMLVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTHTMLVisualizationCash), 0);
    with TItemTHTMLVisualizationCash(ptrNewItem^) do begin
    DataStream:=nil;
    Width:=0;
    LastUser_ID:=0;
    LastUser_flRead:=false;
    CF:=THTMLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try Width:=CF.Width; except on E: EActionsGroup do ; else Raise; end;
    try CF.GetDATA(DataStream,Space.Configuration.VisualizationMaxSize); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTHTMLVisualizationCash(ItemsList[I]^) do with THTMLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    TItemTHTMLVisualizationCash(ItemsList[I]^).Width:=Width;
    GetDATA(TItemTHTMLVisualizationCash(ItemsList[I]^).DataStream,Space.Configuration.VisualizationMaxSize);
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTHTMLVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;


procedure TTHTMLVisualizationCash.Update;
begin
Empty;
end;

function TTHTMLVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTHTMLVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTHTMLVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTHTMLVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTHTMLVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTHTMLVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTHTMLVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTHTMLVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: THTMLVisualizationFunctionality;
  begin
  with TItemTHTMLVisualizationCash(ptrItem^) do begin
  DataStream.Free;
  DataStream:=nil;
  LastUser_ID:=0;
  //. updating item
  CF:=THTMLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  Width:=CF.Width;
  CF.GetDATA(DataStream,Space.Configuration.VisualizationMaxSize);
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTHTMLVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTHTMLVisualizationCash), 0);
  with TItemTHTMLVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  DataStream:=nil;
  Width:=0;
  LastUser_ID:=0;
  LastUser_flRead:=false;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTHTMLVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTHTMLVisualizationCash), 0);
    with TItemTHTMLVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    DataStream:=nil;
    Width:=0;
    LastUser_ID:=0;
    LastUser_flRead:=false;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTHTMLVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: THTMLVisualizationFunctionality;
  begin
  with TItemTHTMLVisualizationCash(ptrItem^) do begin
  DataStream.Free;
  DataStream:=nil;
  LastUser_ID:=0;
  //. updating item
  CF:=THTMLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  Width:=CF.Width;
  CF.GetDATA(DataStream,Space.Configuration.VisualizationMaxSize);
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTHTMLVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTHTMLVisualizationCash(ptrItem^) do begin
  DataStream.Free;
  LastUser_ID:=0;
  //.
  Width:=Item.Width;
  DataStream:=Item.DataStream;
  end;
  end;

var
  Item: TItemTHTMLVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTHTMLVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTHTMLVisualizationCash), 0);
  with TItemTHTMLVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  DataStream:=nil;
  Width:=0;
  LastUser_ID:=0;
  LastUser_flRead:=false;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTHTMLVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTHTMLVisualizationCash), 0);
    with TItemTHTMLVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    DataStream:=nil;
    Width:=0;
    LastUser_ID:=0;
    LastUser_flRead:=false;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTHTMLVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTHTMLVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTHTMLVisualizationCash(ptrDelItem^).ptrNext;
    TItemTHTMLVisualizationCash(ptrDelItem^).DataStream.Free;
    FreeMem(ptrDelItem,SizeOf(TItemTHTMLVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTHTMLVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTHTMLVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetDATA(const CBS: TClientBlobStream): OLEVariant;
  var
    MS: TMemoryStream;
    DATAPtr: pointer;
  begin
  if (CBS <> nil)
   then with CBS do begin
    Position:=0;
    Result:=VarArrayCreate([0,Size-1],varByte);
    DATAPtr:=VarArrayLock(Result);
    try
    Read(DATAPtr^,Size);
    finally
    VarArrayUnLock(Result);
    end;
    end
   else Result:=null;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTHTMLVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('Width');           PropNode.nodeTypedValue:=Width;           ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('DATA');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetDATA(DATAStream);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTHTMLVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetDATA(DATA: Variant; out CBS: TClientBlobStream);
  var
    DATASize: integer;
    DATAPtr: pointer;
    MS: TMemoryStream;
  begin
  CBS:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    CBS:=TClientBlobStream(TMemoryStream.Create);
    with CBS do begin
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(CBS);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _Width: integer;
  DATA: Variant;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _Width:=ItemNode.selectSingleNode('Width').nodeTypedValue;
  DATA:=ItemNode.selectSingleNode('DATA').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTHTMLVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTHTMLVisualizationCash), 0);
  with TItemTHTMLVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  Width:=_Width;
  LastUser_ID:=0;
  LastUser_flRead:=false;
  SetDATA(DATA, DATAStream);
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;




//. BZR-Visualization
{TSystemTBZRVisualization}
Constructor TSystemTBZRVisualization.Create;
begin
CreateNew(idTBZRVisualization,tnTBZRVisualization,TTBZRVisualizationFunctionality);
end;





//.  AGIF-Visualization
{TSystemTAGIFVisualization}
Constructor TSystemTAGIFVisualization.Create;
begin
CreateNew(idTAGIFVisualization,tnTAGIFVisualization,TTAGIFVisualizationFunctionality);
if Enabled then Cash:=TTAGIFVisualizationCash.Create(Self);
end;

Destructor TSystemTAGIFVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTAGIFVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTAGIFVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTAGIFVisualization.Caching_Start;
begin
end;

procedure TSystemTAGIFVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTAGIFVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTAGIFVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTAGIFVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TAGIFDataUpdating
Constructor TAGIFData.Create(pSpace: TProxySpace; const pidTObj,pidObj: integer; const MS: TMemoryStream = nil);
var
  D: TClientBlobStream;
begin
Space:=pSpace;
DATA:=TGIFImage.Create;
if (MS = nil)
 then with TAGIFVisualizationFunctionality(TComponentFunctionality_Create(pidTObj,pidObj)) do
  try
  flUserSecurityDisabled:=true;
  GetDATA(D,Space.Configuration.VisualizationMaxSize);
  try
  DATA.LoadFromStream(D);
  finally
  D.Destroy;
  end;
  finally
  Release;
  end
 else begin
  MS.Position:=0;
  DATA.LoadFromStream(MS);
  end;
Lock:=TCriticalSection.Create;
BMP:=nil;
Interval:=10;
FrameID:=0;
//. preset
BMP:=DATA.Frames[FrameID].Bitmap;
//.
RefCount:=1;
Inherited Create(false);
end;

Destructor TAGIFData.Destroy;
begin
Inherited;
DATA.Free;
Lock.Free;
end;

procedure TAGIFData.Execute;
var
  I: integer;
  TimeInterval: integer;
begin
I:=0;
TimeInterval:=0;
repeat
  //.
  if (I = TimeInterval)
   then
    try
    I:=0;
    Lock.Enter;
    try
    BMP:=DATA.Frames[FrameID].Bitmap;
    /// ? BMP.Transparent:=true;
    /// ? BMP.TransparentColor:=BMP.Canvas.Pixels[0,BMP.Height-1];
    TimeInterval:=Trunc(DATA.Frames[FrameID].AnimateInterval/Interval);
    if TimeInterval = 0 then TimeInterval:=1;
    Inc(FrameID);
    if FrameID >= DATA.Count then FrameID:=0;
    finally
    Lock.Leave;
    end;
    except
      end;
  //.
  Sleep(Interval);
  Inc(I);
until Terminated;
end;

//. TAGIFDataTracker
Constructor TTAGIFVisualizationAGIFDataTracker.Create(pCash: TTAGIFVisualizationCash);
begin
Cash:=pCash;
Inherited Create(false);
end;

Destructor TTAGIFVisualizationAGIFDataTracker.Destroy;
begin
Inherited;
end;

procedure TTAGIFVisualizationAGIFDataTracker.Execute;
const
  Interval = 300; //. 300 ms
  MaxNullRefTime = 1800*(1/(3600*24)); //. 
var
  ptrItem: pointer;
begin
with Cash do
repeat
  try
  TypeSystem.Lock.Enter;
  try
  ptrItem:=FItems;
  while ptrItem <> nil do with TItemTAGIFVisualizationCash(ptrItem^) do begin
    if (AGIFData <> nil) AND (AGIFData.RefCount = 0) AND ((Now-AGIFData.NullRefTime) > MaxNullRefTime)
     then begin
      AGIFData.Destroy;
      AGIFData:=nil;
      end;
    ptrItem:=ptrNext;
    end;
  finally
  TypeSystem.Lock.Leave;
  end;
  except
    end;
  //.
  Sleep(Interval);
until Terminated;
end;

//. TTAGIFVisualizationCash
Constructor TTAGIFVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
AGIFDataTracker:=TTAGIFVisualizationAGIFDataTracker.Create(Self);
end;

destructor TTAGIFVisualizationCash.Destroy;
begin
AGIFDataTracker.Free;
Empty;
Inherited;
end;

procedure TTAGIFVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTAGIFVisualizationCash(ptrDelItem^).ptrNext;
  TItemTAGIFVisualizationCash(ptrDelItem^).AGIFData.Free;
  FreeMem(ptrDelItem,SizeOf(TItemTAGIFVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTAGIFVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
begin
if List.Count = 0 then Exit; //. ->
for I:=0 to List.Count-1 do begin
  GetMem(ptrNewItem,SizeOf(TItemTAGIFVisualizationCash));
  try
  FillChar(ptrNewItem^,SizeOf(TItemTAGIFVisualizationCash), 0);
  with TItemTAGIFVisualizationCash(ptrNewItem^) do begin
  idObj:=Integer(List[I]);
  AGIFDATA:=nil;
  end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  TItemTAGIFVisualizationCash(ptrNewItem^).ptrNext:=FItems;
  FItems:=ptrNewItem;
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
end;


procedure TTAGIFVisualizationCash.Update;
begin
Empty;
end;

function TTAGIFVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTAGIFVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTAGIFVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTAGIFVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTAGIFVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTAGIFVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTAGIFVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

procedure TTAGIFVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  begin
  with TItemTAGIFVisualizationCash(ptrItem^) do begin
  //. updating item
  AGIFData.Free;
  AGIFData:=nil;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTAGIFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTAGIFVisualizationCash), 0);
  with TItemTAGIFVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  AGIFData:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTAGIFVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTAGIFVisualizationCash), 0);
    with TItemTAGIFVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    AGIFData:=nil;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTAGIFVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTAGIFVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTAGIFVisualizationCash(ptrDelItem^).ptrNext;
    TItemTAGIFVisualizationCash(ptrDelItem^).AGIFData.Free;
    FreeMem(ptrDelItem,SizeOf(TItemTAGIFVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTAGIFVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTAGIFVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetDATA(const AGIFData: TAGIFData): OLEVariant;
  var
    MS: TMemoryStream;
    DATAPtr: pointer;
  begin
  MS:=TMemoryStream.Create;
  with MS do
  try
  if (AGIFData <> nil)
   then begin
    AGIFData.DATA.SaveToStream(MS);
    Position:=0;
    end;
  Result:=VarArrayCreate([0,Size-1],varByte);
  DATAPtr:=VarArrayLock(Result);
  try
  Read(DATAPtr^,Size);
  finally
  VarArrayUnLock(Result);
  end;
  finally
  Destroy;
  end;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTAGIFVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('DATA');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetDATA(AGIFData);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTAGIFVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetDATA(DATA: Variant; out MS: TMemoryStream);
  var
    DATASize: integer;
    DATAPtr: pointer;
  begin
  MS:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    MS:=TMemoryStream.Create;
    with MS do begin
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(MS);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  DATA: Variant;
  MS: TMemoryStream;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  DATA:=ItemNode.selectSingleNode('DATA').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTAGIFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTAGIFVisualizationCash), 0);
  with TItemTAGIFVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  SetDATA(DATA, MS);
  try
  if (MS <> nil) then AGIFData:=TAGIFData.Create(TypeSystem.Space,TypeSystem.idType,idObj,MS) else AGIFData:=nil; 
  finally
  MS.Free;
  end;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;


//. TAGIFVisualizationUpdating
Constructor TAGIFVisualizationUpdating.Create(pReflecting: TReflecting; pFunctionality: TComponentFunctionality);
begin
Functionality:=pFunctionality;
Functionality.AddRef;
Reflecting:=pReflecting;
FreeOnTerminate:=true;
Inherited Create(true);
Priority:=tpLower;
Resume;
end;

Destructor TAGIFVisualizationUpdating.Destroy;
begin
Inherited;
end;

procedure TAGIFVisualizationUpdating.Execute;
var
  LastReflectionHashCode: Double;
begin
try
with TAGIFVisualizationFunctionality(Functionality) do begin
//. get AGIF data provider
TypeSystem.Lock.Enter;
try
ptrItem:=TSystemTAGIFVisualization(TypeSystem).Cash.GetPtrItem(idObj);
if ptrItem <> nil
 then with TItemTAGIFVisualizationCash(ptrItem^) do
  if AGIFData <> nil
   then Inc(AGIFData.RefCount)
   else AGIFData:=TAGIFData.Create(Space,TypeSystem.idType,idObj)
finally
TypeSystem.Lock.Leave;
end;
try
//. updating
LastReflectionHashCode:=Reflecting.Reflector.ReflectionWindow.HashCode;
LastFrameID:=-1;
Interval:=100;
repeat
  if (
        (LastReflectionHashCode = Reflecting.Reflector.ReflectionWindow.HashCode) AND
        (NOT Reflecting.ReFormingLays.flReforming) AND
        (NOT Reflecting.flReflecting) AND
        (NOT Reflecting.flBriefReflecting)
      )
   then Synchronize(Self.Update);
  //.
  Sleep(Interval);
until Terminated;
finally
//. release AGIF data provider
TypeSystem.Lock.Enter;
try
ptrItem:=TSystemTAGIFVisualization(TypeSystem).Cash.GetPtrItem(idObj);
if ptrItem <> nil
 then with TItemTAGIFVisualizationCash(ptrItem^) do
  if AGIFData <> nil
   then begin
    Dec(AGIFData.RefCount);
    if AGIFData.RefCount = 0 then AGIFData.NullRefTime:=Now;
    end;
finally
TypeSystem.Lock.Leave;
end;
end;
end;
finally
Functionality.Release;
end;
end;

procedure TAGIFVisualizationUpdating.Update;
begin
with TAGIFVisualizationFunctionality(Functionality) do begin
TypeSystem.Lock.Enter;
try
ptrItem:=TSystemTAGIFVisualization(TypeSystem).Cash.GetPtrItem(idObj);
if ptrItem <> nil
 then with TItemTAGIFVisualizationCash(ptrItem^),Reflecting.Reflector do begin
  AGIFData.Lock.Enter;
  try
  if (AGIFData.BMP <> nil)
   then begin
    if (AGIFData.FrameID <> LastFrameID)
     then begin
      Canvas.Lock;
      try
      SetGraphicsMode(Canvas.Handle,GM_ADVANCED);
      SetWorldTransForm(Canvas.Handle,XF);
      try
      /// ? native draw Canvas.StretchDraw(Rect(0,0,Round(_Width),Round(b)), AGIFData.BMP);
      DrawUsingGDIPus(Canvas.Handle, AGIFData.BMP,0,0,Round(_Width),Round(b));
      finally
      ModifyWorldTransForm(Canvas.Handle,XF,MWT_IDENTITY);
      end;
      finally
      Canvas.UnLock;
      end;
      LastFrameID:=AGIFData.FrameID;
      end;
    end;
  Interval:=AGIFData.Interval-1;
  finally
  AGIFData.Lock.Leave;
  end;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;
end;



//. Oriented OrientedVIDEO-Visualization
{TSystemTOrientedVIDEOVisualization}
Constructor TSystemTOrientedVIDEOVisualization.Create;
begin
CreateNew(idTOrientedVIDEOVisualization,tnTOrientedVIDEOVisualization,TTOrientedVIDEOVisualizationFunctionality);
if Enabled then Cash:=TTOrientedVIDEOVisualizationCash.Create(Self);
end;

Destructor TSystemTOrientedVIDEOVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTOrientedVIDEOVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTOrientedVIDEOVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTOrientedVIDEOVisualization.Caching_Start;
begin
end;

procedure TSystemTOrientedVIDEOVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTOrientedVIDEOVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTOrientedVIDEOVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTOrientedVIDEOVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TAUDIOData
Constructor TAUDIOData.Create(pVIDEOData: TVIDEOData);
begin
VIDEOData:=pVIDEOData;
Inherited Create(true);
Priority:=tpHighest;
Resume;
end;

Destructor TAUDIOData.Destroy;
begin
Inherited;
end;

const
  WaveBuffersCount = 3;
type
  TWaveBuffer = record
    PacketData: PSafeArray;
    wh: TWaveHdr;
  end;

  TWaveBufferingAndPlaying = class(TThread)
  private
    AUDIOData: TAUDIOData;
    Lock: TCriticalSection;
    WaveBuffers: array[0..WaveBuffersCount-1] of TWaveBuffer;
    WaveBuffersHeadPos: integer;
    WaveBuffersTailPos: integer;

    HWO: HWaveOut;
    evtDone: THandle;

    Constructor Create(pAUDIOData: TAUDIOData);
    Destructor Destroy; override;
    procedure Execute; override;
    procedure AUDIO_Start(Header: PSafeArray);
    procedure AUDIO_Stop;
  end;

Constructor TWaveBufferingAndPlaying.Create(pAUDIOData: TAUDIOData);
var
  I: integer;
begin
AUDIOData:=pAUDIOData;
Lock:=TCriticalSection.Create;
for I:=0 to WaveBuffersCount-1 do with WaveBuffers[I] do begin
  PacketData:=nil;
  wh.lpData:=nil;
  wh.dwBufferLength:=0;
  wh.dwUser:=0;
  wh.dwFlags:=0;
  wh.dwLoops:=1;
  wh.lpNext:=nil;
  wh.reserved:=0;
  end;
WaveBuffersHeadPos:=0;
WaveBuffersTailPos:=0;
Inherited Create(true);
Priority:=tpHigher;
end;

Destructor TWaveBufferingAndPlaying.Destroy;
var
  I: integer;
begin
if (Suspended) then Resume();
Inherited;
for I:=0 to WaveBuffersCount-1 do with WaveBuffers[I] do begin
  if PacketData <> nil
   then begin
    SafeArrayUnAccessData(PacketData);
    SafeArrayDestroy(PacketData);
    PacketData:=nil;
    end;
  /// ? if waveOutUnPrepareHeader(hwo,@wh,sizeof(TWaveHdr)) <> MMSYSERR_NOERROR then Raise Exception.Create('could not prepare header'); //. =>
  end;
Lock.Free;
end;

procedure TWaveBufferingAndPlaying.Execute;
begin 
repeat
  if (WaveBuffersHeadPos <> WaveBuffersTailPos)
   then begin
    try
    if (waveOutWrite(hwo,@WaveBuffers[WaveBuffersTailPos].wh,SizeOf(WaveBuffers[WaveBuffersTailPos].wh)) <> MMSYSERR_NOERROR) then Raise Exception.Create('could not write device'); //. =>with PlayList.LockList do
    WaitForSingleObject(evtDone, INFINITE);
    Inc(WaveBuffersTailPos);
    if WaveBuffersTailPos >= WaveBuffersCount then WaveBuffersTailPos:=0;
    except
      end;
    end
   else
    Sleep(15);
until Terminated;
end;

procedure TWaveBufferingAndPlaying.AUDIO_Start(Header: PSafeArray);
var
  DATAPtr: pointer;
begin
//. create done event
evtDone:=CreateEvent(nil,true,true,nil);
//. open out device
SafeArrayAccessData(Header, DATAPtr);
try
if waveOutOpen(@HWO,WAVE_MAPPER,DATAPtr,Cardinal(evtDone),0,CALLBACK_EVENT) <> MMSYSERR_NOERROR then Raise Exception.Create('could not open device'); //. =>
finally
SafeArrayUnAccessData(Header);
end;
end;

procedure TWaveBufferingAndPlaying.AUDIO_Stop;
begin
//. close done event
CloseHandle(evtDone);
//.
if waveOutReset(hwo) <> MMSYSERR_NOERROR then Raise Exception.Create('could not reset device'); //. =>}
if waveOutClose(hwo) <> MMSYSERR_NOERROR then Raise Exception.Create('could not close device'); //. =>
end;

procedure TAUDIOData.Execute;
var
  DATAProvider: IVIDEODataProvider;
  Params: WideString;
  Interval,CID: integer;
  _PacketData: PSafeArray;
  LastPacketID,PacketID: integer;
  PacketDataPtr: pointer;
  PacketSize: integer;
  DistPtr: pointer;
  AUDIOHeader: PSafeArray;
  DATAPtr: pointer;
begin
CoInitializeEx(nil, COINIT_MULTITHREADED);
try
DATAProvider:=CocoVIDEOData.CreateRemote(VIDEOData.DataServer);
/// + VIDEOData.Space.GetSecurityParams(Params);
try
DATAProvider.Open(VIDEOData.idTObj,VIDEOData.idObj,Integer(idReadOperation),Params);
except
  Exit; //. ->
  end;
if NOT DATAProvider.hasAudio then Exit; //. ->
//.
with TWaveBufferingAndPlaying.Create(Self) do
try
DATAProvider.GetAudioDataParams(VIDEOData.ObjectID, AUDIOHeader,Interval,CID);
try
AUDIO_Start(AUDIOHeader);
finally
SafeArrayDestroy(AUDIOHeader);
end;
try
Resume;
Interval:=Interval-1;
if Interval > 100 then Interval:=100;
repeat
  //.
  try
  DATAProvider.GetAudioData(VIDEOData.ObjectID, _PacketData,PacketID);
  if PacketID <> LastPacketID
   then begin
    with WaveBuffers[WaveBuffersHeadPos] do begin
    if PacketData <> nil
     then begin
      SafeArrayUnAccessData(PacketData);
      SafeArrayDestroy(PacketData);
      PacketData:=nil;
      end;
    PacketData:=_PacketData;
    SafeArrayAccessData(PacketData,DATAPtr);
    //.
    wh.lpData:=DATAPtr;
    wh.dwBufferLength:=PacketData^.rgsabound[0].cElements;
    wh.dwUser:=0;
    wh.dwFlags:=0;
    wh.dwLoops:=1;
    wh.lpNext:=nil;
    wh.reserved:=0;
    if waveOutPrepareHeader(hwo,@wh,sizeof(TWaveHdr)) <> MMSYSERR_NOERROR then Raise Exception.Create('could not prepare header'); //. =>
    end;
    Inc(WaveBuffersHeadPos);
    if WaveBuffersHeadPos >= WaveBuffersCount then WaveBuffersHeadPos:=0;
    //.
    LastPacketID:=PacketID;
    end
   else
    SafeArrayDestroy(_PacketData);
  except
    end;
  //.
  Sleep(Interval);
until Self.Terminated;
finally
AUDIO_Stop;
end;
finally
Destroy;
end;
finally
CoUnInitialize;
end;
end;

//. TVIDEODataUpdating
Constructor TVIDEOData.Create(pSpace: TProxySpace; const pidTObj,pidObj: integer; const pDataServer: string; const pObjectID: integer);
begin
Space:=pSpace;
idTObj:=pidTObj;
idObj:=pidObj;
Lock:=TCriticalSection.Create;
FrameBuffer:=nil;
Interval:=100;
DataServer:=pDataServer;
ObjectID:=pObjectID;
LastFrameID:=-1;
RefCount:=1;
AUDIOData:=TAUDIOData.Create(Self);
Inherited Create(false);
end;

Destructor TVIDEOData.Destroy;
begin
Inherited;
AUDIOData.Free;
if FrameBuffer <> nil then SafeArrayDestroy(FrameBuffer);
Lock.Free;
end;

procedure TVIDEOData.Execute;
var
  DATAProvider: IVIDEODataProvider;
  Params: WideString;
  W,H,I,CID: integer;
  FrameData: PSafeArray;
  FrameID: integer;
  FrameDataPtr: pointer;
  FrameSize: integer;
  DistPtr: pointer;
begin
CoInitializeEx(nil, COINIT_MULTITHREADED);
try
DATAProvider:=CocoVIDEOData.CreateRemote(DataServer);
/// + Space.GetSecurityParams(Params);
try
DATAProvider.Open(idTObj,idObj,Integer(idReadOperation),Params);
except
  Exit; //. ->
  end;
if NOT DATAProvider.hasVideo then Exit; //. ->
DATAProvider.GetVideoDataParams(ObjectID, W,H,I,CID);
Lock.Enter;
try
Interval:=I-1;
finally
Lock.Leave;
end;
if Interval > 100 then Interval:=100;
repeat
  //.
  try
  DATAProvider.GetVideoData(ObjectID, FrameData,FrameID);
  Lock.Enter;
  try
  if FrameID <> LastFrameID
   then begin
    if FrameBuffer <> nil then SafeArrayDestroy(FrameBuffer);
    FrameBuffer:=FrameData;
    LastFrameID:=FrameID;
    end
   else
    SafeArrayDestroy(FrameData);
  finally
  Lock.Leave;
  end;
  except
    end;
  //.
  Sleep(Interval);
until Terminated;
finally
CoUnInitialize;
end;
end;

//. TVIDEODataTracker
Constructor TVIDEODataTracker.Create(pCash: TTOrientedVIDEOVisualizationCash);
begin
Cash:=pCash;
Inherited Create(false);
end;

Destructor TVIDEODataTracker.Destroy;
begin
Inherited;
end;

procedure TVIDEODataTracker.Execute;
const
  Interval = 300; //. 300 ms
  MaxNullRefTime = 1/(3600*24); //. 1 sec
var
  ptrItem: pointer;
begin
with Cash do
repeat
  try
  TypeSystem.Lock.Enter;
  try
  ptrItem:=FItems;
  while ptrItem <> nil do with TItemTOrientedVIDEOVisualizationCash(ptrItem^) do begin
    if (VIDEOData <> nil) AND (VIDEOData.RefCount = 0) AND ((Now-VIDEOData.NullRefTime) > MaxNullRefTime)
     then begin
      VIDEOData.Destroy;
      VIDEOData:=nil;
      end;
    ptrItem:=ptrNext;
    end;
  finally
  TypeSystem.Lock.Leave;
  end;
  except
    end;
  //.
  Sleep(Interval);
until Terminated;
end;

//. TTOrientedVIDEOVisualizationCash
Constructor TTOrientedVIDEOVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
VIDEODataTracker:=TVIDEODataTracker.Create(Self);
end;

destructor TTOrientedVIDEOVisualizationCash.Destroy;
begin
VIDEODataTracker.Free;
Empty;
Inherited;
end;

procedure TTOrientedVIDEOVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTOrientedVIDEOVisualizationCash(ptrDelItem^).ptrNext;
  TItemTOrientedVIDEOVisualizationCash(ptrDelItem^).VIDEOData.Free;
  FreeMem(ptrDelItem,SizeOf(TItemTOrientedVIDEOVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedVIDEOVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
begin
if List.Count = 0 then Exit; //. ->
for I:=0 to List.Count-1 do begin
  GetMem(ptrNewItem,SizeOf(TItemTOrientedVIDEOVisualizationCash));
  try
  FillChar(ptrNewItem^,SizeOf(TItemTOrientedVIDEOVisualizationCash), 0);
  with TItemTOrientedVIDEOVisualizationCash(ptrNewItem^) do begin
  idObj:=Integer(List[I]);
  VIDEOData:=nil;
  end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  TItemTOrientedVIDEOVisualizationCash(ptrNewItem^).ptrNext:=FItems;
  FItems:=ptrNewItem;
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
end;


procedure TTOrientedVIDEOVisualizationCash.Update;
begin
Empty;
end;

function TTOrientedVIDEOVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTOrientedVIDEOVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTOrientedVIDEOVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTOrientedVIDEOVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTOrientedVIDEOVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedVIDEOVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOrientedVIDEOVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

procedure TTOrientedVIDEOVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  begin
  with TItemTOrientedVIDEOVisualizationCash(ptrItem^) do begin
  //. updating item
  VIDEOData.Free;
  VIDEOData:=nil;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTOrientedVIDEOVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOrientedVIDEOVisualizationCash), 0);
  with TItemTOrientedVIDEOVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  VIDEOData:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedVIDEOVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedVIDEOVisualizationCash), 0);
    with TItemTOrientedVIDEOVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    VIDEOData:=nil;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedVIDEOVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTOrientedVIDEOVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTOrientedVIDEOVisualizationCash(ptrDelItem^).ptrNext;
    TItemTOrientedVIDEOVisualizationCash(ptrDelItem^).VIDEOData.Free;
    FreeMem(ptrDelItem,SizeOf(TItemTOrientedVIDEOVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTOrientedVIDEOVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedVIDEOVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);
var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOrientedVIDEOVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedVIDEOVisualizationCash.LoadItems(Node: IXMLDOMNode);
var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTOrientedVIDEOVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOrientedVIDEOVisualizationCash), 0);
  with TItemTOrientedVIDEOVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  VIDEOData:=nil;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;


//. TOrientedVIDEOVisualizationUpdating
Constructor TOrientedVIDEOVisualizationUpdating.Create(pReflecting: TReflecting; pFunctionality: TComponentFunctionality);
begin
Functionality:=pFunctionality;
Functionality.AddRef;
Reflecting:=pReflecting;
FreeOnTerminate:=true;
Inherited Create(false);
end;

Destructor TOrientedVIDEOVisualizationUpdating.Destroy;
begin
Inherited;
end;

procedure TOrientedVIDEOVisualizationUpdating.Execute;
var
  Interval: integer;
  ptrItem: pointer;
  LastReflectionHashCode: Double;
  FrameDataPtr: pointer;
  K: Double;
  DDib: THandle;
  BMP: TBitmap;
  W,H: Double;
begin
try
with TOrientedVIDEOVisualizationFunctionality(Functionality) do begin
//. get VIDEO data provider
TypeSystem.Lock.Enter;
try
ptrItem:=TSystemTOrientedVIDEOVisualization(TypeSystem).Cash.GetPtrItem(idObj);
if ptrItem <> nil
 then with TItemTOrientedVIDEOVisualizationCash(ptrItem^) do
  if VIDEOData <> nil
   then Inc(VIDEOData.RefCount)
   else VIDEOData:=TVIDEOData.Create(Space,TypeSystem.idType,idObj,DataServer,ObjectID)
finally
TypeSystem.Lock.Leave;
end;
try
//. updating
BMP:=TBitmap.Create;
try
LastReflectionHashCode:=Reflecting.Reflector.ReflectionWindow.HashCode;
Interval:=100;
repeat
  TypeSystem.Lock.Enter;
  try
  if LastReflectionHashCode = Reflecting.Reflector.ReflectionWindow.HashCode
   then begin
    ptrItem:=TSystemTOrientedVIDEOVisualization(TypeSystem).Cash.GetPtrItem(idObj);
    if ptrItem <> nil
     then with TItemTOrientedVIDEOVisualizationCash(ptrItem^),Reflecting.Reflector do begin
      DDib:=DrawDibOpen;
      try
      VIDEOData.Lock.Enter;
      try
      if VIDEOData.FrameBuffer <> nil
       then begin
        SafeArrayAccessData(VIDEOData.FrameBuffer,FrameDataPtr);
        try
        K:=TBitmapInfoHeader(FrameDataPtr^).biHeight/TBitmapInfoHeader(FrameDataPtr^).biWidth;
        W:=Sqrt(Sqr(D)/(1+Sqr(K))); H:=Sqrt(Sqr(D)/(1+Sqr(K)))*K;
        Canvas.Lock;
        try
        DrawDIBDraw(DDib,Canvas.Handle, Round(Xc-W/2),Round(Yc-H/2),Round(W),Round(H), FrameDataPtr,Pointer(Integer(FrameDataPtr)+TBitmapInfoHeader(FrameDataPtr^).biSize), 0,0,TBitmapInfoHeader(FrameDataPtr^).biWidth,TBitmapInfoHeader(FrameDataPtr^).biHeight, 0);
        {/// + freezing with BMP do begin
        Handle:=0;
        Width:=TBitmapInfoHeader(FrameDataPtr^).biWidth;
        Height:=TBitmapInfoHeader(FrameDataPtr^).biHeight;
        DrawDIBDraw(DDib,Canvas.Handle, 0,0,Width,Height, FrameDataPtr,Pointer(Integer(FrameDataPtr)+TBitmapInfoHeader(FrameDataPtr^).biSize), 0,0,TBitmapInfoHeader(FrameDataPtr^).biWidth,TBitmapInfoHeader(FrameDataPtr^).biHeight, 0);
        end;
        DrawUsingGDIPus(Canvas.Handle, BMP,Round(Xc-W/2),Round(Yc-H/2),Round(W),Round(H));}
        finally
        Canvas.UnLock;
        end;
        finally
        SafeArrayUnAccessData(VIDEOData.FrameBuffer);
        end;
        end;
      Interval:=VIDEOData.Interval-1;
      finally
      VIDEOData.Lock.Leave;
      end;
      finally
      DrawDibClose(DDib);
      DrawDibStop(DDib);
      end;
      end;
    end;
  finally
  TypeSystem.Lock.Leave;
  end;
  //.
  Sleep(Interval);
until Terminated;
finally
BMP.Destroy;
end;
finally
//. release VIDEO data provider
TypeSystem.Lock.Enter;
try
ptrItem:=TSystemTOrientedVIDEOVisualization(TypeSystem).Cash.GetPtrItem(idObj);
if ptrItem <> nil
 then with TItemTOrientedVIDEOVisualizationCash(ptrItem^) do
  if VIDEOData <> nil
   then begin
    Dec(VIDEOData.RefCount);
    if VIDEOData.RefCount = 0 then VIDEOData.NullRefTime:=Now;
    end;
finally
TypeSystem.Lock.Leave;
end;
end;
end;
finally
Functionality.Release;
end;
end;





//.  VIDEO-Visualization
{TSystemTVIDEOVisualization}
Constructor TSystemTVIDEOVisualization.Create;
begin
CreateNew(idTVIDEOVisualization,tnTVIDEOVisualization,TTVIDEOVisualizationFunctionality);
if Enabled then Cash:=TTVIDEOVisualizationCash.Create(Self);
end;

Destructor TSystemTVIDEOVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTVIDEOVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTVIDEOVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTVIDEOVisualization.Caching_Start;
begin
end;

procedure TSystemTVIDEOVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTVIDEOVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTVIDEOVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTVIDEOVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TVIDEODataTracker
Constructor TTVIDEOVisualizationVIDEODataTracker.Create(pCash: TTVIDEOVisualizationCash);
begin
Cash:=pCash;
Inherited Create(false);
end;

Destructor TTVIDEOVisualizationVIDEODataTracker.Destroy;
begin
Inherited;
end;

procedure TTVIDEOVisualizationVIDEODataTracker.Execute;
const
  Interval = 300; //. 300 ms
  MaxNullRefTime = 1/(3600*24); //. 1 sec
var
  ptrItem: pointer;
begin
with Cash do
repeat
  try
  TypeSystem.Lock.Enter;
  try
  ptrItem:=FItems;
  while ptrItem <> nil do with TItemTVIDEOVisualizationCash(ptrItem^) do begin
    if (VIDEOData <> nil) AND (VIDEOData.RefCount = 0) AND ((Now-VIDEOData.NullRefTime) > MaxNullRefTime)
     then begin
      VIDEOData.Destroy;
      VIDEOData:=nil;
      end;
    ptrItem:=ptrNext;
    end;
  finally
  TypeSystem.Lock.Leave;
  end;
  except
    end;
  //.
  Sleep(Interval);
until Terminated;
end;

//. TTVIDEOVisualizationCash
Constructor TTVIDEOVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
VIDEODataTracker:=TTVIDEOVisualizationVIDEODataTracker.Create(Self);
end;

destructor TTVIDEOVisualizationCash.Destroy;
begin
VIDEODataTracker.Free;
Empty;
Inherited;
end;

procedure TTVIDEOVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTVIDEOVisualizationCash(ptrDelItem^).ptrNext;
  TItemTVIDEOVisualizationCash(ptrDelItem^).VIDEOData.Free;
  FreeMem(ptrDelItem,SizeOf(TItemTVIDEOVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTVIDEOVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
begin
if List.Count = 0 then Exit; //. ->
for I:=0 to List.Count-1 do begin
  GetMem(ptrNewItem,SizeOf(TItemTVIDEOVisualizationCash));
  try
  FillChar(ptrNewItem^,SizeOf(TItemTVIDEOVisualizationCash), 0);
  with TItemTVIDEOVisualizationCash(ptrNewItem^) do begin
  idObj:=Integer(List[I]);
  VIDEOData:=nil;
  end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  TItemTVIDEOVisualizationCash(ptrNewItem^).ptrNext:=FItems;
  FItems:=ptrNewItem;
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
end;


procedure TTVIDEOVisualizationCash.Update;
begin
Empty;
end;

function TTVIDEOVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTVIDEOVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTVIDEOVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTVIDEOVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTVIDEOVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTVIDEOVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTVIDEOVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

procedure TTVIDEOVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  begin
  with TItemTVIDEOVisualizationCash(ptrItem^) do begin
  //. updating item
  VIDEOData.Free;
  VIDEOData:=nil;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTVIDEOVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTVIDEOVisualizationCash), 0);
  with TItemTVIDEOVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  VIDEOData:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTVIDEOVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTVIDEOVisualizationCash), 0);
    with TItemTVIDEOVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    VIDEOData:=nil;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTVIDEOVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTVIDEOVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTVIDEOVisualizationCash(ptrDelItem^).ptrNext;
    TItemTVIDEOVisualizationCash(ptrDelItem^).VIDEOData.Free;
    FreeMem(ptrDelItem,SizeOf(TItemTVIDEOVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTVIDEOVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTVIDEOVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);
var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTVIDEOVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTVIDEOVisualizationCash.LoadItems(Node: IXMLDOMNode);
var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTVIDEOVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTVIDEOVisualizationCash), 0);
  with TItemTVIDEOVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  VIDEOData:=nil;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;


//. TVIDEOVisualizationUpdating
Constructor TVIDEOVisualizationUpdating.Create(pReflecting: TReflecting; pFunctionality: TComponentFunctionality);
begin
Functionality:=pFunctionality;
Functionality.AddRef;
Reflecting:=pReflecting;
FreeOnTerminate:=true;
Inherited Create(false);
end;

Destructor TVIDEOVisualizationUpdating.Destroy;
begin
Inherited;
end;

procedure TVIDEOVisualizationUpdating.Execute;
var
  Interval: integer;
  ptrItem: pointer;
  LastReflectionHashCode: Double;
  FrameDataPtr: pointer;
  DDib: THandle;
  BMP: TBitmap;
begin
try
with TVIDEOVisualizationFunctionality(Functionality) do begin
//. get VIDEO data provider
TypeSystem.Lock.Enter;
try
ptrItem:=TSystemTVIDEOVisualization(TypeSystem).Cash.GetPtrItem(idObj);
if ptrItem <> nil
 then with TItemTVIDEOVisualizationCash(ptrItem^) do
  if VIDEOData <> nil
   then Inc(VIDEOData.RefCount)
   else VIDEOData:=TVIDEOData.Create(Space,TypeSystem.idType,idObj,DataServer,ObjectID)
finally
TypeSystem.Lock.Leave;
end;
try
//. updating
BMP:=TBitmap.Create;
try
LastReflectionHashCode:=Reflecting.Reflector.ReflectionWindow.HashCode;
Interval:=100;
repeat
  TypeSystem.Lock.Enter;
  try
  if LastReflectionHashCode = Reflecting.Reflector.ReflectionWindow.HashCode
   then begin
    ptrItem:=TSystemTVIDEOVisualization(TypeSystem).Cash.GetPtrItem(idObj);
    if ptrItem <> nil
     then with TItemTVIDEOVisualizationCash(ptrItem^),Reflecting.Reflector do begin
      DDib:=DrawDibOpen;
      try
      VIDEOData.Lock.Enter;
      try
      if VIDEOData.FrameBuffer <> nil
       then begin
        SafeArrayAccessData(VIDEOData.FrameBuffer,FrameDataPtr);
        try
        Canvas.Lock;
        try
        SetGraphicsMode(Canvas.Handle,GM_ADVANCED);
        SetWorldTransForm(Canvas.Handle,XF);
        try
        DrawDIBDraw(DDib,Canvas.Handle, 0,0,Round(_Width),Round(b), FrameDataPtr,Pointer(Integer(FrameDataPtr)+TBitmapInfoHeader(FrameDataPtr^).biSize), 0,0,TBitmapInfoHeader(FrameDataPtr^).biWidth,TBitmapInfoHeader(FrameDataPtr^).biHeight, 0);
        {/// + freezing with BMP do begin
        Handle:=0;
        Width:=TBitmapInfoHeader(FrameDataPtr^).biWidth;
        Height:=TBitmapInfoHeader(FrameDataPtr^).biHeight;
        DrawDIBDraw(DDib,Canvas.Handle, 0,0,Width,Height, FrameDataPtr,Pointer(Integer(FrameDataPtr)+TBitmapInfoHeader(FrameDataPtr^).biSize), 0,0,Width,Height, 0);
        end;
        DrawUsingGDIPus(Canvas.Handle, BMP,0,0,Round(_Width),Round(b));}
        finally
        ModifyWorldTransForm(Canvas.Handle,XF,MWT_IDENTITY);
        end;
        finally
        Canvas.UnLock;
        end;
        finally
        SafeArrayUnAccessData(VIDEOData.FrameBuffer);
        end;
        end;
      Interval:=VIDEOData.Interval-1;
      finally
      VIDEOData.Lock.Leave;
      end;
      finally
      DrawDibClose(DDib);
      DrawDibStop(DDib);
      end;
      end;
    end;
  finally
  TypeSystem.Lock.Leave;
  end;
  //.
  Sleep(Interval);
until Terminated;
finally
BMP.Destroy;
end;
finally
//. release VIDEO data provider
TypeSystem.Lock.Enter;
try
ptrItem:=TSystemTVIDEOVisualization(TypeSystem).Cash.GetPtrItem(idObj);
if ptrItem <> nil
 then with TItemTVIDEOVisualizationCash(ptrItem^) do
  if VIDEOData <> nil
   then begin
    Dec(VIDEOData.RefCount);
    if VIDEOData.RefCount = 0 then VIDEOData.NullRefTime:=Now;
    end;
finally
TypeSystem.Lock.Leave;
end;
end;
end;
finally
Functionality.Release;
end;
end;





//. Oriented OPP-Visualization
{TSystemTOPPVisualization}
Constructor TSystemTOPPVisualization.Create;
begin
CreateNew(idTOPPVisualization,tnTOPPVisualization,TTOPPVisualizationFunctionality);
if Enabled then Cash:=TTOPPVisualizationCash.Create(Self);
end;

Destructor TSystemTOPPVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTOPPVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTOPPVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTOPPVisualization.Caching_Start;
begin
end;

procedure TSystemTOPPVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTOPPVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTOPPVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTOPPVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTOPPVisualizationCash
Constructor TTOPPVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTOPPVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTOPPVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTOPPVisualizationCash(ptrDelItem^).ptrNext;
  TItemTOPPVisualizationCash(ptrDelItem^).PropsPanel.Free;
  TItemTOPPVisualizationCash(ptrDelItem^).PropsPanelBMP.Free;
  FreeMem(ptrDelItem,SizeOf(TItemTOPPVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOPPVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TOPPVisualizationFunctionality;
  DS: TMemoryStream;
  CDT: TComponentFileType;
begin
if List.Count = 0 then Exit; //. ->
for I:=0 to List.Count-1 do begin
  GetMem(ptrNewItem,SizeOf(TItemTOPPVisualizationCash));
  try
  FillChar(ptrNewItem^,SizeOf(TItemTOPPVisualizationCash), 0);
  with TItemTOPPVisualizationCash(ptrNewItem^) do begin
  PropsPanel_idTObj:=0;
  PropsPanel_idObj:=0;
  PropsPanel:=nil;
  PropsPanelBMP:=nil;
  flLock:=false;
  LockReflector:=nil;
  CF:=TOPPVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
  try
  idObj:=CF.idObj;
  CF.GetParams(PropsPanel_idTObj,PropsPanel_idObj);
  finally
  CF.Release;
  end;
  end;
  except
    On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
    end;
  TypeSystem.Lock.Enter;
  try
  TItemTOPPVisualizationCash(ptrNewItem^).ptrNext:=FItems;
  FItems:=ptrNewItem;
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
end;


procedure TTOPPVisualizationCash.Update;
begin
Empty;
end;

function TTOPPVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTOPPVisualizationCash.GetPanel(const pidObj: integer; const Reflector: TAbstractReflector;  out oPropsPanel: TForm; out oPropsPanelBMP: TBitmap): boolean;
var
  ptrItem: pointer;
  Message: TMessage;
begin
Result:=false;
TypeSystem.Lock.Enter;
try
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil then Exit; //. ->
with TItemTOPPVisualizationCash(ptrItem^) do begin
if (PropsPanel = nil)
 then
  if (PropsPanel_idObj <> 0) AND (fmPropsPanelRepository <> nil)
   then with Message do begin
    Msg:=WM_GETPROPSPANEL;
    WParam:=PropsPanel_idTObj;
    LParam:=PropsPanel_idObj;
    if (GetCurrentThreadID <> MainThreadID)
     then SendMessage(fmPropsPanelRepository.Handle, Msg,WParam,LParam)
     else fmPropsPanelRepository.wmGetPropsPanel(Message);
    PropsPanel:=fmPropsPanelRepository.NewPropsPanel;
    PropsPanelBMP:=fmPropsPanelRepository.NewPropsPanelBMP;
    end
   else
    Exit; //. ->
flLock:=true;
LockReflector:=Reflector;
oPropsPanel:=PropsPanel;
oPropsPanelBMP:=PropsPanelBMP;
end;
finally
TypeSystem.Lock.Leave;
end;
Result:=true;
end;

function TTOPPVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTOPPVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTOPPVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTOPPVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOPPVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOPPVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTOPPVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TOPPVisualizationFunctionality;
  begin
  with TItemTOPPVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TOPPVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(PropsPanel_idTObj,PropsPanel_idObj);
  finally
  CF.Release;
  end;
  PropsPanel.Free;
  PropsPanel:=nil;
  PropsPanelBMP.Free;
  PropsPanelBMP:=nil;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTOPPVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOPPVisualizationCash), 0);
  with TItemTOPPVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  PropsPanel_idTObj:=0;
  PropsPanel_idObj:=0;
  PropsPanel:=nil;
  PropsPanelBMP:=nil;
  flLock:=false;
  LockReflector:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTOPPVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTOPPVisualizationCash), 0);
    with TItemTOPPVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    PropsPanel_idTObj:=0;
    PropsPanel_idObj:=0;
    PropsPanel:=nil;
    PropsPanelBMP:=nil;
    flLock:=false;
    LockReflector:=nil;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTOPPVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TOPPVisualizationFunctionality;
  begin
  with TItemTOPPVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TOPPVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(PropsPanel_idTObj,PropsPanel_idObj);
  finally
  CF.Release;
  end;
  PropsPanel.Free;
  PropsPanel:=nil;
  PropsPanelBMP.Free;
  PropsPanelBMP:=nil;
  end;
  end;

  procedure MoveItem(const Item: TItemTOPPVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTOPPVisualizationCash(ptrItem^) do begin
  PropsPanel.Free;
  PropsPanel:=nil;
  PropsPanelBMP.Free;
  PropsPanelBMP:=nil;
  //.
  PropsPanel_idTObj:=Item.PropsPanel_idTObj;
  PropsPanel_idObj:=Item.PropsPanel_idObj;
  end;
  end;

var
  Item: TItemTOPPVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTOPPVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOPPVisualizationCash), 0);
  with TItemTOPPVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  PropsPanel_idTObj:=0;
  PropsPanel_idObj:=0;
  PropsPanel:=nil;
  PropsPanelBMP:=nil;
  flLock:=false;
  LockReflector:=nil;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTOPPVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTOPPVisualizationCash), 0);
    with TItemTOPPVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    PropsPanel_idTObj:=0;
    PropsPanel_idObj:=0;
    PropsPanel:=nil;
    PropsPanelBMP:=nil;
    flLock:=false;
    LockReflector:=nil;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOPPVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTOPPVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTOPPVisualizationCash(ptrDelItem^).ptrNext;
    TItemTOPPVisualizationCash(ptrDelItem^).PropsPanel.Free;
    TItemTOPPVisualizationCash(ptrDelItem^).PropsPanelBMP.Free;
    FreeMem(ptrDelItem,SizeOf(TItemTOPPVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTOPPVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOPPVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);
var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOPPVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('PropsPanel_idTObj'); PropNode.nodeTypedValue:=PropsPanel_idTObj; ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('PropsPanel_idObj');  PropNode.nodeTypedValue:=PropsPanel_idObj;  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOPPVisualizationCash.LoadItems(Node: IXMLDOMNode);
var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _PropsPanel_idTObj: integer;
  _PropsPanel_idObj: integer;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _PropsPanel_idTObj:=ItemNode.selectSingleNode('PropsPanel_idTObj').nodeTypedValue;
  _PropsPanel_idObj:=ItemNode.selectSingleNode('PropsPanel_idObj').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTOPPVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOPPVisualizationCash), 0);
  with TItemTOPPVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  PropsPanel_idTObj:=_PropsPanel_idTObj;
  PropsPanel_idObj:=_PropsPanel_idObj;
  //.
  PropsPanel:=nil;
  PropsPanelBMP:=nil;
  flLock:=false;
  LockReflector:=nil;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;





//. MODELServer
{TSystemTMODELServer}
Constructor TSystemTMODELServer.Create;
begin
CreateNew(idTMODELServer,tnTMODELServer,TTMODELServerFunctionality);
end;





//. CoReference
{TSystemTCoReference}
Constructor TSystemTCoReference.Create;
begin
CreateNew(idTCoReference,tnTCoReference,TTCoReferenceFunctionality);
end;





//. Positioner
{TSystemTPositioner}
Constructor TSystemTPositioner.Create;
begin
CreateNew(idTPositioner,tnTPositioner,TTPositionerFunctionality);
end;





//. Oriented WMF-Visualization
{TSystemTOrientedWMFVisualization}
Constructor TSystemTOrientedWMFVisualization.Create;
begin
CreateNew(idTOrientedWMFVisualization,tnTOrientedWMFVisualization,TTOrientedWMFVisualizationFunctionality);
if Enabled then Cash:=TTOrientedWMFVisualizationCash.Create(Self);
end;

Destructor TSystemTOrientedWMFVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTOrientedWMFVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTOrientedWMFVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTOrientedWMFVisualization.Caching_Start;
begin
end;

procedure TSystemTOrientedWMFVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTOrientedWMFVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTOrientedWMFVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTOrientedWMFVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTOrientedWMFVisualizationCash
Constructor TTOrientedWMFVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTOrientedWMFVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTOrientedWMFVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTOrientedWMFVisualizationCash(ptrDelItem^).ptrNext;
  TItemTOrientedWMFVisualizationCash(ptrDelItem^).WMF.Free;
  FreeMem(ptrDelItem,SizeOf(TItemTOrientedWMFVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedWMFVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TOrientedWMFVisualizationFunctionality;
  DS: TMemoryStream;
  CDT: TComponentFileType;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedWMFVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedWMFVisualizationCash), 0);
    with TItemTOrientedWMFVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    WMF:=nil;
    Width:=0;
    Height:=0;
    Orientation:=0;
    CF:=TOrientedWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetParams(Width,Height,Orientation);
    idDATAFile:=CF.DATAFileID;
    if (idDATAFile <> 0)
     then begin
      if (NOT GetComponentFile(idDATAFile, DS)) then CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
      try
      WMF:=TMetaFile.Create;
      WMF.LoadFromStream(DS);
      finally
      DS.Destroy;
      end;
      end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTOrientedWMFVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedWMFVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedWMFVisualizationCash), 0);
    with TItemTOrientedWMFVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    WMF:=nil;
    Width:=0;
    Height:=0;
    Orientation:=0;
    CF:=TOrientedWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try idDATAFile:=CF.DATAFileID; except on E: EActionsGroup do ; else Raise; end;
    try CF.GetParams(Width,Height,Orientation); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTOrientedWMFVisualizationCash(ItemsList[I]^) do with TOrientedWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    idDATAFile:=DATAFileID;
    with TItemTOrientedWMFVisualizationCash(ItemsList[I]^) do GetParams(Width,Height,Orientation);
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  ActionsGroups.ActionsGroup_Start(ptrActionsGroup);
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then with TItemTOrientedWMFVisualizationCash(ItemsList[I]^) do with TOrientedWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if (idDATAFile <> 0)
     then
      if (GetComponentFile(idDATAFile, DS))
       then
        try
        WMF:=TMetaFile.Create;
        WMF.LoadFromStream(DS);
        finally
        DS.Destroy;
        end
       else try GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize); except on E: EActionsGroup do ; else Raise; end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item WMF of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    finally
    Release;
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then with TItemTOrientedWMFVisualizationCash(ItemsList[I]^) do with TOrientedWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if ((idDATAFile <> 0) AND (WMF = nil))
     then begin
      GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
      try
      WMF:=TMetaFile.Create;
      WMF.LoadFromStream(DS);
      finally
      DS.Destroy;
      end;
      end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item WMF of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTOrientedWMFVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;

procedure TTOrientedWMFVisualizationCash.Update;
begin
Empty;
end;

function TTOrientedWMFVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTOrientedWMFVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTOrientedWMFVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTOrientedWMFVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTOrientedWMFVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedWMFVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOrientedWMFVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTOrientedWMFVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TOrientedWMFVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
  begin
  with TItemTOrientedWMFVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TOrientedWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(Width,Height,Orientation);
  _idDATAFile:=CF.DATAFileID;
  if idDATAFile <> _idDATAFile
   then begin
    //. free last
    FreeAndNil(WMF);
    //.
    if (_idDATAFile <> 0) then if (NOT GetComponentFile(_idDATAFile, DS)) then CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
    idDATAFile:=_idDATAFile;
    try
    WMF:=TMetaFile.Create;
    WMF.LoadFromStream(DS);
    finally
    DS.Destroy;
    end;
    end;
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTOrientedWMFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOrientedWMFVisualizationCash), 0);
  with TItemTOrientedWMFVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  idDATAFile:=0;
  WMF:=nil;
  Width:=0;
  Height:=0;
  Orientation:=0;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedWMFVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedWMFVisualizationCash), 0);
    with TItemTOrientedWMFVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    idDATAFile:=0;
    WMF:=nil;
    Width:=0;
    Height:=0;
    Orientation:=0;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTOrientedWMFVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TOrientedWMFVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
  begin
  with TItemTOrientedWMFVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TOrientedWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(Width,Height,Orientation);
  _idDATAFile:=CF.DATAFileID;
  if (idDATAFile <> _idDATAFile)
   then begin
    //. free last
    FreeAndNil(WMF);
    //.
    if (_idDATAFile <> 0) then if (NOT GetComponentFile(_idDATAFile, DS)) then CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
    idDATAFile:=_idDATAFile;
    try
    WMF:=TMetaFile.Create;
    WMF.LoadFromStream(DS);
    finally
    DS.Destroy;
    end;
    end;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure CopyToItem(const ptrItem: pointer; var Item: TItemTOrientedWMFVisualizationCash);
  begin
  Item:=TItemTOrientedWMFVisualizationCash(ptrItem^);
  //. copy item reference fields
  if (TItemTOrientedWMFVisualizationCash(ptrItem^).WMF <> nil)
   then begin
    Item.WMF:=TMetaFile.Create;
    Item.WMF.Assign(TItemTOrientedWMFVisualizationCash(ptrItem^).WMF);
    end;
  end;

  procedure MoveItem(const Item: TItemTOrientedWMFVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTOrientedWMFVisualizationCash(ptrItem^) do begin
  Width:=Item.Width;
  Height:=Item.Height;
  Orientation:=Item.Orientation;
  if (idDATAFile <> Item.idDATAFile)
   then begin
    FreeAndNil(WMF);
    //.
    WMF:=Item.WMF;
    idDATAFile:=Item.idDATAFile;
    end
   else Item.WMF.Free;
  end;
  end;

  procedure FreeItem(var Item: TItemTOrientedWMFVisualizationCash);
  begin
  FreeAndNil(Item.WMF);
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
  Item: TItemTOrientedWMFVisualizationCash;
begin
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTOrientedWMFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOrientedWMFVisualizationCash), 0);
  with TItemTOrientedWMFVisualizationCash(ptrNewItem^) do begin
  idObj:=pidObj;
  idDATAFile:=0;
  WMF:=nil;
  Width:=0;
  Height:=0;
  Orientation:=0;
  end;
  UpdateItem(ptrNewItem);
  //.
  TypeSystem.Lock.Enter;
  try
  TItemTOrientedWMFVisualizationCash(ptrNewItem^).ptrNext:=FItems;
  FItems:=ptrNewItem;
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
opUpdate: begin
  TypeSystem.Lock.Enter;
  try
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil) then CopyToItem(ptrUpdateItem, Item);
  finally
  TypeSystem.Lock.Leave;
  end;
  if (ptrUpdateItem <> nil)
   then begin    
    UpdateItem(@Item);
    //.
    TypeSystem.Lock.Enter;
    try
    ptrUpdateItem:=GetPtrItem(pidObj);
    if (ptrUpdateItem <> nil)
     then MoveItem(Item,ptrUpdateItem)
     else FreeItem(Item);
    finally
    TypeSystem.Lock.Leave;
    end;
    end
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedWMFVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedWMFVisualizationCash), 0);
    with TItemTOrientedWMFVisualizationCash(ptrNewItem^) do begin
    idObj:=pidObj;
    idDATAFile:=0;
    WMF:=nil;
    Width:=0;
    Height:=0;
    Orientation:=0;
    end;
    UpdateItem(ptrNewItem);
    //.
    TypeSystem.Lock.Enter;
    try
    TItemTOrientedWMFVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
end;

procedure TTOrientedWMFVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTOrientedWMFVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTOrientedWMFVisualizationCash(ptrDelItem^).ptrNext;
    TItemTOrientedWMFVisualizationCash(ptrDelItem^).WMF.Free;
    FreeMem(ptrDelItem,SizeOf(TItemTOrientedWMFVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTOrientedWMFVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTOrientedWMFVisualizationCash.GetComponentFile(const pidDATAFile: integer; out DATA: TMemoryStream): boolean;
var
  ptrItem: pointer;
begin
Result:=false;
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOrientedWMFVisualizationCash(ptrItem^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    DATA:=TMemoryStream.Create;
    if (WMF <> nil)
     then begin
      WMF.SaveToStream(DATA);
      DATA.Position:=0;
      end;
    Result:=true;
    Exit; //. ->
    end;
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedWMFVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetDATA(const WMF: TMetaFile): OLEVariant;
  var
    MS: TMemoryStream;
    DATAPtr: pointer;
  begin
  MS:=TMemoryStream.Create;
  with MS do
  try
  if (WMF <> nil)
   then begin
    WMF.SaveToStream(MS);
    Position:=0;
    end;
  Result:=VarArrayCreate([0,Size-1],varByte);
  DATAPtr:=VarArrayLock(Result);
  try
  Read(DATAPtr^,Size);
  finally
  VarArrayUnLock(Result);
  end;
  finally
  Destroy;
  end;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOrientedWMFVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('idDATAFile');       PropNode.nodeTypedValue:=idDATAFile;    ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Width');            PropNode.nodeTypedValue:=Width;         ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Height');           PropNode.nodeTypedValue:=Height;        ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Orientation');      PropNode.nodeTypedValue:=Orientation;   ItemNode.appendChild(PropNode);
  //.
  PropNode:=Document.CreateElement('WMF');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetDATA(WMF);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedWMFVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetDATA(DATA: Variant; out WMF: TMetaFile);
  var
    DATASize: integer;
    DATAPtr: pointer;
    MS: TMemoryStream;
  begin
  WMF:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    MS:=TMemoryStream.Create;
    with MS do
    try
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    WMF:=TMetaFile.Create;
    WMF.LoadFromStream(MS);
    finally
    Destroy;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(WMF);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _idDATAFile: integer;
  DATA: Variant;
  _Width: Double;
  _Height: Double;
  _Orientation: integer;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _idDATAFile:=ItemNode.selectSingleNode('idDATAFile').nodeTypedValue;
  _Width:=ItemNode.selectSingleNode('Width').nodeTypedValue;
  _Height:=ItemNode.selectSingleNode('Height').nodeTypedValue;
  _Orientation:=ItemNode.selectSingleNode('Orientation').nodeTypedValue;
  DATA:=ItemNode.selectSingleNode('WMF').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTOrientedWMFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOrientedWMFVisualizationCash), 0);
  with TItemTOrientedWMFVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  idDATAFile:=_idDATAFile;
  Width:=_Width;
  Height:=_Height;
  Orientation:=_Orientation;
  SetDATA(DATA, WMF);
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;



//. CELL-Visualization
{TSystemTCELLVisualizationVisualization}
Constructor TSystemTCELLVisualization.Create;
begin
CreateNew(idTCELLVisualization,tnTCELLVisualization,TTCELLVisualizationFunctionality);
ReflectingFigure:=TFigureWinRefl.Create;
ReflectingFigureLock:=TCriticalSection.Create;
if Enabled then Cash:=TTCELLVisualizationCash.Create(Self);
end;

Destructor TSystemTCELLVisualization.Destroy;
begin
Cash.Free;
ReflectingFigureLock.Free;
ReflectingFigure.Free;
Inherited;
end;

procedure TSystemTCELLVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTCELLVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTCELLVisualization.Caching_Start;
begin
end;

procedure TSystemTCELLVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTCELLVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTCELLVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTCELLVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTCELLVisualizationCash
Constructor TTCELLVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTCELLVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTCELLVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTCELLVisualizationCash(ptrDelItem^).ptrNext;
  FreeMem(ptrDelItem,SizeOf(TItemTCELLVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCELLVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TCELLVisualizationFunctionality;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTCELLVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTCELLVisualizationCash), 0);
    with TItemTCELLVisualizationCash(ptrNewItem^) do begin
    ColCount:=0;
    RowCount:=0;
    LineWidth:=0;
    CF:=TCELLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetParams(ColCount,RowCount,LineWidth);
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTCELLVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTCELLVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTCELLVisualizationCash), 0);
    with TItemTCELLVisualizationCash(ptrNewItem^) do begin
    ColCount:=0;
    RowCount:=0;
    LineWidth:=0;
    CF:=TCELLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try CF.GetParams(ColCount,RowCount,LineWidth); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTCELLVisualizationCash(ItemsList[I]^) do with TCELLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    with TItemTCELLVisualizationCash(ItemsList[I]^) do GetParams(ColCount,RowCount,LineWidth);
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTCELLVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;


procedure TTCELLVisualizationCash.Update;
begin
Empty;
end;

function TTCELLVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTCELLVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTCELLVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTCELLVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTCELLVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCELLVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTCELLVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTCELLVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TCELLVisualizationFunctionality;
  begin
  with TItemTCELLVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TCELLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(ColCount,RowCount,LineWidth);
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTCELLVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTCELLVisualizationCash), 0);
  with TItemTCELLVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  ColCount:=0;
  RowCount:=0;
  LineWidth:=0;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTCELLVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTCELLVisualizationCash), 0);
    with TItemTCELLVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    ColCount:=0;
    RowCount:=0;
    LineWidth:=0;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTCELLVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TCELLVisualizationFunctionality;
  begin
  with TItemTCELLVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TCELLVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(ColCount,RowCount,LineWidth);
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTCELLVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTCELLVisualizationCash(ptrItem^) do begin
  ColCount:=Item.ColCount;
  RowCount:=Item.RowCount;
  LineWidth:=Item.LineWidth;
  end;
  end;

var
  Item: TItemTCELLVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTCELLVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTCELLVisualizationCash), 0);
  with TItemTCELLVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  ColCount:=0;
  RowCount:=0;
  LineWidth:=0;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTCELLVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTCELLVisualizationCash), 0);
    with TItemTCELLVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    ColCount:=0;
    RowCount:=0;
    LineWidth:=0;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCELLVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTCELLVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTCELLVisualizationCash(ptrDelItem^).ptrNext;
    FreeMem(ptrDelItem,SizeOf(TItemTCELLVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTCELLVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCELLVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);
var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTCELLVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('ColCount');  PropNode.nodeTypedValue:=ColCount;  ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('RowCount');  PropNode.nodeTypedValue:=RowCount;  ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('LineWidth'); PropNode.nodeTypedValue:=LineWidth; ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTCELLVisualizationCash.LoadItems(Node: IXMLDOMNode);
var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _ColCount: integer;
  _RowCount: integer;
  _LineWidth: Double;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _ColCount:=ItemNode.selectSingleNode('ColCount').nodeTypedValue;
  _RowCount:=ItemNode.selectSingleNode('RowCount').nodeTypedValue;
  _LineWidth:=ItemNode.selectSingleNode('LineWidth').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTCELLVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTCELLVisualizationCash), 0);
  with TItemTCELLVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  ColCount:=_ColCount;
  RowCount:=_RowCount;
  LineWidth:=_LineWidth;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;




//. EllipseVisualization
{TSystemTEllipseVisualizationVisualization}
Constructor TSystemTEllipseVisualization.Create;
begin
CreateNew(idTEllipseVisualization,tnTEllipseVisualization,TTEllipseVisualizationFunctionality);
if Enabled then Cash:=TTEllipseVisualizationCash.Create(Self);
end;

Destructor TSystemTEllipseVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTEllipseVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTEllipseVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTEllipseVisualization.Caching_Start;
begin
end;

procedure TSystemTEllipseVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTEllipseVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTEllipseVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTEllipseVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTEllipseVisualizationCash
Constructor TTEllipseVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTEllipseVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTEllipseVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTEllipseVisualizationCash(ptrDelItem^).ptrNext;
  FreeMem(ptrDelItem,SizeOf(TItemTEllipseVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTEllipseVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TEllipseVisualizationFunctionality;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTEllipseVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTEllipseVisualizationCash), 0);
    with TItemTEllipseVisualizationCash(ptrNewItem^) do begin
    BorderWidth:=0;
    CF:=TEllipseVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    BorderWidth:=CF.BorderWidth;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTEllipseVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTEllipseVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTEllipseVisualizationCash), 0);
    with TItemTEllipseVisualizationCash(ptrNewItem^) do begin
    BorderWidth:=0;
    CF:=TEllipseVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try BorderWidth:=CF.BorderWidth; except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTEllipseVisualizationCash(ItemsList[I]^) do with TEllipseVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    TItemTEllipseVisualizationCash(ItemsList[I]^).BorderWidth:=BorderWidth;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTEllipseVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;


procedure TTEllipseVisualizationCash.Update;
begin
Empty;
end;

function TTEllipseVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTEllipseVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTEllipseVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTEllipseVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTEllipseVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTEllipseVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTEllipseVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTEllipseVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TEllipseVisualizationFunctionality;
  begin
  with TItemTEllipseVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TEllipseVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  BorderWidth:=CF.BorderWidth;
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTEllipseVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTEllipseVisualizationCash), 0);
  with TItemTEllipseVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  BorderWidth:=0;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTEllipseVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTEllipseVisualizationCash), 0);
    with TItemTEllipseVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    BorderWidth:=0;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTEllipseVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TEllipseVisualizationFunctionality;
  begin
  with TItemTEllipseVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TEllipseVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  BorderWidth:=CF.BorderWidth;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTEllipseVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTEllipseVisualizationCash(ptrItem^) do begin
  BorderWidth:=Item.BorderWidth;
  end;
  end;

var
  Item: TItemTEllipseVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTEllipseVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTEllipseVisualizationCash), 0);
  with TItemTEllipseVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  BorderWidth:=0;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTEllipseVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTEllipseVisualizationCash), 0);
    with TItemTEllipseVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    BorderWidth:=0;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTEllipseVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTEllipseVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTEllipseVisualizationCash(ptrDelItem^).ptrNext;
    FreeMem(ptrDelItem,SizeOf(TItemTEllipseVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTEllipseVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTEllipseVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);
var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTEllipseVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('BorderWidth');  PropNode.nodeTypedValue:=BorderWidth;  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTEllipseVisualizationCash.LoadItems(Node: IXMLDOMNode);
var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _BorderWidth: Double;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _BorderWidth:=ItemNode.selectSingleNode('BorderWidth').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTEllipseVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTEllipseVisualizationCash), 0);
  with TItemTEllipseVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  BorderWidth:=_BorderWidth;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;




//. WMF-визуализация
{TSystemTWMFVisualization}
Constructor TSystemTWMFVisualization.Create;
begin
CreateNew(idTWMFVisualization,tnTWMFVisualization,TTWMFVisualizationFunctionality);
if Enabled then Cash:=TTWMFVisualizationCash.Create(Self);
end;

Destructor TSystemTWMFVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTWMFVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTWMFVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTWMFVisualization.Caching_Start;
begin
end;

procedure TSystemTWMFVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTWMFVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTWMFVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTWMFVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTWMFVisualizationCash
Constructor TTWMFVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTWMFVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTWMFVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTWMFVisualizationCash(ptrDelItem^).ptrNext;
  TItemTWMFVisualizationCash(ptrDelItem^).WMF.Free;
  FreeMem(ptrDelItem,SizeOf(TItemTWMFVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTWMFVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TWMFVisualizationFunctionality;
  DS: TMemoryStream;
  CDT: TComponentFileType;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTWMFVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTWMFVisualizationCash), 0);
    with TItemTWMFVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    WMF:=nil;
    CF:=TWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    idDATAFile:=CF.DATAFileID;
    if (idDATAFile <> 0)
     then begin
      if (NOT GetComponentFile(idDATAFile, DS)) then CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
      try
      WMF:=TMetaFile.Create;
      WMF.LoadFromStream(DS);
      finally
      DS.Destroy;
      end;
      end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTWMFVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTWMFVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTWMFVisualizationCash), 0);
    with TItemTWMFVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    WMF:=nil;
    CF:=TWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try idDATAFile:=CF.DATAFileID; except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTWMFVisualizationCash(ItemsList[I]^) do with TWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    idDATAFile:=DATAFileID;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  ActionsGroups.ActionsGroup_Start(ptrActionsGroup);
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then with TItemTWMFVisualizationCash(ItemsList[I]^) do with TWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if (idDATAFile <> 0)
     then
      if (GetComponentFile(idDATAFile, DS))
       then
        try
        WMF:=TMetaFile.Create;
        WMF.LoadFromStream(DS);
        finally
        DS.Destroy;
        end
       else try GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize); except on E: EActionsGroup do ; else Raise; end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item WMF of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    finally
    Release;
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then with TItemTWMFVisualizationCash(ItemsList[I]^) do with TWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if ((idDATAFile <> 0) AND (WMF = nil))
     then begin
      GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
      try
      WMF:=TMetaFile.Create;
      WMF.LoadFromStream(DS);
      finally
      DS.Destroy;
      end;
      end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item WMF of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTWMFVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;


procedure TTWMFVisualizationCash.Update;
begin
Empty;
end;

function TTWMFVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTWMFVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTWMFVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTWMFVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTWMFVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTWMFVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTWMFVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTWMFVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);         
  var
    CF: TWMFVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
  begin
  with TItemTWMFVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  _idDATAFile:=CF.DATAFileID;
  if (idDATAFile <> _idDATAFile)
   then begin
    //. free last
    FreeAndNil(WMF);
    //.
    if (_idDATAFile <> 0) then if (NOT GetComponentFile(_idDATAFile, DS)) then CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
    idDATAFile:=_idDATAFile;
    try
    WMF:=TMetaFile.Create;
    WMF.LoadFromStream(DS);
    finally
    DS.Destroy;
    end;
    end;
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTWMFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTWMFVisualizationCash), 0);
  with TItemTWMFVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  idDATAFile:=0;
  WMF:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTWMFVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTWMFVisualizationCash), 0);
    with TItemTWMFVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    idDATAFile:=0;
    WMF:=nil;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTWMFVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);         
  var
    CF: TWMFVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
  begin
  with TItemTWMFVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TWMFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  _idDATAFile:=CF.DATAFileID;
  if (idDATAFile <> _idDATAFile)
   then begin
    //. free last
    FreeAndNil(WMF);
    //.
    if (_idDATAFile <> 0) then if (NOT GetComponentFile(_idDATAFile, DS)) then CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
    idDATAFile:=_idDATAFile;
    try
    WMF:=TMetaFile.Create;
    WMF.LoadFromStream(DS);
    finally
    DS.Destroy;
    end;
    end;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure CopyToItem(const ptrItem: pointer; var Item: TItemTWMFVisualizationCash);
  begin
  Item:=TItemTWMFVisualizationCash(ptrItem^);
  //. copy item reference fields
  if (TItemTWMFVisualizationCash(ptrItem^).WMF <> nil)
   then begin
    Item.WMF:=TMetaFile.Create;
    Item.WMF.Assign(TItemTWMFVisualizationCash(ptrItem^).WMF);
    end;
  end;

  procedure MoveItem(const Item: TItemTWMFVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTWMFVisualizationCash(ptrItem^) do begin
  if (idDATAFile <> Item.idDATAFile)
   then begin
    FreeAndNil(WMF);
    //.
    WMF:=Item.WMF;
    idDATAFile:=Item.idDATAFile;
    end
   else Item.WMF.Free;
  end;
  end;

  procedure FreeItem(var Item: TItemTWMFVisualizationCash);
  begin
  FreeAndNil(Item.WMF);
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
  Item: TItemTWMFVisualizationCash;
begin
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTWMFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTWMFVisualizationCash), 0);
  with TItemTWMFVisualizationCash(ptrNewItem^) do begin
  idObj:=pidObj;
  idDATAFile:=0;
  WMF:=nil;
  end;
  UpdateItem(ptrNewItem);
  //.
  TypeSystem.Lock.Enter;
  try
  TItemTWMFVisualizationCash(ptrNewItem^).ptrNext:=FItems;
  FItems:=ptrNewItem;
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
opUpdate: begin
  TypeSystem.Lock.Enter;
  try
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil) then CopyToItem(ptrUpdateItem, Item);
  finally
  TypeSystem.Lock.Leave;
  end;
  if (ptrUpdateItem <> nil)
   then begin    
    UpdateItem(@Item);
    //.
    TypeSystem.Lock.Enter;
    try
    ptrUpdateItem:=GetPtrItem(pidObj);
    if (ptrUpdateItem <> nil)
     then MoveItem(Item,ptrUpdateItem)
     else FreeItem(Item);
    finally
    TypeSystem.Lock.Leave;
    end;
    end
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTWMFVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTWMFVisualizationCash), 0);
    with TItemTWMFVisualizationCash(ptrNewItem^) do begin
    idObj:=pidObj;
    idDATAFile:=0;
    WMF:=nil;
    end;
    UpdateItem(ptrNewItem);
    //.
    TypeSystem.Lock.Enter;
    try
    TItemTWMFVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
end;

procedure TTWMFVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTWMFVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTWMFVisualizationCash(ptrDelItem^).ptrNext;
    TItemTWMFVisualizationCash(ptrDelItem^).WMF.Free;
    FreeMem(ptrDelItem,SizeOf(TItemTWMFVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTWMFVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTWMFVisualizationCash.GetComponentFile(const pidDATAFile: integer; out DATA: TMemoryStream): boolean;
var
  ptrItem: pointer;
begin
Result:=false;
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTWMFVisualizationCash(ptrItem^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    DATA:=TMemoryStream.Create;
    if (WMF <> nil)
     then begin
      WMF.SaveToStream(DATA);
      DATA.Position:=0;
      end;
    Result:=true;
    Exit; //. ->
    end;
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTWMFVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetDATA(const WMF: TMetaFile): OLEVariant;
  var
    MS: TMemoryStream;
    DATAPtr: pointer;
  begin
  MS:=TMemoryStream.Create;
  with MS do
  try
  if (WMF <> nil)
   then begin
    WMF.SaveToStream(MS);
    Position:=0;
    end;
  Result:=VarArrayCreate([0,Size-1],varByte);
  DATAPtr:=VarArrayLock(Result);
  try
  Read(DATAPtr^,Size);
  finally
  VarArrayUnLock(Result);
  end;
  finally
  Destroy;
  end;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTWMFVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('idDATAFile');       PropNode.nodeTypedValue:=idDATAFile;    ItemNode.appendChild(PropNode);
  //.
  PropNode:=Document.CreateElement('WMF');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetDATA(WMF);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTWMFVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetDATA(DATA: Variant; out WMF: TMetaFile);
  var
    DATASize: integer;
    DATAPtr: pointer;
    MS: TMemoryStream;
  begin
  WMF:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    MS:=TMemoryStream.Create;
    with MS do
    try
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    WMF:=TMetaFile.Create;
    WMF.LoadFromStream(MS);
    finally
    Destroy;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(WMF);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _idDATAFile: integer;
  DATA: Variant;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _idDATAFile:=ItemNode.selectSingleNode('idDATAFile').nodeTypedValue;
  DATA:=ItemNode.selectSingleNode('WMF').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTWMFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTWMFVisualizationCash), 0);
  with TItemTWMFVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  idDATAFile:=_idDATAFile;
  SetDATA(DATA, WMF);
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;



//. Picture-визуализация
{TSystemTPictureVisualization}
Constructor TSystemTPictureVisualization.Create;
begin
CreateNew(idTPictureVisualization,tnTPictureVisualization,TTPictureVisualizationFunctionality);
if Enabled then Cash:=TTPictureVisualizationCash.Create(Self);
end;

Destructor TSystemTPictureVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTPictureVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTPictureVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTPictureVisualization.Caching_Start;
begin
end;

procedure TSystemTPictureVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTPictureVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTPictureVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTPictureVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTPictureVisualizationCash
Constructor TTPictureVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTPictureVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTPictureVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTPictureVisualizationCash(ptrDelItem^).ptrNext;
  TItemTPictureVisualizationCash(ptrDelItem^).BMP.Free;
  FreeMem(ptrDelItem,SizeOf(TItemTPictureVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPictureVisualizationCash.ConvertDATAToBMP(const DS: TMemoryStream; const CDT: TComponentFileType; out BMP: TBitmap);
var
  JI: TJPEGImage;
begin
case TComponentFileType(CDT) of
cftBMP: begin
  BMP:=TBitmap.Create;
  BMP.LoadFromStream(DS);
  end;
cftJPEG: begin
  JI:=TJPEGImage.Create;
  with JI do
  try
  BMP:=TBitmap.Create;
  if (DS.Size > 0)
   then begin
    JI.LoadFromStream(DS);
    BMP.Canvas.Lock();
    try
    BMP.Assign(JI);
    finally
    BMP.Canvas.Unlock();
    end;
    end;
  finally
  Destroy;
  end;
  end;
else
  Raise Exception.Create('unimplemented picture file type '); //. =>
end;
end;

procedure TTPictureVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TPictureVisualizationFunctionality;
  DS: TMemoryStream;
  CDT: TComponentFileType;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTPictureVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTPictureVisualizationCash), 0);
    with TItemTPictureVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    BMP:=nil;
    VisibleMinScale:=0;
    VisibleMaxScale:=0;
    CF:=TPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetParams(VisibleMinScale,VisibleMaxScale);
    idDATAFile:=CF.DATAFileID;
    if ((idDATAFile <> 0) AND ((VisibleMinScale = 0) AND (VisibleMaxScale = 0)))
     then
      if (GetComponentFile(idDATAFile, DS))
       then
        try
        BMP:=TBitmap.Create;
        BMP.LoadFromStream(DS);
        finally
        DS.Destroy;
        end
       else begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        ConvertDATAToBMP(DS,CDT, BMP);
        finally
        DS.Destroy;
        end;
        end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTPictureVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTPictureVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTPictureVisualizationCash), 0);
    with TItemTPictureVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    BMP:=nil;
    VisibleMinScale:=0;
    VisibleMaxScale:=0;
    CF:=TPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try idDATAFile:=CF.DATAFileID; except on E: EActionsGroup do ; else Raise; end;
    try CF.GetParams(VisibleMinScale,VisibleMaxScale); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTPictureVisualizationCash(ItemsList[I]^) do with TPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    idDATAFile:=DATAFileID;
    with TItemTPictureVisualizationCash(ItemsList[I]^) do GetParams(VisibleMinScale,VisibleMaxScale);
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  ActionsGroups.ActionsGroup_Start(ptrActionsGroup);
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then with TItemTPictureVisualizationCash(ItemsList[I]^) do with TPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if ((idDATAFile <> 0) AND ((VisibleMinScale = 0) AND (VisibleMaxScale = 0)))
     then
      if (GetComponentFile(idDATAFile, DS))
       then
        try
        BMP:=TBitmap.Create;
        BMP.LoadFromStream(DS);
        finally
        DS.Destroy;
        end
       else try GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize); except on E: EActionsGroup do ; else Raise; end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item BMP of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    finally
    Release;
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then with TItemTPictureVisualizationCash(ItemsList[I]^) do with TPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if ((idDATAFile <> 0) AND (BMP = nil) AND ((VisibleMinScale = 0) AND (VisibleMaxScale = 0)))
     then begin
      GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
      try
      ConvertDATAToBMP(DS,CDT, BMP);
      finally
      DS.Destroy;
      end;
      end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item BMP of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTPictureVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;



procedure TTPictureVisualizationCash.Update;
begin
Empty;
end;

function TTPictureVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTPictureVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTPictureVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTPictureVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTPictureVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPictureVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTPictureVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTPictureVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TPictureVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
    JI: TJPEGImage;
  begin 
  with TItemTPictureVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(VisibleMinScale,VisibleMaxScale);
  _idDATAFile:=CF.DATAFileID;
  if idDATAFile <> _idDATAFile
   then begin
    //. free last
    FreeAndNil(BMP);
    //.
    if ((_idDATAFile <> 0) AND ((VisibleMinScale = 0) AND (VisibleMaxScale = 0)))
     then
      if (GetComponentFile(_idDATAFile, DS))
       then
        try
        BMP:=TBitmap.Create;
        BMP.LoadFromStream(DS);
        finally
        DS.Destroy;
        end
       else begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        ConvertDATAToBMP(DS,CDT, BMP);
        finally
        DS.Destroy;
        end;
        end;
    idDATAFile:=_idDATAFile;
    end;
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTPictureVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTPictureVisualizationCash), 0);
  with TItemTPictureVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  idDATAFile:=0;
  BMP:=nil;
  VisibleMinScale:=0;
  VisibleMaxScale:=0;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTPictureVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTPictureVisualizationCash), 0);
    with TItemTPictureVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    idDATAFile:=0;
    BMP:=nil;
    VisibleMinScale:=0;
    VisibleMaxScale:=0;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTPictureVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TPictureVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
    JI: TJPEGImage;
  begin 
  with TItemTPictureVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(VisibleMinScale,VisibleMaxScale);
  _idDATAFile:=CF.DATAFileID;
  if idDATAFile <> _idDATAFile
   then begin
    //. free last
    FreeAndNil(BMP);
    //.
    if ((_idDATAFile <> 0) AND ((VisibleMinScale = 0) AND (VisibleMaxScale = 0)))
     then
      if (GetComponentFile(_idDATAFile, DS))
       then
        try
        BMP:=TBitmap.Create;
        BMP.LoadFromStream(DS);
        finally
        DS.Destroy;
        end
       else begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        ConvertDATAToBMP(DS,CDT, BMP);
        finally
        DS.Destroy;
        end;
        end;
    idDATAFile:=_idDATAFile;
    end;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure CopyToItem(const ptrItem: pointer; var Item: TItemTPictureVisualizationCash);
  var
    MS: TMemoryStream;
  begin
  Item:=TItemTPictureVisualizationCash(ptrItem^);
  //. copy item reference fields
  if (TItemTPictureVisualizationCash(ptrItem^).BMP <> nil)
   then begin
    Item.BMP:=TBitmap.Create;
    MS:=TMemoryStream.Create();
    try
    TItemTPictureVisualizationCash(ptrItem^).BMP.SaveToStream(MS);
    MS.Position:=0;
    Item.BMP.LoadFromStream(MS);
    finally
    MS.Destroy();
    end;
    end;
  end;

  procedure MoveItem(const Item: TItemTPictureVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTPictureVisualizationCash(ptrItem^) do begin
  VisibleMinScale:=Item.VisibleMinScale;
  VisibleMaxScale:=Item.VisibleMaxScale;
  if (idDATAFile <> Item.idDATAFile)
   then begin
    FreeAndNil(BMP);
    //.
    BMP:=Item.BMP;
    idDATAFile:=Item.idDATAFile;
    end
   else Item.BMP.Free;
  end;
  end;

  procedure FreeItem(var Item: TItemTPictureVisualizationCash);
  begin
  FreeAndNil(Item.BMP);
  end;
  
var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
  Item: TItemTPictureVisualizationCash;
begin
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTPictureVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTPictureVisualizationCash), 0);
  with TItemTPictureVisualizationCash(ptrNewItem^) do begin
  idObj:=pidObj;
  idDATAFile:=0;
  BMP:=nil;
  VisibleMinScale:=0;
  VisibleMaxScale:=0;
  end;
  UpdateItem(ptrNewItem);
  //.
  TypeSystem.Lock.Enter;
  try
  TItemTPictureVisualizationCash(ptrNewItem^).ptrNext:=FItems;
  FItems:=ptrNewItem;
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
opUpdate: begin
  TypeSystem.Lock.Enter;
  try
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil) then CopyToItem(ptrUpdateItem, Item);
  finally
  TypeSystem.Lock.Leave;
  end;
  if (ptrUpdateItem <> nil)
   then begin    
    UpdateItem(@Item);
    //.
    TypeSystem.Lock.Enter;
    try
    ptrUpdateItem:=GetPtrItem(pidObj);
    if (ptrUpdateItem <> nil)
     then MoveItem(Item,ptrUpdateItem)
     else FreeItem(Item);
    finally
    TypeSystem.Lock.Leave;
    end;
    end
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTPictureVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTPictureVisualizationCash), 0);
    with TItemTPictureVisualizationCash(ptrNewItem^) do begin
    idObj:=pidObj;
    idDATAFile:=0;
    BMP:=nil;
    VisibleMinScale:=0;
    VisibleMaxScale:=0;
    end;
    UpdateItem(ptrNewItem);
    //.
    TypeSystem.Lock.Enter;
    try
    TItemTPictureVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
end;

procedure TTPictureVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTPictureVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTPictureVisualizationCash(ptrDelItem^).ptrNext;
    TItemTPictureVisualizationCash(ptrDelItem^).BMP.Free;
    FreeMem(ptrDelItem,SizeOf(TItemTPictureVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTPictureVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTPictureVisualizationCash.GetComponentFile(const pidDATAFile: integer; out DATA: TMemoryStream): boolean;
var
  ptrItem: pointer;
begin
Result:=false;
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTPictureVisualizationCash(ptrItem^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    DATA:=TMemoryStream.Create;
    if (BMP <> nil)
     then begin
      BMP.SaveToStream(DATA);
      DATA.Position:=0;
      end;
    Result:=true;
    Exit; //. ->
    end;
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPictureVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetDATA(const BMP: TBitmap): OLEVariant;
  var
    MS: TMemoryStream;
    DATAPtr: pointer;
    JI: TJpegImage;
  begin
  MS:=TMemoryStream.Create;
  with MS do
  try
  if (BMP <> nil)
   then begin
    JI:=TJpegImage.Create;
    try
    BMP.Canvas.Lock();
    try
    JI.Assign(BMP);
    finally
    BMP.Canvas.Unlock();
    end;
    JI.SaveToStream(MS);
    finally
    JI.Destroy;
    end;
    Position:=0;
    end;
  Result:=VarArrayCreate([0,Size-1],varByte);
  DATAPtr:=VarArrayLock(Result);
  try
  Read(DATAPtr^,Size);
  finally
  VarArrayUnLock(Result);
  end;
  finally
  Destroy;
  end;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTPictureVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('idDATAFile');       PropNode.nodeTypedValue:=idDATAFile;      ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('VisibleMinScale');  PropNode.nodeTypedValue:=VisibleMinScale; ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('VisibleMaxScale');  PropNode.nodeTypedValue:=VisibleMaxScale; ItemNode.appendChild(PropNode);
  //.
  PropNode:=Document.CreateElement('DATA');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetDATA(BMP);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPictureVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetDATA(DATA: Variant; out BMP: TBitmap);
  var
    DATASize: integer;
    DATAPtr: pointer;
    MS: TMemoryStream;
    JI: TJpegImage;
  begin
  BMP:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    MS:=TMemoryStream.Create;
    with MS do
    try
    Size:=DATASize;
    Write(DATAPtr^,DATASize);
    Position:=0;
    JI:=TJpegImage.Create;
    try
    JI.LoadFromStream(MS);
    BMP:=TBitmap.Create;
    BMP.Canvas.Lock();
    try
    BMP.Assign(JI);
    finally
    BMP.Canvas.Unlock();
    end;
    finally
    JI.Destroy;
    end;
    finally
    Destroy;
    end;
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeAndNil(BMP);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _idDATAFile: integer;
  _VisibleMinScale: double;
  _VisibleMaxScale: double;
  DATA: Variant;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _idDATAFile:=ItemNode.selectSingleNode('idDATAFile').nodeTypedValue;
  _VisibleMinScale:=ItemNode.selectSingleNode('VisibleMinScale').nodeTypedValue;
  _VisibleMaxScale:=ItemNode.selectSingleNode('VisibleMaxScale').nodeTypedValue;
  DATA:=ItemNode.selectSingleNode('DATA').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTPictureVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTPictureVisualizationCash), 0);
  with TItemTPictureVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  idDATAFile:=_idDATAFile;
  VisibleMinScale:=_VisibleMinScale;
  VisibleMaxScale:=_VisibleMaxScale;
  SetDATA(DATA, BMP);
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;





//. RoundVisualization
{TSystemTRoundVisualizationVisualization}
Constructor TSystemTRoundVisualization.Create;
begin
CreateNew(idTRoundVisualization,tnTRoundVisualization,TTRoundVisualizationFunctionality);
if Enabled then Cash:=TTRoundVisualizationCash.Create(Self);
end;

Destructor TSystemTRoundVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTRoundVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTRoundVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTRoundVisualization.Caching_Start;
begin
end;

procedure TSystemTRoundVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTRoundVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTRoundVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTRoundVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTRoundVisualizationCash
Constructor TTRoundVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTRoundVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTRoundVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTRoundVisualizationCash(ptrDelItem^).ptrNext;
  FreeMem(ptrDelItem,SizeOf(TItemTRoundVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTRoundVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TRoundVisualizationFunctionality;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin 
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTRoundVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTRoundVisualizationCash), 0);
    with TItemTRoundVisualizationCash(ptrNewItem^) do begin
    BorderWidth:=0;
    CF:=TRoundVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    BorderWidth:=CF.BorderWidth;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTRoundVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTRoundVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTRoundVisualizationCash), 0);
    with TItemTRoundVisualizationCash(ptrNewItem^) do begin
    BorderWidth:=0;
    CF:=TRoundVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try BorderWidth:=CF.BorderWidth; except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTRoundVisualizationCash(ItemsList[I]^) do with TRoundVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    TItemTRoundVisualizationCash(ItemsList[I]^).BorderWidth:=BorderWidth;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTRoundVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;


procedure TTRoundVisualizationCash.Update;
begin
Empty;
end;

function TTRoundVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTRoundVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTRoundVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTRoundVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTRoundVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTRoundVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTRoundVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTRoundVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TRoundVisualizationFunctionality;
  begin
  with TItemTRoundVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TRoundVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  BorderWidth:=CF.BorderWidth;
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTRoundVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTRoundVisualizationCash), 0);
  with TItemTRoundVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  BorderWidth:=0;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTRoundVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTRoundVisualizationCash), 0);
    with TItemTRoundVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    BorderWidth:=0;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTRoundVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TRoundVisualizationFunctionality;
  begin
  with TItemTRoundVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TRoundVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  BorderWidth:=CF.BorderWidth;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTRoundVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTRoundVisualizationCash(ptrItem^) do begin
  BorderWidth:=Item.BorderWidth;
  end;
  end;

var
  Item: TItemTRoundVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTRoundVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTRoundVisualizationCash), 0);
  with TItemTRoundVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  BorderWidth:=0;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTRoundVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTRoundVisualizationCash), 0);
    with TItemTRoundVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    BorderWidth:=0;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTRoundVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTRoundVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTRoundVisualizationCash(ptrDelItem^).ptrNext;
    FreeMem(ptrDelItem,SizeOf(TItemTRoundVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTRoundVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTRoundVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);
var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTRoundVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('BorderWidth');  PropNode.nodeTypedValue:=BorderWidth;  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTRoundVisualizationCash.LoadItems(Node: IXMLDOMNode);
var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _BorderWidth: Double;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _BorderWidth:=ItemNode.selectSingleNode('BorderWidth').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTRoundVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTRoundVisualizationCash), 0);
  with TItemTRoundVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  BorderWidth:=_BorderWidth;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;









{TSystemTGeodesyPoint}
Constructor TSystemTGeodesyPoint.Create;
begin
CreateNew(idTGeodesyPoint,tnTGeodesyPoint,TTGeodesyPointFunctionality);
CrdSysCache:=TTSystemTGeodesyPointCrdSysCash.Create(Self);
end;

Destructor TSystemTGeodesyPoint.Destroy;
begin
CrdSysCache.Free;
Inherited;
end;

procedure TSystemTGeodesyPoint.Initialize;
begin
end;


{TTSystemTGeodesyPointCrdSysCash}
Constructor TTSystemTGeodesyPointCrdSysCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
CrdSysList:=TList.Create;
end;

destructor TTSystemTGeodesyPointCrdSysCash.Destroy;
begin
Empty;
CrdSysList.Free;
Inherited;
end;

procedure TTSystemTGeodesyPointCrdSysCash.Empty;
var
  I,J: integer;
  ptrCrdSys: pointer;
  ptrCrdSysItem: pointer;
begin
TypeSystem.Lock.Enter;
try
for I:=0 to CrdSysList.Count-1 do begin
  ptrCrdSys:=CrdSysList[I];
  CrdSysList[I]:=nil;
  with TItemOfTSystemTGeodesyPointCrdSysCash(ptrCrdSys^) do begin
  for J:=0 to GeodesyPointsList.Count-1 do begin
    ptrCrdSysItem:=GeodesyPointsList[J];
    FreeMem(ptrCrdSysItem,SizeOf(TGeodesyPointStruct));
    end;
  GeodesyPointsList.Destroy();
  end;
  FreeMem(ptrCrdSys,SizeOf(TItemOfTSystemTGeodesyPointCrdSysCash));
  end;
CrdSysList.Clear();
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTSystemTGeodesyPointCrdSysCash.Update;
begin
end;

procedure TTSystemTGeodesyPointCrdSysCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);
begin
end;

procedure TTSystemTGeodesyPointCrdSysCash.RemoveItem(const pidObj: integer);
begin
end;

procedure TTSystemTGeodesyPointCrdSysCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);
var
  ItemNode: IXMLDOMElement;
  I,J: integer;
  CrdSyssNode: IXMLDOMElement;
  CrdSysNode: IXMLDOMElement;
  GeodesyPointsNode: IXMLDOMElement;
  GeodesyPointNode: IXMLDOMElement;
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
//. create CrdSystems item
CrdSyssNode:=Document.CreateElement('CrdSystems');
for I:=0 to CrdSysList.Count-1 do with TItemOfTSystemTGeodesyPointCrdSysCash(CrdSysList[I]^) do begin
  //. create CrdSys item
  CrdSysNode:=Document.CreateElement('ID'+IntToStr(idCrdSys));
  GeodesyPointsNode:=Document.CreateElement('GeodesyPoints');
  for J:=0 to GeodesyPointsList.Count-1 do with TGeodesyPointStruct(GeodesyPointsList[J]^) do begin
    GeodesyPointNode:=Document.CreateElement('Item');
    PropNode:=Document.CreateElement('X');     PropNode.nodeTypedValue:=X;          GeodesyPointNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('Y');     PropNode.nodeTypedValue:=Y;          GeodesyPointNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('Lat');   PropNode.nodeTypedValue:=Latitude;   GeodesyPointNode.appendChild(PropNode);
    PropNode:=Document.CreateElement('Long');  PropNode.nodeTypedValue:=Longitude;  GeodesyPointNode.appendChild(PropNode);
    GeodesyPointsNode.appendChild(GeodesyPointNode);
    end;
  CrdSysNode.appendChild(GeodesyPointsNode);
  CrdSyssNode.appendChild(CrdSysNode);
  end;
ParentNode.parentNode.appendChild(CrdSyssNode);
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTSystemTGeodesyPointCrdSysCash.LoadItems(Node: IXMLDOMNode);
var
  CrdSyssNode: IXMLDOMNode;
  I,J: integer;
  CrdSysNode: IXMLDOMNode;
  _idCrdSys: integer;
  ptrCrdSys: pointer;
  GeodesyPointsNode: IXMLDOMNode;
  GeodesyPointNode: IXMLDOMNode;
  GP: TGeodesyPointStruct;
  ptrCrdSysItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Empty;
CrdSyssNode:=Node.parentNode.selectSingleNode('CrdSystems');
if (CrdSyssNode = nil) then Exit; //. ->
for I:=0 to CrdSyssNode.childNodes.length-1 do begin
  CrdSysNode:=CrdSyssNode.childNodes[I];
  //. get id
  _idCrdSys:=ExtractID(CrdSysNode.NodeName);
  //. create new crd sys
  GetMem(ptrCrdSys,SizeOf(TItemOfTSystemTGeodesyPointCrdSysCash));
  with TItemOfTSystemTGeodesyPointCrdSysCash(ptrCrdSys^) do begin
  idCrdSys:=_idCrdSys;
  GeodesyPointsList:=TList.Create;
  //.
  GeodesyPointsNode:=CrdSysNode.selectSingleNode('GeodesyPoints');
  for J:=0 to GeodesyPointsNode.childNodes.length-1 do begin
    GeodesyPointNode:=GeodesyPointsNode.childNodes[J];
    //.
    GP.X:=GeodesyPointNode.selectSingleNode('X').nodeTypedValue;
    GP.Y:=GeodesyPointNode.selectSingleNode('Y').nodeTypedValue;
    GP.Latitude:=GeodesyPointNode.selectSingleNode('Lat').nodeTypedValue;
    GP.Longitude:=GeodesyPointNode.selectSingleNode('Long').nodeTypedValue;
    //.
    GetMem(ptrCrdSysItem,SizeOf(TGeodesyPointStruct));
    TGeodesyPointStruct(ptrCrdSysItem^):=GP;
    GeodesyPointsList.Add(ptrCrdSysItem);
    end;
  end;
  //.
  CrdSysList.Add(ptrCrdSys);
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTSystemTGeodesyPointCrdSysCash.CrdSys_AddGeodesyPoints(const pidCrdSys: integer; Points: TByteArray);
var
  I,J: integer;
  flCrdSysFound: boolean;
  ptrCrdSys: pointer;
  ptrCrdSysItem: pointer;
  ptrPoint: pointer;
  PointsCount: integer;
  GP: TGeodesyPointStruct;
  flPointFound: boolean;
begin
TypeSystem.Lock.Enter;
try
flCrdSysFound:=false;
for I:=0 to CrdSysList.Count-1 do begin
  ptrCrdSys:=CrdSysList[I];
  if (TItemOfTSystemTGeodesyPointCrdSysCash(ptrCrdSys^).idCrdSys = pidCrdSys)
   then begin
    flCrdSysFound:=true;
    Break; //. >
    end;
  end;
if (NOT flCrdSysFound)
 then begin
  GetMem(ptrCrdSys,SizeOf(TItemOfTSystemTGeodesyPointCrdSysCash));
  with TItemOfTSystemTGeodesyPointCrdSysCash(ptrCrdSys^) do begin
  idCrdSys:=pidCrdSys;
  GeodesyPointsList:=TList.Create;
  end;
  CrdSysList.Add(ptrCrdSys);
  end;
//.
with TItemOfTSystemTGeodesyPointCrdSysCash(ptrCrdSys^) do begin
ptrPoint:=@Points[0];
PointsCount:=(Length(Points) DIV SizeOf(TGeodesyPointStruct));
for I:=0 to PointsCount-1 do begin
  GP:=TGeodesyPointStruct(ptrPoint^);
  flPointFound:=false;
  for J:=0 to GeodesyPointsList.Count-1 do with TGeodesyPointStruct(GeodesyPointsList[J]^) do begin
    if (NOT ((X = GP.X) AND (Y = GP.Y) AND (Latitude = GP.Latitude) AND (Longitude = GP.Longitude)))
     then begin
      if (((X = GP.X) AND (Y = GP.Y)) OR ((Latitude = GP.Latitude) AND (Longitude = GP.Longitude)))
       then begin
        TGeodesyPointStruct(GeodesyPointsList[J]^):=GP;
        flPointFound:=true;
        end;
      end
     else begin
      flPointFound:=true;
      Break; //. >
      end;
    end;
  if (NOT flPointFound)
   then begin
    GetMem(ptrCrdSysItem,SizeOf(TGeodesyPointStruct));
    TGeodesyPointStruct(ptrCrdSysItem^):=GP;
    GeodesyPointsList.Add(ptrCrdSysItem);
    end;
  //. next point
  Inc(DWord(ptrPoint),SizeOf(TGeodesyPointStruct));
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTSystemTGeodesyPointCrdSysCash.CrdSys_GetNearestGeoPoints(const idCrdSys: integer; const pLatitude,pLongitude: double; const PointsCount: integer; out Points: TByteArray): boolean;
var
  I,J: integer;
  flCrdSysFound: boolean;
  ptrCrdSys: pointer;
  MinQdDist,QdDist: Extended;
  PointsSize: integer;
  MinPos: integer;
  MinDiff,Diff: Extended;
begin
Result:=false;
TypeSystem.Lock.Enter;
try
flCrdSysFound:=false;
for I:=0 to CrdSysList.Count-1 do begin
  ptrCrdSys:=CrdSysList[I];
  if (TItemOfTSystemTGeodesyPointCrdSysCash(ptrCrdSys^).idCrdSys = idCrdSys)
   then begin
    flCrdSysFound:=true;
    Break; //. >
    end;
  end;
if (NOT flCrdSysFound OR (TItemOfTSystemTGeodesyPointCrdSysCash(ptrCrdSys^).GeodesyPointsList.Count < PointsCount)) then Exit; //. ->
SetLength(Points,PointsCount*SizeOf(TGeodesyPointStruct));
PointsSize:=0;
with TItemOfTSystemTGeodesyPointCrdSysCash(ptrCrdSys^) do
for I:=0 to GeodesyPointsList.Count-1 do with TGeodesyPointStruct(GeodesyPointsList[I]^) do begin
  QdDist:=sqr(Latitude-pLatitude)+sqr(Longitude-pLongitude);
  MinPos:=-1;
  MinDiff:=0;
  for J:=0 to PointsSize-1 do with TGeodesyPointStruct(Pointer(@Points[J*SizeOf(TGeodesyPointStruct)])^) do begin
    MinQdDist:=sqr(Latitude-pLatitude)+sqr(Longitude-pLongitude);
    Diff:=(QdDist-MinQdDist);
    if (Diff < MinDiff)
     then begin
      MinPos:=J;
      MinDiff:=Diff;
      end;
    end;
  if (MinPos <> -1)
   then TGeodesyPointStruct(Pointer(@Points[MinPos*SizeOf(TGeodesyPointStruct)])^):=TGeodesyPointStruct(GeodesyPointsList[I]^)
   else
    if (PointsSize < PointsCount)
     then begin
      TGeodesyPointStruct(Pointer(@Points[PointsSize*SizeOf(TGeodesyPointStruct)])^):=TGeodesyPointStruct(GeodesyPointsList[I]^);
      Inc(PointsSize);
      end;
  end;
finally
TypeSystem.Lock.Leave;
end;
Result:=true;
end;

function TTSystemTGeodesyPointCrdSysCash.CrdSys_GetNearestXYPoints(const idCrdSys: integer; const pX,pY: double; const PointsCount: integer; out Points: TByteArray): boolean;
var
  I,J: integer;
  flCrdSysFound: boolean;
  ptrCrdSys: pointer;
  MinQdDist,QdDist: Extended;
  PointsSize: integer;
  MinPos: integer;
  MinDiff,Diff: Extended;
begin
Result:=false;
TypeSystem.Lock.Enter;
try
flCrdSysFound:=false;
for I:=0 to CrdSysList.Count-1 do begin
  ptrCrdSys:=CrdSysList[I];
  if (TItemOfTSystemTGeodesyPointCrdSysCash(ptrCrdSys^).idCrdSys = idCrdSys)
   then begin
    flCrdSysFound:=true;
    Break; //. >
    end;
  end;
if (NOT flCrdSysFound OR (TItemOfTSystemTGeodesyPointCrdSysCash(ptrCrdSys^).GeodesyPointsList.Count < PointsCount)) then Exit; //. ->
SetLength(Points,PointsCount*SizeOf(TGeodesyPointStruct));
PointsSize:=0;
with TItemOfTSystemTGeodesyPointCrdSysCash(ptrCrdSys^) do
for I:=0 to GeodesyPointsList.Count-1 do with TGeodesyPointStruct(GeodesyPointsList[I]^) do begin
  QdDist:=sqr(X-pX)+sqr(Y-pY);
  MinPos:=-1;
  MinDiff:=0;
  for J:=0 to PointsSize-1 do with TGeodesyPointStruct(Pointer(@Points[J*SizeOf(TGeodesyPointStruct)])^) do begin
    MinQdDist:=sqr(X-pX)+sqr(Y-pY);
    Diff:=(QdDist-MinQdDist);
    if (Diff < MinDiff)
     then begin
      MinPos:=J;
      MinDiff:=Diff;
      end;
    end;
  if (MinPos <> -1)
   then TGeodesyPointStruct(Pointer(@Points[MinPos*SizeOf(TGeodesyPointStruct)])^):=TGeodesyPointStruct(GeodesyPointsList[I]^)
   else
    if (PointsSize < PointsCount)
     then begin
      TGeodesyPointStruct(Pointer(@Points[PointsSize*SizeOf(TGeodesyPointStruct)])^):=TGeodesyPointStruct(GeodesyPointsList[I]^);
      Inc(PointsSize);
      end;
  end;
finally
TypeSystem.Lock.Leave;
end;
Result:=true;
end;




//. Private-Area визуализация
{TSystemTPrivateAreaVisualization}
Constructor TSystemTPrivateAreaVisualization.Create;
begin
CreateNew(idTPrivateAreaVisualization,tnTPrivateAreaVisualization,TTPrivateAreaVisualizationFunctionality);
if Enabled then Cash:=TTPrivateAreaVisualizationCash.Create(Self);
end;

Destructor TSystemTPrivateAreaVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTPrivateAreaVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;


//. TTPrivateAreaVisualizationCash
Constructor TTPrivateAreaVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTPrivateAreaVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTPrivateAreaVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTPrivateAreaVisualizationCash(ptrDelItem^).ptrNext;
  FreeMem(ptrDelItem,SizeOf(TItemTPrivateAreaVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPrivateAreaVisualizationCash.Update;
begin
end;

function TTPrivateAreaVisualizationCash.GetOwner(const idObj: integer; var vidTOwner,vidOwner: integer): boolean;
var
  ptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=false;
ptrItem:=GetPtrItem(idObj);
if ptrItem = nil then Exit; //. ->
with TItemTPrivateAreaVisualizationCash(ptrItem^) do begin
if (idTOwner = 0) OR (idOwner = 0) then Exit; //. ->
vidTOwner:=idTOwner;
vidOwner:=idOwner;
end;
Result:=true;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTPrivateAreaVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTPrivateAreaVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTPrivateAreaVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTPrivateAreaVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPrivateAreaVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    ptrObj: TPtr;
    ptrVisObj: TPtr;
  begin
  with TItemTPrivateAreaVisualizationCash(ptrItem^) do begin
  if true /// - NOT Space.GlobalSpaceCashDataProvider.T2DVisualizationCash_GetItemByIDObj(idType,idObj, ptrObj,idTOwner,idOwner,ptrVisObj)
   then begin
    idTOwner:=0;
    idOwner:=0;
    end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTPrivateAreaVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTPrivateAreaVisualizationCash), 0);
  with TItemTPrivateAreaVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTPrivateAreaVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTPrivateAreaVisualizationCash), 0);
    with TItemTPrivateAreaVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPrivateAreaVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTPrivateAreaVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTPrivateAreaVisualizationCash(ptrDelItem^).ptrNext;
    FreeMem(ptrDelItem,SizeOf(TItemTPrivateAreaVisualizationCash));
    //. remove all the same items Exit;
    end
   else
    ptrptrDelItem:=@TItemTPrivateAreaVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPrivateAreaVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);
var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTPrivateAreaVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('idTOwner');  PropNode.nodeTypedValue:=idTOwner;  ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('idOwner');   PropNode.nodeTypedValue:=idOwner;   ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTPrivateAreaVisualizationCash.LoadItems(Node: IXMLDOMNode);
var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _idTOwner: integer;
  _idOwner: integer;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _idTOwner:=ItemNode.selectSingleNode('idTOwner').nodeTypedValue;
  _idOwner:=ItemNode.selectSingleNode('idOwner').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTPrivateAreaVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTPrivateAreaVisualizationCash), 0);
  with TItemTPrivateAreaVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  idTOwner:=_idTOwner;
  idOwner:=_idOwner;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;




//. HyperText
{TSystemTHyperText}
Constructor TSystemTHyperText.Create;
begin
CreateNew(idTHyperText,tnTHyperText,TTHyperTextFunctionality);
end;





//. ComponentsFindService
{TSystemTComponentsFindService}
Constructor TSystemTComponentsFindService.Create;
begin
CreateNew(idTComponentsFindService,tnTComponentsFindService,TTComponentsFindServiceFunctionality);
end;





//. UsersService
{TSystemTUsersService}
Constructor TSystemTUsersService.Create;
begin
CreateNew(idTUsersService,tnTUsersService,TTUsersServiceFunctionality);
end;





//. TransportService
{TSystemTTransportService}
Constructor TSystemTTransportService.Create;
begin
CreateNew(idTTransportService,tnTTransportService,TTTransportServiceFunctionality);
end;





//. MarketService
{TSystemTMarketService}
Constructor TSystemTMarketService.Create;
begin
CreateNew(idTMarketService,tnTMarketService,TTMarketServiceFunctionality);
end;





//. TelecomService
{TSystemTTelecomService}
Constructor TSystemTTelecomService.Create;
begin
CreateNew(idTTelecomService,tnTTelecomService,TTTelecomServiceFunctionality);
end;





// Визуализация
{TSystemTWNDVisualizationVisualization}
Constructor TSystemTWNDVisualization.Create;
begin
CreateNew(idTWNDVisualization,tnTWNDVisualization,TTWNDVisualizationFunctionality);
if Enabled then Cash:=TTWNDVisualizationCash.Create(Self);
end;

Destructor TSystemTWNDVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTWNDVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTWNDVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTWNDVisualization.Caching_Start;
begin
end;

procedure TSystemTWNDVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTWNDVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTWNDVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTWNDVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTWNDVisualizationCash
Constructor TTWNDVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTWNDVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTWNDVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTWNDVisualizationCash(ptrDelItem^).ptrNext;
  FreeMem(TItemTWNDVisualizationCash(ptrDelItem^).DATAPtr,TItemTWNDVisualizationCash(ptrDelItem^).DATASize);
  FreeMem(ptrDelItem,SizeOf(TItemTWNDVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTWNDVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TWNDVisualizationFunctionality;
  DS: TMemoryStream;
  CDT: TComponentFileType;
  BMPDATAStream: TMemoryStream;
  JI: TJPEGImage;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTWNDVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTWNDVisualizationCash), 0);
    with TItemTWNDVisualizationCash(ptrNewItem^) do begin
    DATAPtr:=nil;
    DATASize:=0;
    CF:=TWNDVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
    try
    case TComponentFileType(CDT) of
    cftBMP: begin
      BMPDATAStream:=TMemoryStream.Create;
      try
      BMPDATAStream.LoadFromStream(DS);
      GetMem(DATAPtr,BMPDATAStream.Size);
      DATASize:=BMPDATAStream.Size;
      BMPDATAStream.Read(DATAPtr^,DATASize);
      finally
      BMPDATAStream.Destroy;
      end;
      end;
    cftJPEG: begin
      JI:=TJPEGImage.Create;
      with JI do
      try
      with TBitmap.Create do
      try
      if DS.Size > 0
       then begin
        JI.LoadFromStream(DS);
        Canvas.Lock();
        try
        Assign(JI);
        finally
        Canvas.Unlock();
        end;
        end;
      BMPDATAStream:=TMemoryStream.Create;
      try
      SaveToStream(BMPDATAStream);
      BMPDATAStream.Position:=0;
      GetMem(DATAPtr,BMPDATAStream.Size);
      DATASize:=BMPDATAStream.Size;
      BMPDATAStream.Read(DATAPtr^,DATASize);
      finally
      BMPDATAStream.Destroy;
      end;
      finally
      Destroy;
      end;
      finally
      Destroy;
      end;
      end;
    else
      Raise Exception.Create('unimplemented picture file type '); //. =>
    end;
    finally
    DS.Destroy;
    end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTWNDVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTWNDVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTWNDVisualizationCash), 0);
    with TItemTWNDVisualizationCash(ptrNewItem^) do begin
    DATAPtr:=nil;
    DATASize:=0;
    CF:=TWNDVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTWNDVisualizationCash(ItemsList[I]^) do with TWNDVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
    try
    with TItemTWNDVisualizationCash(ItemsList[I]^) do
    case TComponentFileType(CDT) of
    cftBMP: begin
      BMPDATAStream:=TMemoryStream.Create;
      try
      BMPDATAStream.LoadFromStream(DS);
      GetMem(DATAPtr,BMPDATAStream.Size);
      DATASize:=BMPDATAStream.Size;
      BMPDATAStream.Read(DATAPtr^,DATASize);
      finally
      BMPDATAStream.Destroy;
      end;
      end;
    cftJPEG: begin
      JI:=TJPEGImage.Create;
      with JI do
      try
      with TBitmap.Create do
      try
      if DS.Size > 0
       then begin
        JI.LoadFromStream(DS);
        Canvas.Lock();
        try
        Assign(JI);
        finally
        Canvas.Unlock();
        end;
        end;
      BMPDATAStream:=TMemoryStream.Create;
      try
      SaveToStream(BMPDATAStream);
      BMPDATAStream.Position:=0;
      GetMem(DATAPtr,BMPDATAStream.Size);
      DATASize:=BMPDATAStream.Size;
      BMPDATAStream.Read(DATAPtr^,DATASize);
      finally
      BMPDATAStream.Destroy;
      end;
      finally
      Destroy;
      end;
      finally
      Destroy;
      end;
      end;
    else
      Raise Exception.Create('unsupported picture file type'); //. =>
    end;
    finally
    DS.Destroy;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTWNDVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;


procedure TTWNDVisualizationCash.Update;
begin
Empty;
end;

function TTWNDVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTWNDVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTWNDVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTWNDVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTWNDVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTWNDVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTWNDVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTWNDVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TWNDVisualizationFunctionality;
    DS: TMemoryStream;
    CDT: TComponentFileType;
    BMPDATAStream: TMemoryStream;
    JI: TJPEGImage;
  begin
  with TItemTWNDVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TWNDVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  //. free last
  if DATAPtr <> nil
   then begin
    FreeMem(DATAPtr,DATASize);
    DATAPtr:=nil;
    end;
  //.
  CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
  try
  case TComponentFileType(CDT) of
  cftBMP: begin
    BMPDATAStream:=TMemoryStream.Create;
    try
    BMPDATAStream.LoadFromStream(DS);
    GetMem(DATAPtr,BMPDATAStream.Size);
    DATASize:=BMPDATAStream.Size;
    BMPDATAStream.Read(DATAPtr^,DATASize);
    finally
    BMPDATAStream.Destroy;
    end;
    end;
  cftJPEG: begin
    JI:=TJPEGImage.Create;
    with JI do
    try
    with TBitmap.Create do
    try
    if DS.Size > 0
     then begin
      JI.LoadFromStream(DS);
      Canvas.Lock();
      try
      Assign(JI);
      finally
      Canvas.Unlock();
      end;
      end;
    BMPDATAStream:=TMemoryStream.Create;
    try
    SaveToStream(BMPDATAStream);
    BMPDATAStream.Position:=0;
    GetMem(DATAPtr,BMPDATAStream.Size);
    DATASize:=BMPDATAStream.Size;
    BMPDATAStream.Read(DATAPtr^,DATASize);
    finally
    BMPDATAStream.Destroy;
    end;
    finally
    Destroy;
    end;
    finally
    Destroy;
    end;
    end;
  else
    Raise Exception.Create('unimplemented picture file type '); //. =>
  end;
  finally
  DS.Destroy;
  end;
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTWNDVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTWNDVisualizationCash), 0);
  with TItemTWNDVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  DATAPtr:=nil;
  DATASize:=0;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTWNDVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTWNDVisualizationCash), 0);
    with TItemTWNDVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    DATAPtr:=nil;
    DATASize:=0;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTWNDVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TWNDVisualizationFunctionality;
    DS: TMemoryStream;
    CDT: TComponentFileType;
    BMPDATAStream: TMemoryStream;
    JI: TJPEGImage;
  begin
  with TItemTWNDVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TWNDVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  //. free last
  if DATAPtr <> nil
   then begin
    FreeMem(DATAPtr,DATASize);
    DATAPtr:=nil;
    end;
  //.
  CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
  try
  case TComponentFileType(CDT) of
  cftBMP: begin
    BMPDATAStream:=TMemoryStream.Create;
    try
    BMPDATAStream.LoadFromStream(DS);
    GetMem(DATAPtr,BMPDATAStream.Size);
    DATASize:=BMPDATAStream.Size;
    BMPDATAStream.Read(DATAPtr^,DATASize);
    finally
    BMPDATAStream.Destroy;
    end;
    end;
  cftJPEG: begin
    JI:=TJPEGImage.Create;
    with JI do
    try
    with TBitmap.Create do
    try
    if DS.Size > 0
     then begin
      JI.LoadFromStream(DS);
      Canvas.Lock();
      try
      Assign(JI);
      finally
      Canvas.Unlock();
      end;
      end;
    BMPDATAStream:=TMemoryStream.Create;
    try
    SaveToStream(BMPDATAStream);
    BMPDATAStream.Position:=0;
    GetMem(DATAPtr,BMPDATAStream.Size);
    DATASize:=BMPDATAStream.Size;
    BMPDATAStream.Read(DATAPtr^,DATASize);
    finally
    BMPDATAStream.Destroy;
    end;
    finally
    Destroy;
    end;
    finally
    Destroy;
    end;
    end;
  else
    Raise Exception.Create('unimplemented picture file type '); //. =>
  end;
  finally
  DS.Destroy;
  end;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTWNDVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTWNDVisualizationCash(ptrItem^) do begin
  if DATAPtr <> nil
   then begin
    FreeMem(DATAPtr,DATASize);
    DATAPtr:=nil;
    end;
  //.
  DATAPtr:=Item.DATAPtr;
  DATASize:=Item.DATASize;
  end;
  end;

var
  Item: TItemTWNDVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTWNDVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTWNDVisualizationCash), 0);
  with TItemTWNDVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  DATAPtr:=nil;
  DATASize:=0;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTWNDVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTWNDVisualizationCash), 0);
    with TItemTWNDVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    DATAPtr:=nil;
    DATASize:=0;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTWNDVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTWNDVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTWNDVisualizationCash(ptrDelItem^).ptrNext;
    FreeMem(TItemTWNDVisualizationCash(ptrDelItem^).DATAPtr,TItemTWNDVisualizationCash(ptrDelItem^).DATASize);
    FreeMem(ptrDelItem,SizeOf(TItemTWNDVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTWNDVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTWNDVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetDATA(const Ptr: pointer; const Size: integer): OLEVariant;
  var
    DATAPtr: pointer;
  begin
  if (Ptr <> nil)
   then begin
    Result:=VarArrayCreate([0,Size-1],varByte);
    DATAPtr:=VarArrayLock(Result);
    try
    Move(Ptr^,DATAPtr^,Size);
    finally
    VarArrayUnLock(Result);
    end;
    end
   else Result:=null;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTWNDVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('DATA');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetDATA(DATAPtr,DATASize);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTWNDVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetDATA(DATA: Variant; out Ptr: pointer; out Size: integer);
  var
    DATASize: integer;
    DATAPtr: pointer;
  begin
  Ptr:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    Size:=DATASize;
    GetMem(Ptr,Size);
    Move(DATAPtr^,Ptr^,Size);
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeMem(Ptr,Size);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  DATA: Variant;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  DATA:=ItemNode.selectSingleNode('DATA').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTWNDVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTWNDVisualizationCash), 0);
  with TItemTWNDVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  SetDATA(DATA, DATAPtr,DATASize);
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;




// визуализация
{TSystemTMRKVisualizationVisualization}
Constructor TSystemTMRKVisualization.Create;
begin
CreateNew(idTMRKVisualization,tnTMRKVisualization,TTMRKVisualizationFunctionality);
if Enabled then Cash:=TTMRKVisualizationCash.Create(Self);
end;

Destructor TSystemTMRKVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTMRKVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTMRKVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTMRKVisualization.Caching_Start;
begin
end;

procedure TSystemTMRKVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTMRKVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTMRKVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTMRKVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTMRKVisualizationCash
Constructor TTMRKVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTMRKVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTMRKVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTMRKVisualizationCash(ptrDelItem^).ptrNext;
  FreeMem(TItemTMRKVisualizationCash(ptrDelItem^).DATAPtr,TItemTMRKVisualizationCash(ptrDelItem^).DATASize);
  FreeMem(ptrDelItem,SizeOf(TItemTMRKVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTMRKVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TMRKVisualizationFunctionality;
  Al: integer;
  DS: TMemoryStream;
  CDT: TComponentFileType;
  BMPDATAStream: TMemoryStream;
  JI: TJPEGImage;
  ptrActionsGroup: pointer;
  ItemsLIst: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTMRKVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTMRKVisualizationCash), 0);
    with TItemTMRKVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    DATAPtr:=nil;
    DATASize:=0;
    Align:=mvaLT;
    BindingPointIndex:=0;
    CF:=TMRKVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetParams(Al,BindingPointIndex); Align:=TMRKVisualizationAlign(Al);
    idDATAFile:=CF.DATAFileID;
    if (idDATAFile <> 0)
     then
      if (GetComponentFile(idDATAFile, DS))
       then
        try
        GetMem(DATAPtr,DS.Size);
        DATASize:=DS.Size;
        DS.Read(DATAPtr^,DATASize);
        finally
        DS.Destroy;
        end
       else begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        case TComponentFileType(CDT) of
        cftBMP: begin
          BMPDATAStream:=TMemoryStream.Create;
          try
          BMPDATAStream.LoadFromStream(DS);
          GetMem(DATAPtr,BMPDATAStream.Size);
          DATASize:=BMPDATAStream.Size;
          BMPDATAStream.Read(DATAPtr^,DATASize);
          finally
          BMPDATAStream.Destroy;
          end;
          end;
        cftJPEG: begin
          JI:=TJPEGImage.Create;
          with JI do
          try
          with TBitmap.Create do
          try
          if DS.Size > 0
           then begin
            JI.LoadFromStream(DS);
            Canvas.Lock();
            try
            Assign(JI);
            finally
            Canvas.Unlock();
            end;
            end;
          BMPDATAStream:=TMemoryStream.Create;
          try
          SaveToStream(BMPDATAStream);
          BMPDATAStream.Position:=0;
          GetMem(DATAPtr,BMPDATAStream.Size);
          DATASize:=BMPDATAStream.Size;
          BMPDATAStream.Read(DATAPtr^,DATASize);
          finally
          BMPDATAStream.Destroy;
          end;
          finally
          Destroy;
          end;
          finally
          Destroy;
          end;
          end;
        else
          Raise Exception.Create('unimplemented picture file type '); //. =>
        end;
        finally
        DS.Destroy;
        end;
        end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTMRKVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin 
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTMRKVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTMRKVisualizationCash), 0);
    with TItemTMRKVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    DATAPtr:=nil;
    DATASize:=0;
    Align:=mvaLT;
    BindingPointIndex:=0;
    CF:=TMRKVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try idDATAFile:=CF.DATAFileID; except on E: EActionsGroup do ; else Raise; end;
    try CF.GetParams(Al,BindingPointIndex); Align:=TMRKVisualizationAlign(Al); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTMRKVisualizationCash(ItemsList[I]^) do with TMRKVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    idDATAFile:=DATAFileID;
    with TItemTMRKVisualizationCash(ItemsList[I]^) do begin GetParams(Al,BindingPointIndex); Align:=TMRKVisualizationAlign(Al); end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  ActionsGroups.ActionsGroup_Start(ptrActionsGroup);
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then with TItemTMRKVisualizationCash(ItemsList[I]^) do with TMRKVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if (idDATAFile <> 0)
     then
      if (GetComponentFile(idDATAFile, DS))
       then
        try
        GetMem(DATAPtr,DS.Size);
        TItemTMRKVisualizationCash(ItemsList[I]^).DATASize:=DS.Size;
        DS.Read(DATAPtr^,TItemTMRKVisualizationCash(ItemsList[I]^).DATASize);
        finally
        DS.Destroy;
        end
       else try GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize); except on E: EActionsGroup do ; else Raise; end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item DATAFile of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(ItemsList[I]))+') could not be prepared for caching',E.Message);
      end;
    finally
    Release;
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then with TItemTMRKVisualizationCash(ItemsList[I]^) do with TMRKVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if ((idDATAFile <> 0) AND (DATAPtr = nil))
     then begin
      GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
      try
      case TComponentFileType(CDT) of
      cftBMP: begin
        BMPDATAStream:=TMemoryStream.Create;
        try
        BMPDATAStream.LoadFromStream(DS);
        GetMem(DATAPtr,BMPDATAStream.Size);
        TItemTMRKVisualizationCash(ItemsList[I]^).DATASize:=BMPDATAStream.Size;
        BMPDATAStream.Read(DATAPtr^,TItemTMRKVisualizationCash(ItemsList[I]^).DATASize);
        finally
        BMPDATAStream.Destroy;
        end;
        end;
      cftJPEG: begin
        JI:=TJPEGImage.Create;
        with JI do
        try
        with TBitmap.Create do
        try
        if DS.Size > 0
         then begin
          JI.LoadFromStream(DS);
          Canvas.Lock();
          try
          Assign(JI);
          finally
          Canvas.Unlock();
          end;
          end;
        BMPDATAStream:=TMemoryStream.Create;
        try
        SaveToStream(BMPDATAStream);
        BMPDATAStream.Position:=0;
        GetMem(DATAPtr,BMPDATAStream.Size);
        TItemTMRKVisualizationCash(ItemsList[I]^).DATASize:=BMPDATAStream.Size;
        BMPDATAStream.Read(DATAPtr^,TItemTMRKVisualizationCash(ItemsList[I]^).DATASize);
        finally
        BMPDATAStream.Destroy;
        end;
        finally
        Destroy;
        end;
        finally
        Destroy;
        end;
        end;
      else
        Raise Exception.Create('unimplemented picture file type '); //. =>
      end;
      finally
      DS.Destroy;
      end;
      end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTMRKVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;



procedure TTMRKVisualizationCash.Update;
begin
Empty;
end;

function TTMRKVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTMRKVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTMRKVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTMRKVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTMRKVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTMRKVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTMRKVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTMRKVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TMRKVisualizationFunctionality;
    Al: integer;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
    BMPDATAStream: TMemoryStream;
    JI: TJPEGImage;
  begin
  with TItemTMRKVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TMRKVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(Al,BindingPointIndex); Align:=TMRKVisualizationAlign(Al);
  _idDATAFile:=CF.DATAFileID;
  if idDATAFile <> _idDATAFile
   then begin
    //. free last
    if DATAPtr <> nil
     then begin
      FreeMem(DATAPtr,DATASize);
      DATAPtr:=nil;
      end;
    //.
    if (_idDATAFile <> 0)
     then
      if (GetComponentFile(_idDATAFile, DS))
       then
        try
        GetMem(DATAPtr,DS.Size);
        DATASize:=DS.Size;
        DS.Read(DATAPtr^,DATASize);
        finally
        DS.Destroy;
        end
       else begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        case TComponentFileType(CDT) of
        cftBMP: begin
          BMPDATAStream:=TMemoryStream.Create;
          try
          BMPDATAStream.LoadFromStream(DS);
          GetMem(DATAPtr,BMPDATAStream.Size);
          DATASize:=BMPDATAStream.Size;
          BMPDATAStream.Read(DATAPtr^,DATASize);
          finally
          BMPDATAStream.Destroy;
          end;
          end;
        cftJPEG: begin
          JI:=TJPEGImage.Create;
          with JI do
          try
          with TBitmap.Create do
          try
          if DS.Size > 0
           then begin
            JI.LoadFromStream(DS);
            Canvas.Lock();
            try
            Assign(JI);
            finally
            Canvas.Unlock();
            end;
            end;
          BMPDATAStream:=TMemoryStream.Create;
          try
          SaveToStream(BMPDATAStream);
          BMPDATAStream.Position:=0;
          GetMem(DATAPtr,BMPDATAStream.Size);
          DATASize:=BMPDATAStream.Size;
          BMPDATAStream.Read(DATAPtr^,DATASize);
          finally
          BMPDATAStream.Destroy;
          end;
          finally
          Destroy;
          end;
          finally
          Destroy;
          end;
          end;
        else
          Raise Exception.Create('unimplemented picture file type '); //. =>
        end;
        finally
        DS.Destroy;
        end;
        end;
    idDATAFile:=_idDATAFile;
    end;
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTMRKVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTMRKVisualizationCash), 0);
  with TItemTMRKVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  idDATAFile:=0;
  DATAPtr:=nil;
  DATASize:=0;
  Align:=mvaLT;
  BindingPointIndex:=0;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTMRKVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTMRKVisualizationCash), 0);
    with TItemTMRKVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    idDATAFile:=0;
    DATAPtr:=nil;
    DATASize:=0;
    Align:=mvaLT;
    BindingPointIndex:=0;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTMRKVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TMRKVisualizationFunctionality;
    Al: integer;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
    BMPDATAStream: TMemoryStream;
    JI: TJPEGImage;
  begin
  with TItemTMRKVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TMRKVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(Al,BindingPointIndex); Align:=TMRKVisualizationAlign(Al);
  _idDATAFile:=CF.DATAFileID;
  if idDATAFile <> _idDATAFile
   then begin
    //. free last
    if DATAPtr <> nil
     then begin
      FreeMem(DATAPtr,DATASize);
      DATAPtr:=nil;
      end;
    //.
    if (_idDATAFile <> 0)
     then
      if (GetComponentFile(_idDATAFile, DS))
       then
        try
        GetMem(DATAPtr,DS.Size);
        DATASize:=DS.Size;
        DS.Read(DATAPtr^,DATASize);
        finally
        DS.Destroy;
        end
       else begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        case TComponentFileType(CDT) of
        cftBMP: begin
          BMPDATAStream:=TMemoryStream.Create;
          try
          BMPDATAStream.LoadFromStream(DS);
          GetMem(DATAPtr,BMPDATAStream.Size);
          DATASize:=BMPDATAStream.Size;
          BMPDATAStream.Read(DATAPtr^,DATASize);
          finally
          BMPDATAStream.Destroy;
          end;
          end;
        cftJPEG: begin
          JI:=TJPEGImage.Create;
          with JI do
          try
          with TBitmap.Create do
          try
          if DS.Size > 0
           then begin
            JI.LoadFromStream(DS);
            Canvas.Lock();
            try
            Assign(JI);
            finally
            Canvas.Unlock();
            end;
            end;
          BMPDATAStream:=TMemoryStream.Create;
          try
          SaveToStream(BMPDATAStream);
          BMPDATAStream.Position:=0;
          GetMem(DATAPtr,BMPDATAStream.Size);
          DATASize:=BMPDATAStream.Size;
          BMPDATAStream.Read(DATAPtr^,DATASize);
          finally
          BMPDATAStream.Destroy;
          end;
          finally
          Destroy;
          end;
          finally
          Destroy;
          end;
          end;
        else
          Raise Exception.Create('unimplemented picture file type '); //. =>
        end;
        finally
        DS.Destroy;
        end;
        end;
    idDATAFile:=_idDATAFile;
    end;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure CopyToItem(const ptrItem: pointer; var Item: TItemTMRKVisualizationCash);
  begin
  Item:=TItemTMRKVisualizationCash(ptrItem^);
  //. copy item reference fields
  if (TItemTMRKVisualizationCash(ptrItem^).DATAPtr <> nil)
   then begin
    GetMem(Item.DATAPtr,TItemTMRKVisualizationCash(ptrItem^).DATASize);
    Move(TItemTMRKVisualizationCash(ptrItem^).DATAPtr^,Item.DATAPtr^,TItemTMRKVisualizationCash(ptrItem^).DATASize);
    end;
  end;

  procedure MoveItem(const Item: TItemTMRKVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTMRKVisualizationCash(ptrItem^) do begin
  if (idDATAFile <> Item.idDATAFile)
   then begin
    if (DATAPtr <> nil)
     then begin
      FreeMem(DATAPtr,DATASize);
      DATAPtr:=nil;
      end;
    //.
    DATAPtr:=Item.DATAPtr;
    DATASize:=Item.DATASize;
    idDATAFile:=Item.idDATAFile;
    end
   else
    if (Item.DATAPtr <> nil)
     then FreeMem(Item.DATAPtr,Item.DATASize);
  //.
  Align:=Item.Align;
  BindingPointIndex:=Item.BindingPointIndex;
  end;
  end;

  procedure FreeItem(var Item: TItemTMRKVisualizationCash);
  begin
  with Item do
  if (DATAPtr <> nil) then FreeMem(DATAPtr,DATASize);
  end;
  
var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
  Item: TItemTMRKVisualizationCash;
begin
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTMRKVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTMRKVisualizationCash), 0);
  with TItemTMRKVisualizationCash(ptrNewItem^) do begin
  idObj:=pidObj;
  idDATAFile:=0;
  DATAPtr:=nil;
  DATASize:=0;
  Align:=mvaLT;
  BindingPointIndex:=0;
  end;
  UpdateItem(ptrNewItem);
  //.
  TypeSystem.Lock.Enter;
  try
  TItemTMRKVisualizationCash(ptrNewItem^).ptrNext:=FItems;
  FItems:=ptrNewItem;
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
opUpdate: begin
  TypeSystem.Lock.Enter;
  try
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil) then CopyToItem(ptrUpdateItem, Item);
  finally
  TypeSystem.Lock.Leave;
  end;
  if (ptrUpdateItem <> nil)
   then begin    
    UpdateItem(@Item);
    //.
    TypeSystem.Lock.Enter;
    try
    ptrUpdateItem:=GetPtrItem(pidObj);
    if (ptrUpdateItem <> nil)
     then MoveItem(Item,ptrUpdateItem)
     else FreeItem(Item);
    finally
    TypeSystem.Lock.Leave;
    end;
    end
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTMRKVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTMRKVisualizationCash), 0);
    with TItemTMRKVisualizationCash(ptrNewItem^) do begin
    idObj:=pidObj;
    idDATAFile:=0;
    DATAPtr:=nil;
    DATASize:=0;
    Align:=mvaLT;
    BindingPointIndex:=0;
    end;
    UpdateItem(ptrNewItem);
    //.
    TypeSystem.Lock.Enter;
    try
    TItemTMRKVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
end;

procedure TTMRKVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTMRKVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTMRKVisualizationCash(ptrDelItem^).ptrNext;
    FreeMem(TItemTMRKVisualizationCash(ptrDelItem^).DATAPtr,TItemTMRKVisualizationCash(ptrDelItem^).DATASize);
    FreeMem(ptrDelItem,SizeOf(TItemTMRKVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTMRKVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTMRKVisualizationCash.GetComponentFile(const pidDATAFile: integer; out DATA: TMemoryStream): boolean;
var
  ptrItem: pointer;
begin
Result:=false;
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTMRKVisualizationCash(ptrItem^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    DATA:=TMemoryStream.Create;
    if (DATAPtr <> nil)
     then begin
      DATA.Write(DATAPtr^,DATASize);
      DATA.Position:=0;
      end;
    Result:=true;
    Exit; //. ->
    end;
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTMRKVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetDATA(const Ptr: pointer; const Size: integer): OLEVariant;
  var
    DATAPtr: pointer;
  begin
  if (Ptr <> nil)
   then begin
    Result:=VarArrayCreate([0,Size-1],varByte);
    DATAPtr:=VarArrayLock(Result);
    try
    Move(Ptr^,DATAPtr^,Size);
    finally
    VarArrayUnLock(Result);
    end;
    end
   else Result:=null;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTMRKVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('idDATAFile');        PropNode.nodeTypedValue:=idDATAFile;        ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Align');             PropNode.nodeTypedValue:=Align;             ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('BindingPointIndex'); PropNode.nodeTypedValue:=BindingPointIndex; ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('DATA');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetDATA(DATAPtr,DATASize);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTMRKVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetDATA(DATA: Variant; out Ptr: pointer; out Size: integer);
  var
    DATASize: integer;
    DATAPtr: pointer;
  begin
  Ptr:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    Size:=DATASize;
    GetMem(Ptr,Size);
    Move(DATAPtr^,Ptr^,Size);
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeMem(Ptr,Size);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _idDATAFile: integer;
  _Align: TMRKVisualizationAlign;
  _BindingPointIndex: integer;
  DATA: Variant;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _idDATAFile:=ItemNode.selectSingleNode('idDATAFile').nodeTypedValue;
  _Align:=ItemNode.selectSingleNode('Align').nodeTypedValue;
  _BindingPointIndex:=ItemNode.selectSingleNode('BindingPointIndex').nodeTypedValue;
  DATA:=ItemNode.selectSingleNode('DATA').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTMRKVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTMRKVisualizationCash), 0);
  with TItemTMRKVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  idDATAFile:=_idDATAFile;
  Align:=_Align;
  BindingPointIndex:=_BindingPointIndex;
  SetDATA(DATA, DATAPtr,DATASize);
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;




// Визуализация
{TSystemTOrientedPictureVisualization}
Constructor TSystemTOrientedPictureVisualization.Create;
begin
CreateNew(idTOrientedPictureVisualization,tnTOrientedPictureVisualization,TTOrientedPictureVisualizationFunctionality);
if Enabled then Cash:=TTOrientedPictureVisualizationCash.Create(Self);
end;

Destructor TSystemTOrientedPictureVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTOrientedPictureVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTOrientedPictureVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTOrientedPictureVisualization.Caching_Start;
begin
end;

procedure TSystemTOrientedPictureVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTOrientedPictureVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTOrientedPictureVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTOrientedPictureVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTOrientedPictureVisualizationCash
Constructor TTOrientedPictureVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTOrientedPictureVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTOrientedPictureVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTOrientedPictureVisualizationCash(ptrDelItem^).ptrNext;
  FreeMem(TItemTOrientedPictureVisualizationCash(ptrDelItem^).DATAPtr,TItemTOrientedPictureVisualizationCash(ptrDelItem^).DATASize);
  FreeMem(ptrDelItem,SizeOf(TItemTOrientedPictureVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedPictureVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TOrientedPictureVisualizationFunctionality;
  DS: TMemoryStream;
  CDT: TComponentFileType;
  BMPDATAStream: TMemoryStream;
  JI: TJPEGImage;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin 
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedPictureVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedPictureVisualizationCash), 0);
    with TItemTOrientedPictureVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    DATAPtr:=nil;
    DATASize:=0;
    Width:=0;
    Height:=0;
    Orientation:=0;
    CF:=TOrientedPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetParams(Width,Height,Orientation);
    idDATAFile:=CF.DATAFileID;
    if (idDATAFile <> 0)
     then
      if (GetComponentFile(idDATAFile, DS))
       then
        try
        GetMem(DATAPtr,DS.Size);
        DATASize:=DS.Size;
        DS.Read(DATAPtr^,DATASize);
        finally
        DS.Destroy;
        end
       else begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        case TComponentFileType(CDT) of
        cftBMP: begin
          BMPDATAStream:=TMemoryStream.Create;
          try
          BMPDATAStream.LoadFromStream(DS);
          GetMem(DATAPtr,BMPDATAStream.Size);
          DATASize:=BMPDATAStream.Size;
          BMPDATAStream.Read(DATAPtr^,DATASize);
          finally
          BMPDATAStream.Destroy;
          end;
          end;
        cftJPEG: begin
          JI:=TJPEGImage.Create;
          with JI do
          try
          with TBitmap.Create do
          try
          if DS.Size > 0
           then begin
            JI.LoadFromStream(DS);
            Canvas.Lock();
            try
            Assign(JI);
            finally
            Canvas.Unlock();
            end;
            end;
          BMPDATAStream:=TMemoryStream.Create;
          try
          SaveToStream(BMPDATAStream);
          BMPDATAStream.Position:=0;
          GetMem(DATAPtr,BMPDATAStream.Size);
          DATASize:=BMPDATAStream.Size;
          BMPDATAStream.Read(DATAPtr^,DATASize);
          finally
          BMPDATAStream.Destroy;
          end;
          finally
          Destroy;
          end;
          finally
          Destroy;
          end;
          end;
        else
          Raise Exception.Create('unimplemented picture file type '); //. =>
        end;
        finally
        DS.Destroy;
        end;
        end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTOrientedPictureVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin 
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedPictureVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedPictureVisualizationCash), 0);
    with TItemTOrientedPictureVisualizationCash(ptrNewItem^) do begin
    idDATAFile:=0;
    DATAPtr:=nil;
    DATASize:=0;
    Width:=0;
    Height:=0;
    Orientation:=0;
    CF:=TOrientedPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try idDATAFile:=CF.DATAFileID; except on E: EActionsGroup do ; else Raise; end;
    try CF.GetParams(Width,Height,Orientation); except on E: EActionsGroup do ; else Raise; end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTOrientedPictureVisualizationCash(ItemsList[I]^) do with TOrientedPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    idDATAFile:=DATAFileID;
    with TItemTOrientedPictureVisualizationCash(ItemsList[I]^) do GetParams(Width,Height,Orientation);
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  ActionsGroups.ActionsGroup_Start(ptrActionsGroup);
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then with TItemTOrientedPictureVisualizationCash(ItemsList[I]^) do with TOrientedPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if (idDATAFile <> 0)
     then
      if (GetComponentFile(idDATAFile, DS))
       then
        try
        GetMem(DATAPtr,DS.Size);
        TItemTOrientedPictureVisualizationCash(ItemsList[I]^).DATASize:=DS.Size;
        DS.Read(DATAPtr^,TItemTOrientedPictureVisualizationCash(ItemsList[I]^).DATASize);
        finally
        DS.Destroy;
        end
       else try GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize); except on E: EActionsGroup do ; else Raise; end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item DATAFile of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(ItemsList[I]))+') could not be prepared for caching',E.Message);
      end;
    finally
    Release;
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then with TItemTOrientedPictureVisualizationCash(ItemsList[I]^) do with TOrientedPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    if ((idDATAFile <> 0) AND (DATAPtr = nil))
     then begin
      GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
      try
      case TComponentFileType(CDT) of
      cftBMP: begin
        BMPDATAStream:=TMemoryStream.Create;
        try
        BMPDATAStream.LoadFromStream(DS);
        GetMem(DATAPtr,BMPDATAStream.Size);
        TItemTOrientedPictureVisualizationCash(ItemsList[I]^).DATASize:=BMPDATAStream.Size;
        BMPDATAStream.Read(DATAPtr^,TItemTOrientedPictureVisualizationCash(ItemsList[I]^).DATASize);
        finally
        BMPDATAStream.Destroy;
        end;
        end;
      cftJPEG: begin
        JI:=TJPEGImage.Create;
        with JI do
        try
        with TBitmap.Create do
        try
        if DS.Size > 0
         then begin
          JI.LoadFromStream(DS);
          Canvas.Lock();
          try
          Assign(JI);
          finally
          Canvas.Unlock();
          end;
          end;
        BMPDATAStream:=TMemoryStream.Create;
        try
        SaveToStream(BMPDATAStream);
        BMPDATAStream.Position:=0;
        GetMem(DATAPtr,BMPDATAStream.Size);
        TItemTOrientedPictureVisualizationCash(ItemsList[I]^).DATASize:=BMPDATAStream.Size;
        BMPDATAStream.Read(DATAPtr^,TItemTOrientedPictureVisualizationCash(ItemsList[I]^).DATASize);
        finally
        BMPDATAStream.Destroy;
        end;
        finally
        Destroy;
        end;
        finally
        Destroy;
        end;
        end;
      else
        Raise Exception.Create('unimplemented picture file type '); //. =>
      end;
      finally
      DS.Destroy;
      end;
      end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item DATAFile of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(ItemsList[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTOrientedPictureVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;



procedure TTOrientedPictureVisualizationCash.Update;
begin
Empty;
end;

function TTOrientedPictureVisualizationCash.GetItem(const pidObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTOrientedPictureVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTOrientedPictureVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTOrientedPictureVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTOrientedPictureVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedPictureVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOrientedPictureVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTOrientedPictureVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TOrientedPictureVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
    BMPDATAStream: TMemoryStream;
    JI: TJPEGImage;
  begin
  with TItemTOrientedPictureVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TOrientedPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(Width,Height,Orientation);
  _idDATAFile:=CF.DATAFileID;
  if idDATAFile <> _idDATAFile
   then begin
    //. free last
    if DATAPtr <> nil
     then begin
      FreeMem(DATAPtr,DATASize);
      DATAPtr:=nil;
      end;
    //.
    if (_idDATAFile <> 0)
     then
      if (GetComponentFile(_idDATAFile, DS))
       then
        try
        GetMem(DATAPtr,DS.Size);
        DATASize:=DS.Size;
        DS.Read(DATAPtr^,DATASize);
        finally
        DS.Destroy;
        end
       else begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        case TComponentFileType(CDT) of
        cftBMP: begin
          BMPDATAStream:=TMemoryStream.Create;
          try
          BMPDATAStream.LoadFromStream(DS);
          GetMem(DATAPtr,BMPDATAStream.Size);
          DATASize:=BMPDATAStream.Size;
          BMPDATAStream.Read(DATAPtr^,DATASize);
          finally
          BMPDATAStream.Destroy;
          end;
          end;
        cftJPEG: begin
          JI:=TJPEGImage.Create;
          with JI do
          try
          with TBitmap.Create do
          try
          if DS.Size > 0
           then begin
            JI.LoadFromStream(DS);
            Canvas.Lock();
            try
            Assign(JI);
            finally
            Canvas.Unlock();
            end;
            end;
          BMPDATAStream:=TMemoryStream.Create;
          try
          SaveToStream(BMPDATAStream);
          BMPDATAStream.Position:=0;
          GetMem(DATAPtr,BMPDATAStream.Size);
          DATASize:=BMPDATAStream.Size;
          BMPDATAStream.Read(DATAPtr^,DATASize);
          finally
          BMPDATAStream.Destroy;
          end;
          finally
          Destroy;
          end;
          finally
          Destroy;
          end;
          end;
        else
          Raise Exception.Create('unimplemented picture file type '); //. =>
        end;
        finally
        DS.Destroy;
        end;
        end;
    idDATAFile:=_idDATAFile;
    end;
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTOrientedPictureVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOrientedPictureVisualizationCash), 0);
  with TItemTOrientedPictureVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  idDATAFile:=0;
  DATAPtr:=nil;
  DATASize:=0;
  Width:=0;
  Height:=0;
  Orientation:=0;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedPictureVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedPictureVisualizationCash), 0);
    with TItemTOrientedPictureVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    idDATAFile:=0;
    DATAPtr:=nil;
    DATASize:=0;
    Width:=0;
    Height:=0;
    Orientation:=0;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTOrientedPictureVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TOrientedPictureVisualizationFunctionality;
    _idDATAFile: integer;
    DS: TMemoryStream;
    CDT: TComponentFileType;
    BMPDATAStream: TMemoryStream;
    JI: TJPEGImage;
  begin
  with TItemTOrientedPictureVisualizationCash(ptrItem^) do begin
  //. updating item
  CF:=TOrientedPictureVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(Width,Height,Orientation);
  _idDATAFile:=CF.DATAFileID;
  if idDATAFile <> _idDATAFile
   then begin
    //. free last
    if DATAPtr <> nil
     then begin
      FreeMem(DATAPtr,DATASize);
      DATAPtr:=nil;
      end;
    //.
    if (_idDATAFile <> 0)
     then
      if (GetComponentFile(_idDATAFile, DS))
       then
        try
        GetMem(DATAPtr,DS.Size);
        DATASize:=DS.Size;
        DS.Read(DATAPtr^,DATASize);
        finally
        DS.Destroy;
        end
       else begin
        CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
        try
        case TComponentFileType(CDT) of
        cftBMP: begin
          BMPDATAStream:=TMemoryStream.Create;
          try
          BMPDATAStream.LoadFromStream(DS);
          GetMem(DATAPtr,BMPDATAStream.Size);
          DATASize:=BMPDATAStream.Size;
          BMPDATAStream.Read(DATAPtr^,DATASize);
          finally
          BMPDATAStream.Destroy;
          end;
          end;
        cftJPEG: begin
          JI:=TJPEGImage.Create;
          with JI do
          try
          with TBitmap.Create do
          try
          if DS.Size > 0
           then begin
            JI.LoadFromStream(DS);
            Canvas.Lock();
            try
            Assign(JI);
            finally
            Canvas.Unlock();
            end;
            end;
          BMPDATAStream:=TMemoryStream.Create;
          try
          SaveToStream(BMPDATAStream);
          BMPDATAStream.Position:=0;
          GetMem(DATAPtr,BMPDATAStream.Size);
          DATASize:=BMPDATAStream.Size;
          BMPDATAStream.Read(DATAPtr^,DATASize);
          finally
          BMPDATAStream.Destroy;
          end;
          finally
          Destroy;
          end;
          finally
          Destroy;
          end;
          end;
        else
          Raise Exception.Create('unimplemented picture file type '); //. =>
        end;
        finally
        DS.Destroy;
        end;
        end;
    idDATAFile:=_idDATAFile;
    end;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure CopyToItem(const ptrItem: pointer; var Item: TItemTOrientedPictureVisualizationCash);
  begin
  Item:=TItemTOrientedPictureVisualizationCash(ptrItem^);
  //. copy item reference fields
  if (TItemTOrientedPictureVisualizationCash(ptrItem^).DATAPtr <> nil)
   then begin
    GetMem(Item.DATAPtr,TItemTOrientedPictureVisualizationCash(ptrItem^).DATASize);
    Move(TItemTOrientedPictureVisualizationCash(ptrItem^).DATAPtr^,Item.DATAPtr^,TItemTOrientedPictureVisualizationCash(ptrItem^).DATASize);
    end;
  end;

  procedure MoveItem(const Item: TItemTOrientedPictureVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTOrientedPictureVisualizationCash(ptrItem^) do begin
  if (idDATAFile <> Item.idDATAFile)
   then begin
    if (DATAPtr <> nil)
     then begin
      FreeMem(DATAPtr,DATASize);
      DATAPtr:=nil;
      end;
    //.
    DATAPtr:=Item.DATAPtr;
    DATASize:=Item.DATASize;
    idDATAFile:=Item.idDATAFile;
    end
   else
    if (Item.DATAPtr <> nil)
     then FreeMem(Item.DATAPtr,Item.DATASize);
  //.
  Width:=Item.Width;
  Height:=Item.Height;
  Orientation:=Item.Orientation;
  end;
  end;

  procedure FreeItem(var Item: TItemTOrientedPictureVisualizationCash);
  begin
  with Item do
  if (DATAPtr <> nil)
   then FreeMem(DATAPtr,DATASize);
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
  Item: TItemTOrientedPictureVisualizationCash;
begin
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTOrientedPictureVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOrientedPictureVisualizationCash), 0);
  with TItemTOrientedPictureVisualizationCash(ptrNewItem^) do begin
  idObj:=pidObj;
  idDATAFile:=0;
  DATAPtr:=nil;
  DATASize:=0;
  Width:=0;
  Height:=0;
  Orientation:=0;
  end;
  UpdateItem(ptrNewItem);
  //.
  TypeSystem.Lock.Enter;
  try
  TItemTOrientedPictureVisualizationCash(ptrNewItem^).ptrNext:=FItems;
  FItems:=ptrNewItem;
  finally
  TypeSystem.Lock.Leave;
  end;
  end;
opUpdate: begin
  TypeSystem.Lock.Enter;
  try
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil) then CopyToItem(ptrUpdateItem, Item);
  finally
  TypeSystem.Lock.Leave;
  end;
  if (ptrUpdateItem <> nil)
   then begin    
    UpdateItem(@Item);
    //.
    TypeSystem.Lock.Enter;
    try
    ptrUpdateItem:=GetPtrItem(pidObj);
    if (ptrUpdateItem <> nil)
     then MoveItem(Item,ptrUpdateItem)
     else FreeItem(Item);
    finally
    TypeSystem.Lock.Leave;
    end;
    end
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedPictureVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedPictureVisualizationCash), 0);
    with TItemTOrientedPictureVisualizationCash(ptrNewItem^) do begin
    idObj:=pidObj;
    idDATAFile:=0;
    DATAPtr:=nil;
    DATASize:=0;
    Width:=0;
    Height:=0;
    Orientation:=0;
    end;
    UpdateItem(ptrNewItem);
    //.
    TypeSystem.Lock.Enter;
    try
    TItemTOrientedPictureVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
end;

procedure TTOrientedPictureVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTOrientedPictureVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTOrientedPictureVisualizationCash(ptrDelItem^).ptrNext;
    FreeMem(TItemTOrientedPictureVisualizationCash(ptrDelItem^).DATAPtr,TItemTOrientedPictureVisualizationCash(ptrDelItem^).DATASize);
    FreeMem(ptrDelItem,SizeOf(TItemTOrientedPictureVisualizationCash));
    //. remove all the same items Exit; //. ->
    end
   else
    ptrptrDelItem:=@TItemTOrientedPictureVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTOrientedPictureVisualizationCash.GetComponentFile(const pidDATAFile: integer; out DATA: TMemoryStream): boolean;
var
  ptrItem: pointer;
begin
Result:=false;
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOrientedPictureVisualizationCash(ptrItem^) do begin
  if (idDATAFile = pidDATAFile)
   then begin
    DATA:=TMemoryStream.Create;
    if (DATAPtr <> nil)
     then begin
      DATA.Write(DATAPtr^,DATASize);
      DATA.Position:=0;
      end;
    Result:=true;
    Exit; //. ->
    end;
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedPictureVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetDATA(const Ptr: pointer; const Size: integer): OLEVariant;
  var
    DATAPtr: pointer;
  begin
  if (Ptr <> nil)
   then begin
    Result:=VarArrayCreate([0,Size-1],varByte);
    DATAPtr:=VarArrayLock(Result);
    try
    Move(Ptr^,DATAPtr^,Size);
    finally
    VarArrayUnLock(Result);
    end;
    end
   else Result:=null;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOrientedPictureVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('idDATAFile');        PropNode.nodeTypedValue:=idDATAFile;        ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Width');             PropNode.nodeTypedValue:=Width;             ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Height');            PropNode.nodeTypedValue:=Height;            ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Orientation');       PropNode.nodeTypedValue:=Orientation;       ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('DATA');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetDATA(DATAPtr,DATASize);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedPictureVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetDATA(DATA: Variant; out Ptr: pointer; out Size: integer);
  var
    DATASize: integer;
    DATAPtr: pointer;
  begin
  Ptr:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    Size:=DATASize;
    GetMem(Ptr,Size);
    Move(DATAPtr^,Ptr^,Size);
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeMem(Ptr,Size);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _idDATAFile: integer;
  _Width: Double;
  _Height: Double;
  _Orientation: integer;
  DATA: Variant;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _idDATAFile:=ItemNode.selectSingleNode('idDATAFile').nodeTypedValue;
  _Width:=ItemNode.selectSingleNode('Width').nodeTypedValue;
  _Height:=ItemNode.selectSingleNode('Height').nodeTypedValue;
  _Orientation:=ItemNode.selectSingleNode('Orientation').nodeTypedValue;
  DATA:=ItemNode.selectSingleNode('DATA').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTOrientedPictureVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOrientedPictureVisualizationCash), 0);
  with TItemTOrientedPictureVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  idDATAFile:=_idDATAFile;
  Width:=_Width;
  Height:=_Height;
  Orientation:=_Orientation;
  SetDATA(DATA, DATAPtr,DATASize);
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;




// Визуализация
{TSystemTOrientedTTFVisualization}
Constructor TSystemTOrientedTTFVisualization.Create;
begin
CreateNew(idTOrientedTTFVisualization,tnTOrientedTTFVisualization,TTOrientedTTFVisualizationFunctionality);
if Enabled then Cash:=TTOrientedTTFVisualizationCash.Create(Self);
end;

Destructor TSystemTOrientedTTFVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTOrientedTTFVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTOrientedTTFVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTOrientedTTFVisualization.Caching_Start;
begin
end;

procedure TSystemTOrientedTTFVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTOrientedTTFVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTOrientedTTFVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTOrientedTTFVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


// TTOrientedTTFVisualizationCash
Constructor TTOrientedTTFVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTOrientedTTFVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTOrientedTTFVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTOrientedTTFVisualizationCash(ptrDelItem^).ptrNext;
  with TItemTOrientedTTFVisualizationCash(ptrDelItem^) do begin
  Str:='';
  Font_Name:='';
  end;
  FreeMem(ptrDelItem,SizeOf(TItemTOrientedTTFVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedTTFVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TOrientedTTFVisualizationFunctionality;
  WS,WS1: WideString;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedTTFVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedTTFVisualizationCash), 0);
    with TItemTOrientedTTFVisualizationCash(ptrNewItem^) do begin
    CF:=TOrientedTTFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetParams(WS,Font_Width,Font_Height,WS1,CharInterval,Orientation);
    Str:=WS; Font_Name:=WS1;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTOrientedTTFVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedTTFVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedTTFVisualizationCash), 0);
    with TItemTOrientedTTFVisualizationCash(ptrNewItem^) do begin
    CF:=TOrientedTTFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try
    CF.GetParams(WS,Font_Width,Font_Height,WS1,CharInterval,Orientation);
    Str:=WS; Font_Name:=WS1;
    except
      on E: EActionsGroup do ;
      else Raise; //. =>
      end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTOrientedTTFVisualizationCash(ItemsList[I]^) do with TOrientedTTFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    with TItemTOrientedTTFVisualizationCash(ItemsList[I]^) do begin
    GetParams(WS,Font_Width,Font_Height,WS1,CharInterval,Orientation);
    Str:=WS; Font_Name:=WS1;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTOrientedTTFVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;


procedure TTOrientedTTFVisualizationCash.Update;
begin
Empty;
end;

function TTOrientedTTFVisualizationCash.GetItem(const pidObj: integer; var S: WideString; var vFont_Width,vFont_Height: Double; var vFont_Name: WideString; var vCharInterval: Double; var vOrientation: integer): boolean;
var
  ptrItem: pointer;
  ptrNewItem: pointer;
  _Str: WideString;
  _Font_Name: WideString;
  _Font_Width: Double;
  _Font_Height: Double;
  _CharInterval: Double;
  _Orientation: integer;
  flFound: boolean;
begin
Result:=false;
TypeSystem.Lock.Enter;
try
ptrItem:=GetPtrItem(pidObj);
if (ptrItem = nil) then Exit; //. ->
with TItemTOrientedTTFVisualizationCash(ptrItem^) do begin
S:=Str;
vFont_Width:=Font_Width;
vFont_Height:=Font_Height;
vFont_Name:=Font_Name;
vCharInterval:=CharInterval;
vOrientation:=Orientation;
end;
Result:=true;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTOrientedTTFVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTOrientedTTFVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTOrientedTTFVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTOrientedTTFVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedTTFVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOrientedTTFVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTOrientedTTFVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TOrientedTTFVisualizationFunctionality;
    WS,WS1: WideString;
  begin
  with TItemTOrientedTTFVisualizationCash(ptrItem^) do begin
  CF:=TOrientedTTFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(WS,Font_Width,Font_Height,WS1,CharInterval,Orientation);
  Str:=WS; Font_Name:=WS1;
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTOrientedTTFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOrientedTTFVisualizationCash), 0);
  with TItemTOrientedTTFVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedTTFVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedTTFVisualizationCash), 0);
    with TItemTOrientedTTFVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTOrientedTTFVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TOrientedTTFVisualizationFunctionality;
    WS,WS1: WideString;
  begin
  with TItemTOrientedTTFVisualizationCash(ptrItem^) do begin
  CF:=TOrientedTTFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(WS,Font_Width,Font_Height,WS1,CharInterval,Orientation);
  Str:=WS; Font_Name:=WS1;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTOrientedTTFVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTOrientedTTFVisualizationCash(ptrItem^) do begin
  Str:=Item.Str;
  Font_Width:=Item.Font_Width;
  Font_Height:=Item.Font_Height;
  Font_Name:=Item.Font_Name;
  CharInterval:=Item.CharInterval;
  Orientation:=Item.Orientation;
  end;
  end;

var
  Item: TItemTOrientedTTFVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTOrientedTTFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOrientedTTFVisualizationCash), 0);
  with TItemTOrientedTTFVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTOrientedTTFVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTOrientedTTFVisualizationCash), 0);
    with TItemTOrientedTTFVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedTTFVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTOrientedTTFVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTOrientedTTFVisualizationCash(ptrDelItem^).ptrNext;
    with TItemTOrientedTTFVisualizationCash(ptrDelItem^) do begin
    Str:='';
    Font_Name:='';
    end;
    FreeMem(ptrDelItem,SizeOf(TItemTOrientedTTFVisualizationCash));
    //. remove all the same items Exit;
    end
   else
    ptrptrDelItem:=@TItemTOrientedTTFVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedTTFVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);
var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTOrientedTTFVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('Str');              PropNode.nodeTypedValue:=Str;           ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('FontName');         PropNode.nodeTypedValue:=Font_Name;     ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('FontWidth');        PropNode.nodeTypedValue:=Font_Width;    ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('FontHeight');       PropNode.nodeTypedValue:=Font_Height;   ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('CharInterval');     PropNode.nodeTypedValue:=CharInterval;  ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('Orientation');      PropNode.nodeTypedValue:=Orientation;   ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTOrientedTTFVisualizationCash.LoadItems(Node: IXMLDOMNode);
var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _Str: string;
  _FontName: string;
  _FontWidth: double;
  _FontHeight: double;
  _CharInterval: double;
  _Orientation: integer;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _Str:=ItemNode.selectSingleNode('Str').nodeTypedValue;
  _FontName:=ItemNode.selectSingleNode('FontName').nodeTypedValue;
  _FontWidth:=ItemNode.selectSingleNode('FontWidth').nodeTypedValue;
  _FontHeight:=ItemNode.selectSingleNode('FontHeight').nodeTypedValue;
  _CharInterval:=ItemNode.selectSingleNode('CharInterval').nodeTypedValue;
  _Orientation:=ItemNode.selectSingleNode('Orientation').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTOrientedTTFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTOrientedTTFVisualizationCash), 0);
  with TItemTOrientedTTFVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  Str:=_Str;
  Font_Name:=_FontName;
  Font_Width:=_FontWidth;
  Font_Height:=_FontHeight;
  CharInterval:=_CharInterval;
  Orientation:=_Orientation;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;




//. Icon
{TSystemTIcon}
Constructor TSystemTIcon.Create;
begin
CreateNew(idTIcon,tnTIcon,TTIconFunctionality);
end;





{TSystemTMessageBoardMessage}
Constructor TSystemTMessageBoardMessage.Create;
begin
CreateNew(idTMessageBoardMessage,tnTMessageBoardMessage,TTMessageBoardMessageFunctionality);
end;

procedure TSystemTMessageBoardMessage.DoOnComponentOperationLocal(const pidTObj,pidObj: integer; const Operation: TComponentOperation);
begin
Inherited;
//. force UserUnreadMessagesChecking to update
UserUnreadMessagesChecking.flForceChecking:=true;
if (UserUnreadMessagesChecking.Suspended) then UserUnreadMessagesChecking.Resume;
end;





//. MessageBoard
{TSystemTMessageBoard}
Constructor TSystemTMessageBoard.Create;
begin
CreateNew(idTMessageBoard,tnTMessageBoard,TTMessageBoardFunctionality);
end;





//. HREF
{TSystemTHREF}
Constructor TSystemTHREF.Create;
begin
CreateNew(idTHREF,tnTHREF,TTHREFFunctionality);
end;





//. QDC-Визуализация
{TSystemTQDCVisualization}
Constructor TSystemTQDCVisualization.Create;
begin
CreateNew(idTQDCVisualization,tnTQDCVisualization,TTQDCVisualizationFunctionality);
if Enabled then Cash:=TTQDCVisualizationCash.Create(Self);
end;

Destructor TSystemTQDCVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTQDCVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTQDCVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited; 
end;

procedure TSystemTQDCVisualization.Caching_Start;
begin
end;

procedure TSystemTQDCVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTQDCVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTQDCVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTQDCVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;


//. TTQDCVisualizationCash
Constructor TTQDCVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTQDCVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTQDCVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTQDCVisualizationCash(ptrDelItem^).ptrNext;
  FreeMem(TItemTQDCVisualizationCash(ptrDelItem^).DATAPtr,TItemTQDCVisualizationCash(ptrDelItem^).DATASize);
  FreeMem(ptrDelItem,SizeOf(TItemTQDCVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTQDCVisualizationCash.Update;
begin
Empty;
end;


function TTQDCVisualizationCash.GetItem(const idObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(idObj);
if ptrItem = nil
 then begin
  {/// ? UpdateLocal(idObj,opCreate);
  ptrItem:=FItems; //. because new item always placed at begin}
  Exit; //. ->
  end;
Result:=true;
end;

function TTQDCVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTQDCVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTQDCVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTQDCVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTQDCVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTQDCVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

procedure TTQDCVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  begin
  {///cwith TItemTQDCVisualizationCash(ptrItem^),Space.TObjPropsQuery_Create do
  try
  EnterSQL('SELECT * FROM '+TypeSystem.TableName+' WHERE id = '+IntToStr(idObj));
  Open;
  //. updating item
  QDCDATAs.Delete(QDCDATAPtr);
  if (FieldValues['idDATAFile'] <> null) AND (FieldValues['idDATAFile'] <> 0)
   then begin
    idDATAFile:=FieldValues['idDATAFile'];
    QDCDATAPtr:=QDCDATAs.Insert(idDATAFile);
    end
   else
    QDCDATAPtr:=nil;
  finally
  Destroy;
  end;}
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTQDCVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTQDCVisualizationCash), 0);
  with TItemTQDCVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  DATAPtr:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTQDCVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTQDCVisualizationCash), 0);
    with TItemTQDCVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    DATAPtr:=nil;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTQDCVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TQDCVisualizationFunctionality;
  DS: TClientBlobStream;
  CDT: TComponentFileType;
  BMPDATAStream: TMemoryStream;
begin //. not supported
(*if List.Count = 0 then Exit; //. ->
TypeSystem.Lock.Enter;
try
for I:=0 to List.Count-1 do begin
  GetMem(ptrNewItem,SizeOf(TItemTQDCVisualizationCash));
  try
  FillChar(ptrNewItem^,SizeOf(TItemTQDCVisualizationCash), 0);
  with TItemTQDCVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  DATAPtr:=nil;
  DATASize:=0;
  CF:=TQDCVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
  try
  idObj:=CF.idObj;
  CF.GetDATA(DS,CDT,Space.Configuration.VisualizationMaxSize);
  try
  case TComponentFilType(CDT) of
  cftBMP: begin
    BMPDATAStream:=TMemoryStream.Create;
    try
    BMPDATAStream.LoadFromStream(DATAStream);
    GetMem(DATAPtr,BMPDATAStream.Size);
    DATASize:=BMPDATAStream.Size;
    BMPDATAStream.Read(DATAPtr^,DATASize);
    finally
    BMPDATAStream.Destroy;
    end;
    end;
  cftJPEG: begin
    JI:=TJPEGImage.Create;
    with JI do
    try
    with TBitmap.Create do
    try
    if DATAStream.Size > 0
     then begin
      JI.LoadFromStream(DATAStream);
      Canvas.Lock();
      try
      Assign(JI);
      finally
      Canvas.Unlock();
      end;
      end;
    BMPDATAStream:=TMemoryStream.Create;
    try
    SaveToStream(BMPDATAStream);
    BMPDATAStream.Position:=0;
    GetMem(DATAPtr,BMPDATAStream.Size);
    DATASize:=BMPDATAStream.Size;
    BMPDATAStream.Read(DATAPtr^,DATASize);
    finally
    BMPDATAStream.Destroy;
    end;
    finally
    Destroy;
    end;
    finally
    Destroy;
    end;
    end;
  else
    Raise Exception.Create('unimplemented picture file type '); //. =>
  end;
  finally
  DS.Destroy;
  end;
  finally
  CF.Release;
  end;
  end;
  FItems:=ptrNewItem;
  except
    FreeMem(TItemTQDCVisualizationCash(ptrNewItem^).DATAPtr,TItemTQDCVisualizationCash(ptrNewItem^).DATASize);
    FreeMem(ptrNewItem,SizeOf(TItemTQDCVisualizationCash));
    end
  end;
finally
TypeSystem.Lock.Leave;
end;*)
end;


procedure TTQDCVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTQDCVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTQDCVisualizationCash(ptrDelItem^).ptrNext;
    FreeMem(TItemTQDCVisualizationCash(ptrDelItem^).DATAPtr,TItemTQDCVisualizationCash(ptrDelItem^).DATASize);
    FreeMem(ptrDelItem,SizeOf(TItemTQDCVisualizationCash));
    //. remove all the same items Exit;
    end
   else
    ptrptrDelItem:=@TItemTQDCVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTQDCVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);

  function GetDATA(const Ptr: pointer; const Size: integer): OLEVariant;
  var
    DATAPtr: pointer;
  begin
  if (Ptr <> nil)
   then begin
    Result:=VarArrayCreate([0,Size-1],varByte);
    DATAPtr:=VarArrayLock(Result);
    try
    Move(Ptr^,DATAPtr^,Size);
    finally
    VarArrayUnLock(Result);
    end;
    end
   else Result:=null;
  end;

var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTQDCVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('DATA');
  PropNode.Set_dataType('bin.base64');
  PropNode.nodeTypedValue:=GetDATA(DATAPtr,DATASize);
  ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTQDCVisualizationCash.LoadItems(Node: IXMLDOMNode);

  procedure SetDATA(DATA: Variant; out Ptr: pointer; out Size: integer);
  var
    DATASize: integer;
    DATAPtr: pointer;
  begin
  Ptr:=nil;
  try
  if (DATA <> null)
   then begin
    DATASize:=VarArrayHighBound(DATA,1)+1;
    DATAPtr:=VarArrayLock(DATA);
    try
    Size:=DATASize;
    GetMem(Ptr,Size);
    Move(DATAPtr^,Ptr^,Size);
    finally
    VarArrayUnLock(DATA);
    end;
    end;
  except
    FreeMem(Ptr,Size);
    Raise; //. =>
    end;
  end;

var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  DATA: Variant;
begin
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  DATA:=ItemNode.selectSingleNode('DATA').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTQDCVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTQDCVisualizationCash), 0);
  with TItemTQDCVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  SetDATA(DATA, DATAPtr,DATASize);
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;




//. OffersServer
{TSystemTOffersServer}
Constructor TSystemTOffersServer.Create;
begin
CreateNew(idTOffersServer,tnTOffersServer,TTOffersServerFunctionality);
end;





//. SecurityComponentOperation
{TSystemTSecurityComponentOperation}
Constructor TSystemTSecurityComponentOperation.Create;
begin
CreateNew(idTSecurityComponentOperation,tnTSecurityComponentOperation,TTSecurityComponentOperationFunctionality);
end;





//. SecurityKey
{TSystemTSecurityKey}
Constructor TSystemTSecurityKey.Create;
begin
CreateNew(idTSecurityKey,tnTSecurityKey,TTSecurityKeyFunctionality);
end;





{TSystemTSecurityFile}
Constructor TSystemTSecurityFile.Create;
begin
CreateNew(idTSecurityFile,tnTSecurityFile,TTSecurityFileFunctionality);
end;





{TSystemTSecurityComponent}
Constructor TSystemTSecurityComponent.Create;
begin
CreateNew(idTSecurityComponent,tnTSecurityComponent,TTSecurityComponentFunctionality);
end;





//. MODELUser
{TSystemTMODELUser}
Constructor TSystemTMODELUser.Create;
begin
CreateNew(idTMODELUser,tnTMODELUser,TTMODELUserFunctionality);
end;





//. Texture
{TSystemTTexture}
Constructor TSystemTTexture.Create;
begin
CreateNew(idTTexture,tnTTexture,TTTextureFunctionality);
end;





//. 3D-Визуализация
{TSystemTBuffered3DVisualization}
Constructor TSystemTBuffered3DVisualization.Create;
begin
CreateNew(idTBuffered3DVisualization,tnTBuffered3DVisualization,TTBuffered3DVisualizationFunctionality);
if Enabled then Cash:=TTBuffered3DVisualizationCash.Create(Self);
end;

Destructor TSystemTBuffered3DVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTBuffered3DVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

procedure TSystemTBuffered3DVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;


//. TTBuffered3DVisualizationCash

{TMeshesList}
Constructor TMeshesList.Create(pCash: TTBuffered3DVisualizationCash);
begin
Inherited Create;
Cash:=pCash;
FMeshes:=nil;
end;

Destructor TMeshesList.Destroy;
begin
Clear;
Inherited;
end;

procedure TMeshesList.Clear;
var
  ptrDestroyItem: pointer;
begin
while FMeshes <> nil do begin
  ptrDestroyItem:=FMeshes;
  FMeshes:=TMeshes(ptrDestroyItem^).Next;
  //. destroy item
  TMeshes(ptrDestroyItem^).Destroy;
  end;
end;

function TMeshesList.Insert(const pidSourceFile: integer; const InstallTextureProc: TInstallTextureProc): TMeshes;
var
  DATAStream: TClientBlobStream;
  DATAType: TComponentFileType;
begin
Result:=FMeshes;
while Result <> nil do
  if Result.idSourceFile = pidSourceFile
   then begin
    Inc(Result.RefCount);
    Exit; //. ->
    end
   else
    Result:=Result.Next;
//. creating new object
with TComponentsFilesRepository.Create(Cash.Space) do
try
GetFile(pidSourceFile, DATAStream,DATAType);
Result:=TMeshes.CreateFromStream(DATAStream,Integer(DATAType),InstallTextureProc);
with Result do begin
Inc(RefCount);
idSourceFile:=pidSourceFile;
Next:=FMeshes;
end;
FMeshes:=Result;
finally
Destroy;
end;
end;

procedure TMeshesList.Delete(var Meshes: TMeshes);
var
  ptrptrItem: pointer;
begin
if Meshes = nil then Exit; //. ->
Dec(Meshes.RefCount);
if Meshes.RefCount = 0
 then begin //. popup item from the list and destroy it
  ptrptrItem:=@FMeshes;
  while Pointer(ptrptrItem^) <> nil do
    if Pointer(ptrptrItem^) = Meshes
     then begin
      Pointer(ptrptrItem^):=Meshes.Next; //. popup
      Meshes.Destroy;
      Meshes:=nil;
      Exit; //. ->
      end
     else
      ptrptrItem:=@TMeshes(Pointer(ptrptrItem^)).Next;
  end;
end;

Constructor TTBuffered3DVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
MeshesList:=TMeshesList.Create(Self);
end;

destructor TTBuffered3DVisualizationCash.Destroy;
begin
Empty;
MeshesList.Free;
Inherited;
end;

procedure TTBuffered3DVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTBuffered3DVisualizationCash(ptrDelItem^).ptrNext;
  MeshesList.Delete(TItemTBuffered3DVisualizationCash(ptrDelItem^).Meshes);
  FreeMem(ptrDelItem,SizeOf(TItemTBuffered3DVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure GetTransforMatrix(const Scale,Translate_X,Translate_Y,Translate_Z,Rotate_AngleX,Rotate_AngleY,Rotate_AngleZ: Double; const ptrMatrix: pointer);
begin
glMatrixMode(GL_MODELVIEW);
glPushMatrix;
glLoadIdentity;
glTranslatef(Translate_X,Translate_Y,Translate_Z);
glScalef(Scale,Scale,Scale);
glRotatef(Rotate_AngleX, 1,0,0);
glRotatef(Rotate_AngleY, 0,1,0);
glRotatef(Rotate_AngleZ, 0,0,1);
glGetFloatv(GL_MODELVIEW_MATRIX, ptrMatrix);
glPopMatrix;
end;

procedure TTBuffered3DVisualizationCash.Update;
begin
Empty;
end;


function TTBuffered3DVisualizationCash.GetItem(const idObj: integer; out ptrItem: pointer): boolean;
begin
Result:=false;
ptrItem:=GetPtrItem(idObj);
if ptrItem = nil then Exit; //. ->
Result:=true;
end;

function TTBuffered3DVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTBuffered3DVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTBuffered3DVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTBuffered3DVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTBuffered3DVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTBuffered3DVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

procedure TTBuffered3DVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  begin
  {///cwith TItemTBuffered3DVisualizationCash(ptrItem^),Space.TObjPropsQuery_Create do
  try
  EnterSQL('SELECT * FROM '+TypeSystem.TableName+' WHERE id = '+IntToStr(idObj));
  Open;
  //. updating item
  MeshesList.Delete(Meshes);
  if (FieldValues['idDATAFile'] <> null) AND (FieldValues['idDATAFile'] <> 0)
   then begin
    idDATAFile:=FieldValues['idDATAFile'];
    Meshes:=MeshesList.Insert(idDATAFile,InstallTexture);
    if Meshes.idDisplayList = 0 then Meshes.DisplayList_Compile;
    end
   else
    Meshes:=nil;
  Scale:=FieldValues['Scale'];
  Rotate_AngleX:=FieldValues['Rotate_AngleX'];
  Rotate_AngleY:=FieldValues['Rotate_AngleY'];
  Rotate_AngleZ:=FieldValues['Rotate_AngleZ'];
  //. getting of Translate_X,Translate_Y
  with TTBuffered3DVisualizationFunctionality.Create do
  try
  with TBuffered3DVisualizationFunctionality(TComponentFunctionality_Create(idObj)) do
  try
  Meshes:=TItemTBuffered3DVisualizationCash(ptrItem^).Meshes;
  Scale:=TItemTBuffered3DVisualizationCash(ptrItem^).Scale;
  Rotate_AngleX:=TItemTBuffered3DVisualizationCash(ptrItem^).Rotate_AngleX;
  Rotate_AngleY:=TItemTBuffered3DVisualizationCash(ptrItem^).Rotate_AngleY;
  Rotate_AngleZ:=TItemTBuffered3DVisualizationCash(ptrItem^).Rotate_AngleZ;
  try
  Get__Translate_XY(TItemTBuffered3DVisualizationCash(ptrItem^).Translate_X,TItemTBuffered3DVisualizationCash(ptrItem^).Translate_Y);
  except
    TItemTBuffered3DVisualizationCash(ptrItem^).Translate_X:=0;
    TItemTBuffered3DVisualizationCash(ptrItem^).Translate_Y:=0;
    Space.Log.Log_WriteException('can not get TranslateXY for Buffered3DVisualization (id = '+IntToStr(idObj)+'), default assigned');
    end;
  finally
  Release;
  end;
  finally
  Release;
  end;
  //. getting Translate_Z
  Translate_Z:=FieldValues['Translate_Z'];
  //.
  GetTransforMatrix(Scale,Translate_X,Translate_Y,Translate_Z,Rotate_AngleX,Rotate_AngleY,Rotate_AngleZ, @TransforMatrix);
  finally
  Destroy;
  end;}
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTBuffered3DVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTBuffered3DVisualizationCash), 0);
  with TItemTBuffered3DVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  Meshes:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTBuffered3DVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTBuffered3DVisualizationCash), 0);
    with TItemTBuffered3DVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    Meshes:=nil;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTBuffered3DVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTBuffered3DVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTBuffered3DVisualizationCash(ptrDelItem^).ptrNext;
    MeshesList.Delete(TItemTBuffered3DVisualizationCash(ptrDelItem^).Meshes);
    FreeMem(ptrDelItem,SizeOf(TItemTBuffered3DVisualizationCash));
    //. remove all the same items Exit;
    end
   else
    ptrptrDelItem:=@TItemTBuffered3DVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTBuffered3DVisualizationCash.InstallTexture(const Material: TMaterial): cardinal;
var
  Picture: TPicture;
  I: Integer;
  MemDC: HDC;
  TexturesList: TList;
  TextureDATA: TMemoryStream;
  TargetWidth,
  TargetHeight: Integer;

  function RoundDownToPowerOf2(Value: Integer): Integer;
  var
    LogTwo: Double;
  begin
  LogTwo := log2(Value);
  if Trunc(LogTwo) < LogTwo then Result := Trunc(Power(2, Trunc(LogTwo)))
                              else Result := Value;
  end;

  function CreateTextureObject(DC: HDC; Bitmap: TBitmap; MinFilter, MagFilter: Cardinal): Cardinal;
  // creates a 2D texture object from the given bitmap which must have width and height as being power of 2
  var J: Integer;
      Data: PByteArray;
      BMInfo: TBitmapInfo;
      ImageSize: Cardinal;
      Temp: Byte;
  begin
  Result := 0;
  if (Bitmap.Height > 2) and (Bitmap.Width > 2) then
  begin
    glGenTextures(1, @Result);
    glBindTexture(GL_TEXTURE_2D, Result);

    // get color components
    with BMinfo.bmiHeader do
    begin
      // create description of the required image format
      FillChar(BMInfo, SizeOf(BMInfo), 0);
      biSize := SizeOf(TBitmapInfoHeader);
      biBitCount := 24;
      biWidth := Bitmap.Width;
      // I want a top-down bitmap. It seems that a positive value in biHeight will always flip
      // the image (even if it is already a bottom-up image).
      biHeight := Bitmap.Height;
      if Cardinal(Bitmap.ScanLine[0]) < Cardinal(Bitmap.ScanLine[1]) then biHeight := - biHeight;
      ImageSize := Bitmap.Width * Bitmap.Height;
      biPlanes := 1;
      biCompression := BI_RGB;
      GetMem(Pointer(Data), ImageSize * 3);
      try
        // get the actual bits of the image
        GetDIBits(DC, Bitmap.Handle, 0, Bitmap.Height, Data, BMInfo, DIB_RGB_COLORS);

        // Now set the bits depending on the features supported by OpenGL.
        if GL_EXT_bgra then
          // BGR extension avoids color component swapping
          if (MinFilter = GL_NEAREST) or (MinFilter = GL_LINEAR)
            then glTexImage2d(GL_TEXTURE_2D, 0, 3, biWidth, Bitmap.Height, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE, Data)
            else gluBuild2DMipmaps(GL_TEXTURE_2D, 3, biWidth, Bitmap.Height, GL_BGR_EXT, GL_UNSIGNED_BYTE, Data)
          else
          begin
            // No BGR support, so we must swap the color components manually.
            {$ifopt R+} {$define RangeCheck} {$R-} {$endif}
            for J := 0 to ImageSize - 1 do // swap blue with red to go from bgr to rgb
            begin
              Temp := Data[J * 3];
              Data[J * 3]:=Data[J * 3 + 2];
              Data[J * 3 + 2] := Temp;
            end;
            {$ifdef RangeCheck} {$undef RangeCheck} {$R+} {$endif}
            if (MinFilter = GL_NEAREST) or (MinFilter = GL_LINEAR)
              then glTexImage2d(GL_TEXTURE_2D, 0, 3, biWidth, Bitmap.Height, 0, GL_RGB, GL_UNSIGNED_BYTE, Data)
              else gluBuild2DMipmaps(GL_TEXTURE_2D, 3, biWidth, Bitmap.Height, GL_RGB, GL_UNSIGNED_BYTE, Data);
          end;
      finally
        FreeMem(Data);
      end;
    end;
  end;
  end;

  function ExtractTextureName(const TextureName: string): string;
  var
    I: integer;
  begin
  Result:='';
  for I:=1 to Length(TextureName) do
    if TextureName[I] = '.'
     then
      Exit //. ->
     else
      Result:=Result+TextureName[I];
  Result:=TextureName;
  end;

begin
Result:=0;
Picture:=TPicture.Create;
try
MemDC:=CreateCompatibleDC(0);
try
with Material do
if Texture <> ''
 then with TTTextureFunctionality.Create do
  try
  GetInstanceListMatchingBy(ExtractTextureName(Texture), TexturesList);
  try
  if TexturesList.Count > 0
   then with TTextureFunctionality(TComponentFunctionality_Create(Integer(TexturesList[0]))) do
    try
    Check;
    GetBitmapDATA(TextureDATA);
    try
    Picture.Bitmap.LoadFromStream(TextureDATA);
    if NOT ((Picture.Width = 0) OR (Picture.Height = 0))
     then with Picture do begin
      TargetWidth := RoundDownToPowerOf2(Width);
      TargetHeight := RoundDownToPowerOf2(Height);
      if (TargetWidth <> Width) or (TargetHeight <> Height) then Stretch(TargetWidth, TargetHeight, sfLanczos3, 0, Bitmap);
      //. create texture object
      Result:=CreateTextureObject(MemDC, Bitmap, MinFilter, MagFilter);
      end;
    finally
    TextureDATA.Destroy;
    end;
    finally
    Destroy;
    end;
  finally
  TexturesList.Destroy;
  end;
  finally
  Destroy;
  end;
finally
DeleteDC(MemDC);
end;
finally
Picture.Free;
end;
end;

procedure TTBuffered3DVisualizationCash.RecompileMeshesDisplayLists;
var
  Meshes: TMeshes;
begin
Meshes:=MeshesList.FMeshes;
while Meshes <> nil do with Meshes do begin
  try
  DisplayList_Compile;
  except
    On E: Exception do EventLog.WriteMajorEvent('RecompileMeshesDisplayLists','mesh compilation error (idComponentFile = '+IntToStr(idSourceFile)+')',E.Message);
    end;
  Meshes:=Next;
  end;
end;





//. DATAFile
{TSystemTDATAFile}
Constructor TSystemTDATAFile.Create;
begin
CreateNew(idTDATAFile,tnTDATAFile,TTDATAFileFunctionality);
end;





//. CoComponent
{TSystemTCoComponent}
Constructor TSystemTCoComponent.Create;
begin
CreateNew(idTCoComponent,tnTCoComponent,TTCoComponentFunctionality);
end;





//. CoComponentTypeMarker
{TSystemTCoComponentTypeMarker}
Constructor TSystemTCoComponentTypeMarker.Create;
begin
CreateNew(idTCoComponentTypeMarker,tnTCoComponentTypeMarker,TTCoComponentTypeMarkerFunctionality);
end;





//. CoComponentType
{TSystemTCoComponentType}
Constructor TSystemTCoComponentType.Create;
begin
CreateNew(idTCoComponentType,tnTCoComponentType,TTCoComponentTypeFunctionality);
end;





//. Address
{TSystemTAddress}
Constructor TSystemTAddress.Create;
begin
CreateNew(idTAddress,tnTAddress,TTAddressFunctionality);
end;





//. Транспортный маршрут
{TSystemTTransportRoute}
Constructor TSystemTTransportRoute.Create;
begin
CreateNew(idTTransportRoute,tnTTransportRoute,TTTransportRouteFunctionality);
end;

procedure TSystemTTransportRoute.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;





//. Транспортный узел
{TRouteNodesList}
Destructor TRouteNodesList.Destroy;
begin
Clear;
Inherited;
end;

procedure TRouteNodesList.Clear;
var
  I: integer;
  ptrDelItem: pointer;
begin
for I:=0 to Count-1 do begin
  ptrDelItem:=List[I];
  List[I]:=nil;
  FreeMem(ptrDelItem, SizeOf(TItemRouteNodesList));
  end;
Inherited Clear;
end;

procedure TRouteNodesList.AddNode(const pidNode: integer; const pidItem: integer);
var
  ptrNewItem: pointer;
begin
GetMem(ptrNewItem,SizeOf(TItemRouteNodesList));
with TItemRouteNodesList(ptrNewItem^) do begin
idNode:=pidNode;
idItem:=pidItem;
end;
Add(ptrNewItem);
end;

{TSystemTTransportNode}
Constructor TSystemTTransportNode.Create;
begin
CreateNew(idTTransportNode,tnTTransportNode,TTTransportNodeFunctionality);
end;





//. Предложение товара
{TSystemTOfferGoods}
Constructor TSystemTOfferGoods.Create;
begin
CreateNew(idTOfferGoods,tnTOfferGoods,TTOfferGoodsFunctionality);
end;

procedure MeasureUnits_NormalizeName(MUName: string; out NN: string);
var
  I: integer;
begin
MUName:=ANSIUpperCase(MUName);
NN:='';
for I:=1 to Length(MUName) do
  if (MUName[I] <> '.') AND (MUName[I] <> ',') then NN:=NN+MUName[I];
end;

function MeasureUnits_GetEqualUnit(const MUName: string; out idMeasureUnit: integer): boolean;

var
  NormalizedName: string;
begin
Result:=false;
MeasureUnits_NormalizeName(MUName, NormalizedName);
{/// + with TypesSystem.Space.TObjPropsQuery_Create do
try
SelectDataBase(idGoodsDB);
EnterSQL('SELECT * FROM Measurements WHERE Name LIKE '''+NormalizedName+''' ORDER BY Key_');
Open;
if RecordCount > 0
 then begin
  idMeasureUnit:=FieldValues['Key_'];
  Result:=true;
  end;
finally
Destroy;
end;}
end;

function MeasureUnits_CreateInstance(const pName: string): integer;
var
  NN: string;
begin
MeasureUnits_NormalizeName(pName, NN);
{/// + with TypesSystem.Space.TObjPropsQuery_Create do
try
EnterSQL('LOCK TABLE Measurements WRITE');
ExecSQL;
try
EnterSQL('INSERT INTO Measurements (Name,Key_) Values('''+NN+''',0)');
ExecSQL;
EnterSQL('SELECT Max(Key_) maxKey_ FROM Measurements');
Open;
Result:=FieldValues['maxKey_'];
finally
EnterSQL('UNLOCK TABLES');
ExecSQL;
end;
finally
Destroy;
end;}
end;

procedure MeasureUnits_GetInstanceList(var List: TStringList);
var
  idMeasurement: integer;
begin
List:=nil;
List:=TStringList.Create;
{/// + with TypesSystem.Space.TObjPropsQuery_Create do
try
SelectDataBase(idGoodsDB);
EnterSQL('SELECT * FROM Measurements');
Open;
while NOT EOF do begin
  idMeasurement:=FieldValues['Key_'];
  List.Objects[List.Add(FieldValues['Name'])]:=TObject(idMeasurement);
  Next;
  end;
finally
Destroy;
end;}
end;

{TMeasureUnitFunctionality}
Constructor TMeasureUnitFunctionality.Create(const pidObj: integer);
begin
Inherited Create;
idObj:=pidObj;
end;

function TMeasureUnitFunctionality.getName;
begin
{/// + with TypesSystem.Space.TObjPropsQuery_Create do
try
EnterSQL('SELECT Name FROM Measurements WHERE Key_ = '+IntToStr(idObj));
Open;
if FieldValues['Name'] <> Null then Result:=FieldValues['Name'] else Result:='';
Result:=Trim(Result);
finally
Destroy;
end;}
end;




//. ИИС телефонной станции
{TSystemTTLFStationTMT}
Constructor TSystemTTLFStationTMT.Create;
begin
CreateNew(idTTLFStationTMT,tnTTLFStationTMT,TTTLFStationTMTFunctionality);
end;





// имя
{TSystemTName}
Constructor TSystemTName.Create;
begin
CreateNew(idTName,tnTName,TTNameFunctionality);
end;





// Визуализация
{TSystemTVisualization}
Constructor TSystemTVisualization.Create;
begin
CreateNew(idTVisualization,tnTVisualization,TTVisualizationFunctionality);
if Enabled then Cash:=TTVisualizationCash.Create(Self);
end;

Destructor TSystemTVisualization.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTVisualization.Initialize;
begin
if Cash <> nil then Cash.Update;
end;

function TSystemTVisualization.CreateContext(const Owner: TComponentContext): TComponentTypeContext;
begin
Result:=Inherited CreateContext(Owner);
Result.DataFlags:=Result.DataFlags+COMPONENT_DATA_FLAG_NAME;
end;

function TSystemTVisualization.InplaceHintEnabled(): boolean;
begin
Result:=true;
end;


// TTVisualizationCash
Constructor TTVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTVisualizationCash(ptrDelItem^).ptrNext;
  FreeMem
  (ptrDelItem,SizeOf(TItemTVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTVisualizationCash.Update;
begin
Empty;
end;

function TTVisualizationCash.GetOwner(const idObj: integer; var vidTOwner,vidOwner: integer): boolean;
var
  ptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=false;
ptrItem:=GetPtrItem(idObj);
if ptrItem = nil then Exit;
with TItemTVisualizationCash(ptrItem^) do begin
if (idTOwner = 0) OR (idOwner = 0) then Exit; //. ->
vidTOwner:=idTOwner;
vidOwner:=idOwner;
end;
Result:=true;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    ptrObj: TPtr;
    ptrVisObj: TPtr;
  begin
  with TItemTVisualizationCash(ptrItem^) do begin
  if true /// - NOT Space.GlobalSpaceCashDataProvider.T2DVisualizationCash_GetItemByIDObj(idType,idObj, ptrObj,idTOwner,idOwner,ptrVisObj)
   then begin
    idTOwner:=0;
    idOwner:=0;
    end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTVisualizationCash), 0);
  with TItemTVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTVisualizationCash), 0);
    with TItemTVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTVisualizationCash(ptrDelItem^).ptrNext;
    FreeMem(ptrDelItem,SizeOf(TItemTVisualizationCash));
    //. remove all the same items Exit;
    end
   else
    ptrptrDelItem:=@TItemTVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;





// Визуализация
{TSystemTTTFVisualization}
Constructor TSystemTTTFVisualization.Create;
begin
CreateNew(idTTTFVisualization,tnTTTFVisualization,TTTTFVisualizationFunctionality);
if Enabled then Cash:=TTTTFVisualizationCash.Create(Self);
end;

Destructor TSystemTTTFVisualization.Destroy;
begin
Cash.Free;
if Enabled then UnRegisterTTF;
Inherited;
end;

procedure TSystemTTTFVisualization.Initialize;
begin
if Enabled then RegisterTTF;
if Cash <> nil then Cash.Update;
end;

procedure TSystemTTTFVisualization.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;

procedure TSystemTTTFVisualization.Caching_Start;
begin
end;

procedure TSystemTTTFVisualization.Caching_AddObject(const idObj: integer);
begin
CachingList.Add(Pointer(idObj));
end;

procedure TSystemTTTFVisualization.Caching_Finish;
var
  List: TList;
  LockedList: TList;
  I: integer;
begin
List:=TList.Create;
try
LockedList:=CachingList.LockList;
try
List.Capacity:=LockedList.Capacity;
for I:=0 to LockedList.Count-1 do List.Add(LockedList[I]);
LockedList.Clear;
finally
CachingList.UnLockList;
end;
if (List.Count > 0)
 then begin
  if (TypesSystem.Context <> nil) then Context_UpdateByItemsList(List);
  Cash.UpdateByObjectsList(List);
  end;
finally
List.Destroy;
end;
end;

function TSystemTTTFVisualization.Context_IsItemExist(const idComponent: integer): boolean;
begin
if (Cash = nil)
 then begin
  Result:=false;
  Exit; //. ->
  end;
Result:=(Cash.GetPtrItem(idComponent) <> nil);
end;

procedure TSystemTTTFVisualization.Context_GetItems(out IDs: TIDArray);
begin
if (Cash = nil)
 then begin
  SetLength(IDs,0);
  Exit; //. ->
  end;
Cash.GetItemsIDs(IDs);
end;

procedure TSystemTTTFVisualization.RegisterTTF;

  procedure Perform(const PathFonts: string);
  var
    sr: TSearchRec;
    FileAttrs: Integer;

    procedure Install(const fnFont: string);
    var
      R: integer;
    begin
    R:=AddFontResource(PChar(fnFont));
    if R <> 0
     then begin
      /// - SendMessage(HWND_BROADCAST,WM_FONTCHANGE,0,0);
      {WriteLn('TTF-font '+fnFont+' installed.')}
      end
     else {WriteLn('! error of TTF-font installing '+fnFont+'.')};
    end;

  begin
  FileAttrs:=faAnyFile;
  if FindFirst(PathFonts+'\*.ttf',FileAttrs, sr) = 0
   then begin
    Install(PathFonts+'\'+sr.Name);
    while FindNext(sr) = 0 do Install(PathFonts+'\'+sr.Name);
    FindClose(sr);
    end;
  end;

begin
Perform(Space.WorkLocale+'\'+PathLib+'\TTF');
end;

procedure TSystemTTTFVisualization.UnRegisterTTF;

  procedure Perform(const PathFonts: string);
  var
    sr: TSearchRec;
    FileAttrs: Integer;

    procedure Remove(const fnFont: string);
    var
      R: Bool;
    begin
    R:=RemoveFontResource(PChar(fnFont));
    if R
     then begin
      /// - SendMessage(HWND_BROADCAST,WM_FONTCHANGE,0,0);
      {WriteLn('TTF-font '+fnFont+' removed.')}
      end
     else {WriteLn('! TTF-font removing error ('+fnFont+').')};
    end;

  begin
  FileAttrs:=faAnyFile;
  if FindFirst(PathFonts+'\*.ttf',FileAttrs, sr) = 0
   then begin
    Remove(PathFonts+'\'+sr.Name);
    while FindNext(sr) = 0 do Remove(PathFonts+'\'+sr.Name);
    FindClose(sr);
    end;
  end;

begin
if Space <> nil then Perform(Space.WorkLocale+'\'+PathLib+'\TTF');
end;


// TTTTFVisualizationCash
Constructor TTTTFVisualizationCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTTTFVisualizationCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTTTFVisualizationCash.Empty;
var
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTTTFVisualizationCash(ptrDelItem^).ptrNext;
  with TItemTTTFVisualizationCash(ptrDelItem^) do begin
  Str:='';
  Font_Name:='';
  end;
  FreeMem(ptrDelItem,SizeOf(TItemTTTFVisualizationCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTTTFVisualizationCash.UpdateByObjectsList(List: TList);
var
  I: integer;
  ptrNewItem: pointer;
  CF: TTTFVisualizationFunctionality;
  WS,WS1: WideString;
  ptrActionsGroup: pointer;
  ItemsList: TList;
begin
if List.Count = 0 then Exit; //. ->
if NOT Space.flActionsGroupCall OR (List.Count = 1)
 then
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTTTFVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTTTFVisualizationCash), 0);
    with TItemTTTFVisualizationCash(ptrNewItem^) do begin
    CF:=TTTFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    CF.GetParams(WS,Font_Width,Font_Height,WS1);
    Str:=WS; Font_Name:=WS1;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    TypeSystem.Lock.Enter;
    try
    TItemTTTFVisualizationCash(ptrNewItem^).ptrNext:=FItems;
    FItems:=ptrNewItem;
    finally
    TypeSystem.Lock.Leave;
    end;
    end
 else begin
  ItemsList:=TList.Create;
  try
  ItemsList.Capacity:=List.Count;
  ptrActionsGroup:=ActionsGroups.ActionsGroup_Start(GetCurrentThreadID);
  try
  try
  for I:=0 to List.Count-1 do begin
    GetMem(ptrNewItem,SizeOf(TItemTTTFVisualizationCash));
    try
    FillChar(ptrNewItem^,SizeOf(TItemTTTFVisualizationCash), 0);
    with TItemTTTFVisualizationCash(ptrNewItem^) do begin
    CF:=TTTFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,Integer(List[I])));
    try
    idObj:=CF.idObj;
    try
    CF.GetParams(WS,Font_Width,Font_Height,WS1);
    Str:=WS; Font_Name:=WS1;
    except
      on E: EActionsGroup do ;
      else Raise; //. =>
      end;
    finally
    CF.Release;
    end;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be prepared for caching',E.Message);
      end;
    ItemsList.Add(ptrNewItem);
    end;
  ActionsGroups.ActionsGroup_Finish(ptrActionsGroup);
  for I:=0 to ItemsList.Count-1 do with TItemTTTFVisualizationCash(ItemsList[I]^) do with TTTFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj)) do
    try
    try
    with TItemTTTFVisualizationCash(ItemsList[I]^) do begin
    GetParams(WS,Font_Width,Font_Height,WS1);
    Str:=WS; Font_Name:=WS1;
    end;
    except
      On E: Exception do EventLog.WriteMinorEvent('UpdateByObjectList','Item of '+TypeSystem.TableName+' (ID: '+IntToStr(Integer(List[I]))+') could not be cached',E.Message);
      end;
    finally
    Release;
    end;
  except
    end;
  TypeSystem.Lock.Enter;
  try
  for I:=0 to ItemsList.Count-1 do if ItemsList[I] <> nil then begin
   TItemTTTFVisualizationCash(ItemsList[I]^).ptrNext:=FItems;
   FItems:=ItemsList[I];
   end;
  finally
  TypeSystem.Lock.Leave;
  end;
  finally
  ActionsGroups.ActionsGroup_End(ptrActionsGroup);
  end;
  finally
  ItemsList.Destroy;
  end;
  end;
end;



procedure TTTTFVisualizationCash.Update;
begin
Empty;
end;

function TTTTFVisualizationCash.GetItem(const pidObj: integer; var S: WideString; var vFont_Width,vFont_Height: Double; var vFont_Name: WideString): boolean;
var
  ptrItem: pointer;
  WS: WideString;
  F_N: WideString;
  F_W,F_H: Double;
begin
TypeSystem.Lock.Enter;
try
Result:=false;
ptrItem:=GetPtrItem(pidObj);
if ptrItem = nil
 then begin
  Exit; /// -
  {if Space.GlobalSpaceCashDataProvider.TTTFVisualizationCash_GetItem(pidObj, WS,F_N,F_W,F_H)
   then begin
    GetMem(ptrItem,SizeOf(TItemTTTFVisualizationCash));
    with TItemTTTFVisualizationCash(ptrItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    //. item filling by fetched data
    Str:=WS;
    Font_Name:=F_N;
    Font_Width:=F_W;
    Font_Height:=F_H;
    end;
    FItems:=ptrItem;
    end
   else
    Exit; //. ->}
  end;
with TItemTTTFVisualizationCash(ptrItem^) do begin
S:=Str;
vFont_Width:=Font_Width;
vFont_Height:=Font_Height;
vFont_Name:=Font_Name;
end;
Result:=true;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTTTFVisualizationCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTTTFVisualizationCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTTTFVisualizationCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTTTFVisualizationCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTTTFVisualizationCash.GetItemsIDs(out IDs: TIDArray);
var
  ptrItem: pointer;
  TempList: TList;
  I: integer;
begin
TempList:=TList.Create;
try
TempList.Capacity:=1024; //. inital size
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTTTFVisualizationCash(ptrItem^) do begin
  TempList.Add(Pointer(idObj));
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
SetLength(IDs,TempList.Count);
for I:=0 to TempList.Count-1 do IDs[I]:=Integer(TempList[I]);
finally
TempList.Destroy;
end;
end;

{//. blocking update procedure TTTTFVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TTTFVisualizationFunctionality;
    WS,WS1: WideString;
  begin
  with TItemTTTFVisualizationCash(ptrItem^) do begin
  CF:=TTTFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(WS,Font_Width,Font_Height,WS1);
  Str:=WS; Font_Name:=WS1;
  finally
  CF.Release;
  end;
  end;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTTTFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTTTFVisualizationCash), 0);
  with TItemTTTFVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then UpdateItem(ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTTTFVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTTTFVisualizationCash), 0);
    with TItemTTTFVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    end;
    UpdateItem(ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;}

procedure TTTTFVisualizationCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    CF: TTTFVisualizationFunctionality;
    WS,WS1: WideString;
  begin
  with TItemTTTFVisualizationCash(ptrItem^) do begin
  CF:=TTTFVisualizationFunctionality(TComponentFunctionality_Create(TypeSystem.idType,idObj));
  try
  CF.GetParams(WS,Font_Width,Font_Height,WS1);
  Str:=WS; Font_Name:=WS1;
  finally
  CF.Release;
  end;
  end;
  end;

  procedure MoveItem(const Item: TItemTTTFVisualizationCash; const ptrItem: pointer);
  begin
  with TItemTTTFVisualizationCash(ptrItem^) do begin
  Str:=Item.Str;
  Font_Width:=Item.Font_Width;
  Font_Height:=Item.Font_Height;
  Font_Name:=Item.Font_Name;
  end;
  end;

var
  Item: TItemTTTFVisualizationCash;
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
if (Operation in [opCreate,opUpdate])
 then begin //. retrieving data from server ...
  FillChar(Item,SizeOf(Item), 0);
  Item.idObj:=pidObj;
  UpdateItem(@Item);
  end;
//.
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTTTFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTTTFVisualizationCash), 0);
  with TItemTTTFVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  end;
  MoveItem(Item,ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if (ptrUpdateItem <> nil)
   then MoveItem(Item,ptrUpdateItem)
   else begin
    GetMem(ptrNewItem,SizeOf(TItemTTTFVisualizationCash));
    FillChar(ptrNewItem^,SizeOf(TItemTTTFVisualizationCash), 0);
    with TItemTTTFVisualizationCash(ptrNewItem^) do begin
    ptrNext:=FItems;
    idObj:=pidObj;
    end;
    MoveItem(Item,ptrNewItem);
    FItems:=ptrNewItem;
    end;
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTTTFVisualizationCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTTTFVisualizationCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTTTFVisualizationCash(ptrDelItem^).ptrNext;
    with TItemTTTFVisualizationCash(ptrDelItem^) do begin
    Str:='';
    Font_Name:='';
    end;
    FreeMem(ptrDelItem,SizeOf(TItemTTTFVisualizationCash));
    //. remove all the same items Exit;
    end
   else
    ptrptrDelItem:=@TItemTTTFVisualizationCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTTTFVisualizationCash.SaveItemsDATA(Document: IXMLDOMDocument; ParentNode: IXMLDOMElement);
var
  ptrItem: pointer;
  ItemNode: IXMLDOMElement;
  //.
  PropNode: IXMLDOMElement;
begin
TypeSystem.Lock.Enter;
try
ptrItem:=FItems;
while (ptrItem <> nil) do with TItemTTTFVisualizationCash(ptrItem^) do begin
  //. create item
  ItemNode:=Document.CreateElement('ID'+IntToStr(idObj));
  //.
  PropNode:=Document.CreateElement('Str');              PropNode.nodeTypedValue:=Str;           ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('FontName');         PropNode.nodeTypedValue:=Font_Name;     ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('FontWidth');        PropNode.nodeTypedValue:=Font_Width;    ItemNode.appendChild(PropNode);
  PropNode:=Document.CreateElement('FontHeight');       PropNode.nodeTypedValue:=Font_Height;   ItemNode.appendChild(PropNode);
  //. add item
  ParentNode.appendChild(ItemNode);
  //. next item
  ptrItem:=ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTTTFVisualizationCash.LoadItems(Node: IXMLDOMNode);
var
  I: integer;
  ItemNode: IXMLDOMNode;
  id: integer;
  ptrNewItem: pointer;
  //.
  _Str: string;
  _FontName: string;
  _FontWidth: double;
  _FontHeight: double;
begin   
TypeSystem.Lock.Enter;
try
Empty;
for I:=0 to Node.childNodes.length-1 do begin
  ItemNode:=Node.childNodes[I];
  //. get item id
  id:=ExtractID(ItemNode.NodeName);
  //.
  _Str:=ItemNode.selectSingleNode('Str').nodeTypedValue;
  _FontName:=ItemNode.selectSingleNode('FontName').nodeTypedValue;
  _FontWidth:=ItemNode.selectSingleNode('FontWidth').nodeTypedValue;
  _FontHeight:=ItemNode.selectSingleNode('FontHeight').nodeTypedValue;
  //. create new item and insert
  GetMem(ptrNewItem,SizeOf(TItemTTTFVisualizationCash));
  FillChar(ptrNewItem^,SizeOf(TItemTTTFVisualizationCash), 0);
  with TItemTTTFVisualizationCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=id;
  //.
  Str:=_Str;
  Font_Name:=_FontName;
  Font_Width:=_FontWidth;
  Font_Height:=_FontHeight;
  end;
  FItems:=ptrNewItem;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;





{TSystemTObject}
Constructor TSystemTObject.Create;
begin
CreateNew(idTObject,tnTObject,TTObjectFunctionality);
end;





// Обозначение
{TSystemTLabel}
Constructor TSystemTLabel.Create;
begin
CreateNew(idTLabel,tnTLabel,TTLabelFunctionality);
end;






// Станцикя
{TSystemTStation}
Constructor TSystemTStation.Create;
begin
CreateNew(idTStation,tnTStation,TTStationFunctionality);
end;





// Магистраль
{TSystemTMainLine}
Constructor TSystemTMainLine.Create;
begin
CreateNew(idTMainLine,tnTMainLine,TTMainLineFunctionality);
end;





// Описание
{TSystemTDescription}
Constructor TSystemTDescription.Create;
begin
CreateNew(idTDescription,tnTDescription,TTDescriptionFunctionality);
end;





// Изображение
{TSystemTImage}
Constructor TSystemTImage.Create;
begin
CreateNew(idTImage,tnTImage,TTImageFunctionality);
end;





// Колодец
{TSystemTWell}
Constructor TSystemTWell.Create;
begin
CreateNew(idTWell,tnTWell,TTWellFunctionality);
end;





// телефон
{TSystemTTLF}
Constructor TSystemTTLF.Create;
begin
CreateNew(idTTLF,tnTTLF,TTTLFFunctionality);
end;





// Коробка распределительная
{TSystemTBox}
Constructor TSystemTBox.Create;
begin
CreateNew(idTBox,tnTBox,TTBoxFunctionality);
end;





// Кабельный ящик
{TSystemTCableBox}
Constructor TSystemTCableBox.Create;
begin
CreateNew(idTCableBox,tnTCableBox,TTCableBoxFunctionality);
end;





// Распределениек
{TSystemTDistrLine}
Constructor TSystemTDistrLine.Create;
begin
CreateNew(idTDistrLine,tnTDistrLine,TTDistrLineFunctionality);
end;





{TSystemTCommLine}
Constructor TSystemTCommLine.Create;
begin
CreateNew(idTCommLine,tnTCommLine,TTCommLineFunctionality);
end;





// Клиент
{TSystemTClient}
Constructor TSystemTClient.Create;
begin
CreateNew(idTClient,tnTClient,TTClientFunctionality);
end;





// Дом
{TSystemTHouse}
Constructor TSystemTHouse.Create;
begin
CreateNew(idTHouse,tnTHouse,TTHouseFunctionality);
end;





// Узел электросвязи
{TSystemTCommNode}
Constructor TSystemTCommNode.Create;
begin
CreateNew(idTCommNode,tnTCommNode,TTCommNodeFunctionality);
end;





// Кросс
{TSystemTCross}
Constructor TSystemTCross.Create;
begin
CreateNew(idTCross,tnTCross,TTCrossFunctionality);
end;





// Шкаф
{TSystemTCase}
Constructor TSystemTCase.Create;
begin
CreateNew(idTCase,tnTCase,TTCaseFunctionality);
end;





// Улица
{TSystemTStreet}
Constructor TSystemTStreet.Create;
begin
CreateNew(idTStreet,tnTStreet,TTStreetFunctionality);
end;





// Разное
{TSystemTOtherObj}
Constructor TSystemTOtherObj.Create;
begin
CreateNew(idTOtherObj,tnTOtherObj,TTOtherObjFunctionality);
end;





// Пролёт
{TSystemTSpan}
Constructor TSystemTSpan.Create;
begin
CreateNew(idTSpan,tnTSpan,TTSpanFunctionality);
end;





// Канал
{TSystemTChanel}
Constructor TSystemTChanel.Create;
begin
CreateNew(idTChanel,tnTChanel,TTChanelFunctionality);
end;





// Опора
{TSystemTHandHold}
Constructor TSystemTHandHold.Create;
begin
CreateNew(idTHandHold,tnTHandHold,TTHandHoldFunctionality);
end;





// Линия расстояния
{TSystemTLineDist}
Constructor TSystemTLineDist.Create;
begin
CreateNew(idTLineDist,tnTLineDist,TTLineDistFunctionality);
end;





//  Муфта
{TSystemTMuff}
Constructor TSystemTMuff.Create;
begin
CreateNew(idTMuff,tnTMuff,TTMuffFunctionality);
end;





// Предложение
{TSystemTOffer}
Constructor TSystemTOffer.Create;
begin
CreateNew(idTOffer,tnTOffer,TTOfferFunctionality);
end;





// Заявка
{TSystemTDemand}
Constructor TSystemTDemand.Create;
begin
CreateNew(idTDemand,tnTDemand,TTDemandFunctionality);
end;





// Товар
{TSystemTGoods}
Constructor TSystemTGoods.Create;
begin
CreateNew(idTGoods,tnTGoods,TTGoodsFunctionality);
if Enabled then Cash:=TTGoodsCash.Create(Self);
end;

Destructor TSystemTGoods.Destroy;
begin
Cash.Free;
Inherited;
end;

procedure TSystemTGoods.Initialize;
begin
if Cash <> nil then Cash.Update;
end;


// TTGoodsCash
Constructor TTGoodsCash.Create(pTypeSystem: TTypeSystem);
begin
Inherited;
FItems:=nil;
end;

destructor TTGoodsCash.Destroy;
begin
Empty;
Inherited;
end;

procedure TTGoodsCash.Empty;
var
  ptrDelItem: pointer;
  ptrDelName: pointer;
  DelNameSize: word;
begin
TypeSystem.Lock.Enter;
try
while FItems <> nil do begin
  ptrDelItem:=FItems;
  FItems:=TItemTGoodsCash(ptrDelItem^).ptrNext;
  //. освобождаем память под DelName
  ptrDelName:=TItemTGoodsCash(ptrDelItem^).ptrName;
  DelNameSize:=Word(ptrDelName^)+SizeOf(DelNameSize);
  FreeMem(ptrDelName,DelNameSize);
  //. освобождаем память под DelItem
  FreeMem(ptrDelItem,SizeOf(TItemTGoodsCash));
  end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTGoodsCash.Update;
var
  ptrNewItem: pointer;
  _Name: string;
  NameSize: word;
  ptrName: pointer;
begin
Empty;
TypeSystem.Lock.Enter;
try
//. do not full update when proxyspace connected remoted
if Space.Status in [pssRemoted,pssRemotedBrief] then Exit; //. ->
//.
{///cwith Space.TObjPropsQuery_Create do
try
SelectDataBase(idGoodsDB);
EnterSQL('SELECT * FROM '+TypeSystem.TableName);
Open;
while NOT EOF do begin
  GetMem(ptrNewItem,SizeOf(TItemTGoodsCash));
  TItemTGoodsCash(ptrNewItem^).idObj:=FieldValues['Key_'];
  try _Name:=FieldValues['Name'] except _Name:=''; end;
  //. записываем Name
  NameSize:=Length(_Name);
  GetMem(ptrName,SizeOf(NameSize)+NameSize);
  asm
        PUSH EDI
        PUSH ESI
        MOV EDI,ptrName
        MOV AX,NameSize
        CLD
        STOSW
        XOR ECX,ECX
        MOV CX,AX
        LEA ESI,_Name
        INC ESI //. skip stringSize
        REP MOVSB
        POP ESI
        POP EDI
  end;
  TItemTGoodsCash(ptrNewItem^).ptrName:=ptrName;

  TItemTGoodsCash(ptrNewItem^).ptrNext:=FItems;
  FItems:=ptrNewItem;

  Next;
  End;
finally
Destroy;
end;}
finally
TypeSystem.Lock.Leave;
end;
end;

function TTGoodsCash.GetItemByPtr(const ptrItem: pointer; var Name: string): boolean;
var
  ptrName: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=false;
//. fetch Name
ptrName:=TItemTGoodsCash(ptrItem^).ptrName;
asm
        PUSH EDI
        PUSH ESI
        MOV ESI,ptrName
        CLD
        LODSW //. get StringSize
        MOV EDI,Name
        STOSB //. set stringSize
        XOR ECX,ECX
        MOV CL,AL
        REP MOVSB
        POP ESI
        POP EDI
end;
Result:=true;
finally
TypeSystem.Lock.Leave;
end;
end;

function TTGoodsCash.GetItem(const idObj: integer; var Name: string): boolean;
var
  ptrItem: pointer;
  ptrName: pointer;
begin
Result:=false;
ptrItem:=GetPtrItem(idObj);
if ptrItem = nil then Exit;
Result:=GetItemByPtr(ptrItem, Name);
end;

function TTGoodsCash.GetPtrItem(const pidObj: integer): pointer;
var
  ptrptrItem: pointer;
begin
TypeSystem.Lock.Enter;
try
Result:=nil;
ptrptrItem:=@FItems;
while Pointer(ptrptrItem^) <> nil do with TItemTGoodsCash(Pointer(ptrptrItem^)^) do begin
  if idObj = pidObj
   then begin
    Result:=Pointer(ptrptrItem^);
    Pointer(ptrptrItem^):=ptrNext;
    TItemTGoodsCash(Result^).ptrNext:=FItems;
    FItems:=Result;
    Exit;
    end;
  ptrptrItem:=@ptrNext;
  end;
{Result:=FItems;
while Result <> nil do with TItemTGoodsCash(Result^) do begin
  if idObj = pidObj then Exit;
  Result:=ptrNext;
  end;}
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTGoodsCash.UpdateLocal(const pidObj: integer; const Operation: TComponentOperation);

  procedure UpdateItem(const ptrItem: pointer);
  var
    NewName: string;
    ptrNewName: pointer;
    NewNameSize: word;

    ptrDelItem: pointer;
    ptrDelName: pointer;
    DelNameSize: word;
  begin
  {обновляем Name}
  //. получаем
  {///cwith Space.TObjPropsQuery_Create do
  try
  SelectDataBase(idGoodsDB);
  EnterSQL('SELECT * FROM '+TypeSystem.TableName+' WHERE Key_ = '+IntToStr(TItemTGoodsCash(ptrItem^).idObj));
  Open;
  try NewName:=FieldValues['Name'] except NewName:=''; end;
  finally
  Destroy;
  end;}
  NewNameSize:=Length(NewName);
  GetMem(ptrNewName,SizeOf(NewNameSize)+NewNameSize);
  asm
        PUSH EDI
        PUSH ESI
        MOV EDI,ptrNewName
        MOV AX,NewNameSize
        CLD
        STOSW
        XOR ECX,ECX
        MOV CX,AX
        LEA ESI,NewName
        INC ESI //. skip stringSize
        REP MOVSB
        POP ESI
        POP EDI
  end;
  //. освобождаем память под DelName
  ptrDelName:=TItemTGoodsCash(ptrItem^).ptrName;
  if ptrDelName <> nil
   then begin
    DelNameSize:=Word(ptrDelName^)+SizeOf(DelNameSize);
    FreeMem(ptrDelName,DelNameSize);
    end;
  //. настраиваем указатель
  TItemTGoodsCash(ptrItem^).ptrName:=ptrNewName;
  end;

var
  ptrNewItem: pointer;
  ptrUpdateItem: pointer;
begin
TypeSystem.Lock.Enter;
try
case Operation of
opCreate: begin
  GetMem(ptrNewItem,SizeOf(TItemTGoodsCash));
  with TItemTGoodsCash(ptrNewItem^) do begin
  ptrNext:=FItems;
  idObj:=pidObj;
  ptrName:=nil;
  end;
  UpdateItem(ptrNewItem);
  FItems:=ptrNewItem;
  end;
opUpdate: begin
  ptrUpdateItem:=GetPtrItem(pidObj);
  if ptrUpdateItem <> nil then UpdateItem(ptrUpdateItem) else UpdateLocal(pidObj,opCreate);
  end;
opDestroy: begin
  RemoveItem(pidObj);
  end;
end;
finally
TypeSystem.Lock.Leave;
end;
end;

procedure TTGoodsCash.RemoveItem(const pidObj: integer);
var
  ptrptrDelItem: pointer;
  ptrDelItem: pointer;
  ptrDelName: pointer;
  DelNameSize: word;
begin
TypeSystem.Lock.Enter;
try
ptrptrDelItem:=@FItems;
while Pointer(ptrptrDelItem^) <> nil do with TItemTGoodsCash(Pointer(ptrptrDelItem^)^) do begin
  if idObj = pidObj
   then begin
    ptrDelItem:=Pointer(ptrptrDelItem^);
    Pointer(ptrptrDelItem^):=TItemTGoodsCash(ptrDelItem^).ptrNext;
    //. освобождаем память под DelName
    ptrDelName:=TItemTGoodsCash(ptrDelItem^).ptrName;
    DelNameSize:=Word(ptrDelName^)+SizeOf(DelNameSize);
    FreeMem(ptrDelName,DelNameSize);
    //. освобождаем память под DelItem
    FreeMem(ptrDelItem,SizeOf(TItemTGoodsCash));
    //. remove all the same items Exit;
    end
   else
    ptrptrDelItem:=@TItemTGoodsCash(Pointer(ptrptrDelItem^)^).ptrNext;
  end;
finally
TypeSystem.Lock.Leave;
end;
end;





{TSystemTCollection}
Constructor TSystemTCollection.Create;
begin
CreateNew(idTCollection,tnTCollection,TTCollectionFunctionality);
end;

procedure TSystemTCollection.DoOnComponentOperationLocal(const idTObj,idObj: integer; const Operation: TComponentOperation);
begin
Inherited;
end;







































{$I TypesFunctionalityImplementation.inc}

{$I TypesFunctionalityImportImplementation.inc}










procedure Initialize;
begin
//. инициализация систем типов
SystemTProxyObject:=TSystemTProxyObject.Create;
SystemTName:=TSystemTName.Create;
SystemTVisualization:=TSystemTVisualization.Create;
SystemTTTFVisualization:=TSystemTTTFVisualization.Create;
SystemTObject:=TSystemTObject.Create;
SystemTLabel:=TSystemTLabel.Create;
SystemTStation:=TSystemTStation.Create;
SystemTMainLine:=TSystemTMainLine.Create;
SystemTDescription:=TSystemTDescription.Create;
SystemTImage:=TSystemTImage.Create;
SystemTWell:=TSystemTWell.Create;
SystemTTLF:=TSystemTTLF.Create;
SystemTBox:=TSystemTBox.Create;
SystemTCableBox:=TSystemTCableBox.Create;
SystemTDistrLine:=TSystemTDistrLine.Create;
SystemTClient:=TSystemTClient.Create;
SystemTHouse:=TSystemTHouse.Create;
SystemTCommNode:=TSystemTCommNode.Create;
SystemTCross:=TSystemTCross.Create;
SystemTCase:=TSystemTCase.Create;
SystemTStreet:=TSystemTStreet.Create;
SystemTOtherObj:=TSystemTOtherObj.Create;
SystemTSpan:=TSystemTSpan.Create;
SystemTChanel:=TSystemTChanel.Create;
SystemTHandHold:=TSystemTHandHold.Create;
SystemTLineDist:=TSystemTLineDist.Create;
SystemTMuff:=TSystemTMuff.Create;
SystemTOffer:=TSystemTOffer.Create;
SystemTDemand:=TSystemTDemand.Create;
SystemTCommLine:=TSystemTCommLine.Create;
SystemTGoods:=TSystemTGoods.Create;
SystemTCollection:=TSystemTCollection.Create;
SystemTTLFStationTMT:=TSystemTTLFStationTMT.Create;
SystemTOfferGoods:=TSystemTOfferGoods.Create;
SystemTLay2DVisualization:=TSystemTLay2DVisualization.Create;
SystemTTransportNode:=TSystemTTransportNode.Create;
SystemTTransportRoute:=TSystemTTransportRoute.Create;
SystemTAddress:=TSystemTAddress.Create;
SystemTCoComponentType:=TSystemTCoComponentType.Create;
SystemTCoComponentTypeMarker:=TSystemTCoComponentTypeMarker.Create;
SystemTCoComponent:=TSystemTCoComponent.Create;
SystemTDATAFile:=TSystemTDATAFile.Create;
SystemTMODELUser:=TSystemTMODELUser.Create;
SystemTTexture:=TSystemTTexture.Create;
SystemTBuffered3DVisualization:=TSystemTBuffered3DVisualization.Create;
SystemTSecurityComponent:=TSystemTSecurityComponent.Create;
SystemTSecurityFile:=TSystemTSecurityFile.Create;
SystemTSecurityKey:=TSystemTSecurityKey.Create;
SystemTSecurityComponentOperation:=TSystemTSecurityComponentOperation.Create;
SystemTOffersServer:=TSystemTOffersServer.Create;
SystemTQDCVisualization:=TSystemTQDCVisualization.Create;
SystemTHREF:=TSystemTHREF.Create;
SystemTMessageBoard:=TSystemTMessageBoard.Create;
SystemTMessageBoardMessage:=TSystemTMessageBoardMessage.Create;
SystemTIcon:=TSystemTIcon.Create;
SystemTOrientedTTFVisualization:=TSystemTOrientedTTFVisualization.Create;
SystemTOrientedPictureVisualization:=TSystemTOrientedPictureVisualization.Create;
SystemTMRKVisualization:=TSystemTMRKVisualization.Create;
SystemTWNDVisualization:=TSystemTWNDVisualization.Create;
SystemTTelecomService:=TSystemTTelecomService.Create;
SystemTMarketService:=TSystemTMarketService.Create;
SystemTTransportService:=TSystemTTransportService.Create;
SystemTUsersService:=TSystemTUsersService.Create;
SystemTComponentsFindService:=TSystemTComponentsFindService.Create;
SystemTHyperText:=TSystemTHyperText.Create;
SystemTPrivateAreaVisualization:=TSystemTPrivateAreaVisualization.Create;
SystemTGeodesyPoint:=TSystemTGeodesyPoint.Create;
SystemTRoundVisualization:=TSystemTRoundVisualization.Create;
SystemTPictureVisualization:=TSystemTPictureVisualization.Create;
SystemTWMFVisualization:=TSystemTWMFVisualization.Create;
SystemTEllipseVisualization:=TSystemTEllipseVisualization.Create;
SystemTCELLVisualization:=TSystemTCELLVisualization.Create;
SystemTOrientedWMFVisualization:=TSystemTOrientedWMFVisualization.Create;
SystemTPositioner:=TSystemTPositioner.Create;
SystemTCoReference:=TSystemTCoReference.Create;
SystemTMODELServer:=TSystemTMODELServer.Create;
SystemTOPPVisualization:=TSystemTOPPVisualization.Create;
SystemTOrientedVIDEOVisualization:=TSystemTOrientedVIDEOVisualization.Create;
SystemTVIDEOVisualization:=TSystemTVIDEOVisualization.Create;
SystemTAGIFVisualization:=TSystemTAGIFVisualization.Create;
SystemTBZRVisualization:=TSystemTBZRVisualization.Create;
SystemTHTMLVisualization:=TSystemTHTMLVisualization.Create;
SystemTOLEVisualization:=TSystemTOLEVisualization.Create;
SystemTHREFVisualization:=TSystemTHREFVisualization.Create;
SystemTCUSTOMVisualization:=TSystemTCUSTOMVisualization.Create;
SystemTForum:=TSystemTForum.Create;
SystemTForumMessage:=TSystemTForumMessage.Create;
SystemTCoVisualization:=TSystemTCoVisualization.Create;
SystemTDetailedPictureVisualization:=TSystemTDetailedPictureVisualization.Create;
SystemTHINTVisualization:=TSystemTHINTVisualization.Create;
SystemTFilterVisualization:=TSystemTFilterVisualization.Create;
SystemTGeoCrdSystem:=TSystemTGeoCrdSystem.Create;
SystemTGeoSpace:=TSystemTGeoSpace.Create;
SystemTGeoGraphServer:=TSystemTGeoGraphServer.Create;
SystemTGeoGraphServerObject:=TSystemTGeoGraphServerObject.Create;
SystemTUserAlert:=TSystemTUserAlert.Create;
SystemTBoolVar:=TSystemTBoolVar.Create;
SystemTSPLVisualization:=TSystemTSPLVisualization.Create;
SystemTMapFormatMap:=TSystemTMapFormatMap.Create;
SystemTMapFormatObject:=TSystemTMapFormatObject.Create;
SystemTPatternVisualization:=TSystemTPatternVisualization.Create;
SystemTURL:=TSystemTURL.Create;
SystemTInt32Var:=TSystemTInt32Var.Create;
SystemTDoubleVar:=TSystemTDoubleVar.Create;
SystemTMODELServerVisualization:=TSystemTMODELServerVisualization.Create;
SystemTAreaNotificationServer:=TSystemTAreaNotificationServer.Create;
SystemTMeasurementObject:=TSystemTMeasurementObject.Create;
SystemTTileServerVisualization:=TSystemTTileServerVisualization.Create;
//.
TypesSystem.Initialize;
//.
Types_ImageList:=Types__TImageList_Create;
//.
{$IFNDEF SOAPServer}
UserUnreadMessagesChecking:=TUserUnreadMessagesChecking.Create(TypesSystem);
{$ENDIF}
//. obsolete
LabelsCash:=TLabelsCash.Create(TypesSystem.Space);
if SystemTVisualization.Cash <> nil then SystemTVisualization.Cash.Update; /// - delete this call when obsolete TLabel components has gone away
end;

procedure Finalize;
begin
FreeAndNil(UserUnreadMessagesChecking);
//. finalize user chat boxes
unitUserChat.Finalize;
//.
TypesSystem.Finalize;
end;

procedure ProcessOnInitializationEndTasks;
var
  idMODELServer: integer;
begin
if (TypesSystem.Space.flOffline) then Exit; //. ->
//.
if (TypesSystem.Space.Configuration.flUserMessagesChecking)
 then begin
  UserUnreadMessagesChecking.flForceChecking:=true;
  UserUnreadMessagesChecking.Resume;
  end
 else
  UserUnreadMessagesChecking.Suspend;
//.
UserChatBoxes:=TUserChatBoxes.Create(TypesSystem.Space);
//. insert current data-server into history
with TTMODELServerFunctionality.Create do
try
if GetInstanceByIPAddress(TypesSystem.Space.SOAPServerURL, idMODELServer)
 then with TMODELServerFunctionality(TComponentFunctionality_Create(idMODELServer)) do
  try
  with TModelServersHistory.Create do
  try
  Insert(Name,IPAddress,Space.ID,Info,Space.UserName,Space.UserPassword);
  finally
  Destroy;
  end;
  finally
  Release;
  end
 else with TModelServersHistory.Create do
  try
  Insert('?',Space.SOAPServerURL,Space.ID,'',Space.UserName,Space.UserPassword);
  finally
  Destroy;
  end;
finally
Release;
end;
//.
end;












{$I TypesFunctionalityExportImplementation.inc}








Initialization


Finalization
//.
Types_ImageList.Free;
//. obsolete
LabelsCash.Free;
end.

